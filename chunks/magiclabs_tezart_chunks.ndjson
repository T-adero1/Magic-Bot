{"code": "TEZOS_NODE_URL=http://localhost:20000\nORIGINATOR_SK=edskRpm2mUhvoUjHjXgMoDRxMKhtKfww1ixmWiHCWhHuMEEbGzdnz8Ks4vgarKDtxok7HmrEo1JzkXkdkvyw7Rtw6BNtSd7MJ7", "explanation": "**Summary**\n\nThis block sets environment variables for a Tezos node:\n\n* `TEZOS_NODE_URL`: specifies the URL of the local Tezos node at http://localhost:20000.\n* `ORIGINATOR_SK`: assigns a secret key (edskRpm2mUhvoUjHjXgMoDRxMKhtKfww1ixmWiHCWhHuMEEbGzdnz8Ks4vgarKDtxok7HmrEo1JzkXkdkvyw7Rtw6BNtSd7MJ) to the originator.", "metadata": {"repo": "magiclabs/tezart", "file": ".env.dist", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\nThe '.env.dist' file sets environment variables for a Tezos node, including its URL (http://localhost:20000) and an originator's secret key."}
{"code": "queue_rules:\n  - name: default\n    conditions:\n      # https://docs.mergify.io/conditions.html#github-actions\n      - check-success=Run tests\n\npull_request_rules:\n\n  - name: merge using the merge queue\n    conditions:\n      - base=main\n      - check-success=Run tests\n    actions:\n      queue:\n        name: default\n        \n  - name: say hi on new contribution\n    conditions:\n      - author!=@moneytrackio/regularcontributors\n    actions:\n        comment:\n          message: |\n              Welcome to our great project Tezart!\n              We're delighted to have you onboard <3\n\n  - name: ask to resolve conflict\n    conditions:\n      - conflict\n    actions:\n        comment:\n          message: This pull request is now in conflicts. Could you fix it @{{author}}? \ud83d\ude4f", "explanation": "Here is a concise summary of the block's purpose and functionality:\n\n**Mergify Configuration Block**\n\nThis block configures Mergify, a GitHub tool for automating pull request management.\n\n* It defines rules for pull requests based on conditions and actions.\n* The rules include:\n\t+ A default rule that requires tests to pass before merging.\n\t+ A merge queue rule that queues PRs with successful tests for review.\n\t+ A rule that comments \"Welcome\" on new contributions from non-regular contributors.\n\t+ A rule that asks the author to resolve conflicts.", "metadata": {"repo": "magiclabs/tezart", "file": ".github/mergify.yml", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file '.github/mergify.yml':\n\n**Mergify Configuration File**\n\nThis YAML file configures Mergify, automating pull request management on GitHub with rules for testing, queuing, commenting, and conflict resolution."}
{"code": "TEZOS_NODE_URL=http://localhost:20000/\nORIGINATOR_SK=edskRpm2mUhvoUjHjXgMoDRxMKhtKfww1ixmWiHCWhHuMEEbGzdnz8Ks4vgarKDtxok7HmrEo1JzkXkdkvyw7Rtw6BNtSd7MJ7\nLOG_LEVEL=INFO", "explanation": "This block appears to be a configuration snippet, likely for an environment variable setup.\n\n**Purpose:** Set environment variables for a Tezos node.\n\n**Functionality:** Defines three variables:\n\n1. `TEZOS_NODE_URL`: sets the URL of a local Tezos node.\n2. `ORIGINATOR_SK`: stores a private key (SK) for originator transactions.\n3. `LOG_LEVEL`: sets the logging level to INFO.", "metadata": {"repo": "magiclabs/tezart", "file": ".github/workflows/.env.ci", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n`.github/workflows/.env.ci` configures environment variables for a Tezos node setup, defining three key variables: TEZOS_NODE_URL, ORIGINATOR_SK, and LOG_LEVEL."}
{"code": "name: Publish package to pub.dev\non:\n  # Trigger the workflow on pull requests on publish branch\n  pull_request:\n    branches:   \n      - main\n  push:\n    branches:\n      - main\n      \njobs:\n  build:\n    runs-on: ubuntu-latest\n    container:\n      image:  google/dart:latest\n    steps:\n    - uses: actions/checkout@v1\n    - name: Setup credentials\n      run: | \n        mkdir -p ~/.pub-cache \n        cat <<EOF > ~/.pub-cache/credentials.json\n        {\n          \"accessToken\":\"${{ secrets.OAUTH_ACCESS_TOKEN }}\",\n          \"refreshToken\":\"${{ secrets.OAUTH_REFRESH_TOKEN }}\",\n          \"tokenEndpoint\":\"https://accounts.google.com/o/oauth2/token\",\n          \"scopes\": [ \"openid\", \"https://www.googleapis.com/auth/userinfo.email\" ],\n          \"expiration\": 1570721159347\n        }\n        EOF\n    - name: Publish package\n      run: pub publish -f", "explanation": "Here is a concise summary:\n\n**Purpose:** Automate publishing of a Dart package to pub.dev.\n\n**Functionality:** Triggers on push or pull requests to the main branch, builds and publishes the package using Google's Dart image and OAuth credentials.", "metadata": {"repo": "magiclabs/tezart", "file": ".github/workflows/publish.yml", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file `.github/workflows/publish.yml`:\n\n**Publishing Workflow:**\nAutomates publishing of a Dart package to pub.dev on push or pull requests to main branch, utilizing Google's Dart image and OAuth credentials."}
{"code": "name: Run tests\n\non:\n  # Trigger the workflow on push or pull request\n  push:\n    branches:\n      - main\n      - v1\n  pull_request:\n\njobs:\n  unit_tests:\n    name: Unit tests\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n      matrix:\n        sdk: [2.15.1]\n\n    services:\n      flextesa:\n        image: moneytrack/flextesa:latest\n        ports:\n        - 20000:20000\n        options: >-\n          -e block_time=2\n    steps:\n    - name: Git checkout\n      uses: actions/checkout@v2\n\n    - uses: dart-lang/setup-dart@v1.0\n      with:\n        sdk: ${{ matrix.sdk }}\n\n    - name: Dart pub get\n      run: dart pub get\n\n    - name: Documentation generation check\n      run: |\n        pub global activate dartdoc\n        $HOME/.pub-cache/bin/dartdoc\n\n    - name: Dart tests\n      run: |\n        cp .github/workflows/.env.ci .env.test\n        ./tezart coverage\n\n    - name: Collect the code coverage\n      uses: codecov/codecov-action@v1.2.1\n      with:\n        token: ${{secrets.CODECOV_TOKEN}} #required\n        file: ./coverage/lcov.info\n", "explanation": "**Purpose:** Run automated tests for a Dart application on push or pull requests to main, v1, and other branches.\n\n**Functionality:** This GitHub Actions workflow runs unit tests using Dart SDK 2.15.1, deploys a service (flextesa), checks documentation generation, and reports code coverage using Codecov.", "metadata": {"repo": "magiclabs/tezart", "file": ".github/workflows/test.yml", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file '.github/workflows/test.yml':\n\n**Summary:** This GitHub Actions workflow automates testing for a Dart app, running unit tests, deploying a service, checking documentation, analyzing code coverage, and package analysis on push or pull requests to specific branches."}
{"code": "    - name: Analyse the package with pana\n      run: |\n        ./tezart pana", "explanation": "This block runs a command to analyze a package using the \"pana\" tool.", "metadata": {"repo": "magiclabs/tezart", "file": ".github/workflows/test.yml", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file '.github/workflows/test.yml':\n\n**Summary:** This GitHub Actions workflow automates testing for a Dart app, running unit tests, deploying a service, checking documentation, analyzing code coverage, and package analysis on push or pull requests to specific branches."}
{"code": "# This file tracks properties of this Flutter project.\n# Used by Flutter tool to assess capabilities and perform upgrades etc.\n#\n# This file should be version controlled and should not be manually edited.\n\nversion:\n  revision: 78910062997c3a836feee883712c241a5fd22983\n  channel: stable\n\nproject_type: package\n", "explanation": "Here is a concise summary:\n\nThis file (pubspec.lock) tracks project properties for Flutter, enabling tool usage and upgrades. It should be version-controlled and not manually edited.", "metadata": {"repo": "magiclabs/tezart", "file": ".metadata", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Unfortunately, you didn't provide code block summaries related to the file '.metadata'. However, I can try to create a summary based on general knowledge about this file.\n\nThe `.metadata` file in Flutter is used for tracking project metadata. \n\nPlease provide the actual summaries if you'd like me to recreate it based on your input."}
{"code": "## [2.0.4]\n\n### Added\n- manage comb pairs\n\n### Changed\n\n### Fixed\n\n\n## [2.0.3]\n\n### Added\n\n### Changed\n\n### Fixed\n- add sleep on operation monitor\n\n## [2.0.2]\n\n### Added\n\n### Changed\n\n### Fixed\n- retry http get requests on SocketException\n\n## [2.0.1]\n\n### Added\n\n### Changed\n\n### Fixed\n- change doc to docs at root level to allow github pages build process\n\n## [2.0.0]\n\n### Added\n\n### Changed\n- replace Uint8List by ByteList after breaking change introduced in pinacl\n\n### Fixed\n\n## [1.0.1]\n\n### Added\n- custom gas limit\n- custom storage limit\n\n### Changed\n\n### Fixed\n\n## [1.0.0]\n\n### Added\n- micheline codec\n- contract call\n- contract origination\n- gas limit, storage limit, fees computation\n\n### Changed\n- BREAKING CHANGE: TezartClient doesn't inject the operations anymore. This responsability moved to OperationsList\n\n### Fixed\n\n## [0.2.1]\n\n### Added\n\n### Changed\n- increase minimum required dart version to 2.11\n- BREAKING CHANGE: change TezartClient constructor parameters to a single one:\\\n  BEFORE: `TezartClient(host: 'localhost', scheme: 'http', port: '20000');`\\", "explanation": "**Summary**\n\nThis block appears to be a changelog for a Dart library, likely TezarTClient. It lists major updates across different versions (2.0.x, 1.0.x, 0.2.x) with notes on added features, changed functionality, and bug fixes.", "metadata": {"repo": "magiclabs/tezart", "file": "CHANGELOG.md", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise holistic summary of the file 'CHANGELOG.md':\n\n**CHANGELOG.md Summary**\n\nThis changelog documents major updates across versions 2.0.x, 1.0.x, and 0.2.x of a Dart library (TezarTClient), highlighting added features, functionality changes, and bug fixes."}
{"code": "  AFTER: `TezartClient('http://localhost:20000');`\n\n### Fixed\n\n## [0.2.0]\n\n### Added\n- initial release of the open source project.\n\n### Changed\n\n### Fixed\n", "explanation": "**Summary**: This block initializes a Tezart client instance.", "metadata": {"repo": "magiclabs/tezart", "file": "CHANGELOG.md", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise holistic summary of the file 'CHANGELOG.md':\n\n**CHANGELOG.md Summary**\n\nThis changelog documents major updates across versions 2.0.x, 1.0.x, and 0.2.x of a Dart library (TezarTClient), highlighting added features, functionality changes, and bug fixes."}
{"code": "# Contributing\n\nWhen contributing to this repository, please first discuss the change you wish to make via [issue](https://github.com/moneytrackio/tezart/issues/new).\n\nPlease note we have a code of conduct, please follow it in all your interactions with the project.\n\n## How to ? \n\nEnsure to follow the information provided in the [official documentation](https://moneytrackio.github.io/tezart/?id=contribute)\n\n## Code of Conduct\n\n### Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to making participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, gender identity and expression, level of experience,\nnationality, personal appearance, race, religion, or sexual identity and\norientation.\n\n### Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Using welcoming and inclusive language", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Guidelines for contributing to a repository, outlining how to contribute and expected code of conduct.\n\n**Functionality:** A set of instructions on how to collaborate with the project, including submitting issues and following a code of conduct that promotes a harassment-free environment.", "metadata": {"repo": "magiclabs/tezart", "file": "CONTRIBUTING.md", "chunk_number": 1, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**Purpose:** Establish community guidelines for respectful interaction.\n\n**Functionality:** Define acceptable behavior, enforce standards through project maintainers, and take corrective action against unacceptable behavior."}
{"code": "* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\nadvances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\n  address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n### Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or", "explanation": "Here is a concise summary:\n\n**Purpose:** Establish community guidelines for respectful interaction and prevent harassment.\n\n**Functionality:** Define acceptable behavior, enforce standards through project maintainers, and take corrective action against unacceptable behavior.", "metadata": {"repo": "magiclabs/tezart", "file": "CONTRIBUTING.md", "chunk_number": 2, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**Purpose:** Establish community guidelines for respectful interaction.\n\n**Functionality:** Define acceptable behavior, enforce standards through project maintainers, and take corrective action against unacceptable behavior."}
{"code": "reject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n### Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community. Examples of\nrepresenting a project or community include using an official project e-mail\naddress, posting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event. Representation of a project may be\nfurther defined and clarified by project maintainers.\n\n### Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project team at [INSERT EMAIL ADDRESS]. All\ncomplaints will be reviewed and investigated and will result in a response that", "explanation": "**Summary:**\n\nThis block outlines the purpose and scope of a Code of Conduct, which is to reject or ban contributors who engage in unacceptable behavior, including comments, commits, code, wiki edits, issues, and other contributions that are not aligned with the conduct rules. The enforcement process involves reporting instances of abusive behavior to the project team via email, which will review and investigate complaints.", "metadata": {"repo": "magiclabs/tezart", "file": "CONTRIBUTING.md", "chunk_number": 3, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**Purpose:** Establish community guidelines for respectful interaction.\n\n**Functionality:** Define acceptable behavior, enforce standards through project maintainers, and take corrective action against unacceptable behavior."}
{"code": "is deemed necessary and appropriate to the circumstances. The project team is\nobligated to maintain confidentiality with regard to the reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n### Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\navailable at [http://contributor-covenant.org/version/1/4][version]\n\n[homepage]: http://contributor-covenant.org\n[version]: http://contributor-covenant.org/version/1/4/", "explanation": "**Summary:** This block outlines a project's Code of Conduct, emphasizing confidentiality for incident reporters, accountability for maintainers who fail to enforce it, and referencing a adapted version from Contributor Covenant.", "metadata": {"repo": "magiclabs/tezart", "file": "CONTRIBUTING.md", "chunk_number": 4, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**Purpose:** Establish community guidelines for respectful interaction.\n\n**Functionality:** Define acceptable behavior, enforce standards through project maintainers, and take corrective action against unacceptable behavior."}
{"code": "# Tezart\n\n[![Dart env](https://img.shields.io/static/v1?label=License&message=MIT&color=blue)](https://github.com/moneytrackio/tezart/blob/main/LICENSE)\n[![GitHub Actions](https://github.com/moneytrackio/tezart/workflows/Run%20tests/badge.svg)](https://github.com/moneytrackio/tezart/actions?query=workflow%3A%22Run+tests%22)\n[![Coverage with codecov.io](https://codecov.io/gh/moneytrackio/tezart/branch/main/graph/badge.svg?token=0BOIGV5QCT)](https://codecov.io/gh/moneytrackio/tezart)\n\n## What it is \n\n[Tezart](https://github.com/moneytrackio/tezart) is a [Dart](https://dart.dev/) library for building decentralized applications on [Tezos](https://tezos.com) blockchain.\n\nTezart interacts with a Tezos node to send transactions, interact with smart contracts and much more!\n\nSee the [Quick start](https://moneytrackio.github.io/tezart/#/?id=quick-start) guide for more details.\n\n## Links\n\n- [Documentation](https://moneytrackio.github.io/tezart/)", "explanation": "Here is a concise summary:\n\n**Purpose:** Tezart is a Dart library for building decentralized applications on the Tezos blockchain.\n**Functionality:** Interacts with a Tezos node to send transactions, interact with smart contracts, and more.", "metadata": {"repo": "magiclabs/tezart", "file": "README.md", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'README.md':\n\n**About Tezart:** A Dart library for building decentralized applications on the Tezos blockchain, enabling interactions with the network through transactions and smart contract integration.\n\nNote: I combined the two summaries you provided into one, focusing on the purpose and functionality of Tezart. Let me know if this meets your requirements!"}
{"code": "- [Contribution](https://moneytrackio.github.io/tezart/#/?id=contribute)\n- [Architecture](https://github.com/moneytrackio/tezart/blob/main/docs/ARCHITECTURE.md)\n<!--- - API Reference  API Reference will be available when the package is published to pub.dev --> \n\n## Feature requests and bugs \n\nIf you want to contribute to this project, read the [code of conduct](https://github.com/moneytrackio/tezart/blob/main/CONTRIBUTING.md).\n\nFeature requests and bugs at the [issue tracker](https://github.com/moneytrackio/tezart/issues/new).\n\n## License\n\n[MIT](https://github.com/moneytrackio/tezart/blob/main/LICENSE)\n\n## Special thanks\n\nThanks to [Tezos Foundation](https://tezos.foundation) for supporting this project.\n\nTheses Tezos libraries have been great references, kudos to their maintainers:\n\n- https://github.com/ecadlabs/taquito\n- https://github.com/Cryptonomic/ConseilJS\n- https://github.com/moneytrackio/tezos_client\n", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Summary**: A collection of links and information related to contributing to a Tezos project called \"Tezart\". It outlines contribution guidelines, architectural documentation, feature requests, bug reporting, and acknowledgments.", "metadata": {"repo": "magiclabs/tezart", "file": "README.md", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'README.md':\n\n**About Tezart:** A Dart library for building decentralized applications on the Tezos blockchain, enabling interactions with the network through transactions and smart contract integration.\n\nNote: I combined the two summaries you provided into one, focusing on the purpose and functionality of Tezart. Let me know if this meets your requirements!"}
{"code": "include: package:lints/recommended.yaml\n\nlinter:\n  rules:\n    - unnecessary_await_in_return\n    ", "explanation": "**Summary**\n\nThis block is a configuration for a linter (code validator) that includes recommended linting rules from a YAML file (`package:lints/recommended.yaml`). The rules include checking for unnecessary `await` statements in return expressions.", "metadata": {"repo": "magiclabs/tezart", "file": "analysis_options.yaml", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'analysis_options.yaml':\n\nConfiguration for linter with recommended rules, including checking for unnecessary await statements."}
{"code": "\ntags:\n  unstable:\n    retry: 3\n", "explanation": "This block specifies a configuration setting for an \"unstable\" entity, with a single key-value pair: `retry` is set to `3`, indicating that a failed operation should be retried up to 3 times.", "metadata": {"repo": "magiclabs/tezart", "file": "dart_test.yaml", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'dart_test.yaml' in concise terms:\n\n**Configuration File:** dart_test.yaml\n\n**Settings:** Unstable entity retry configuration with `retry` set to `3`."}
{"code": "dartdoc:\n  showUndocumentedCategories: true\n  errors:\n    - unresolved-doc-reference\n    - ambiguous-doc-reference\n    - broken-link\n    - missing-from-search-index\n    - no-canonical-found\n    - orphaned-file\n    - reexported-private-api-across-packages\n    - unknown-directive\n    - unknown-file\n    - unknown-macro\n    - unresolved-doc-reference\n    - package\n  linkToSource:\n    root: '.'\n    uriTemplate: 'https://github.com/moneytrackio/tezart/blob/main/%f%#L%l%'", "explanation": "Here is a concise summary:\n\nThis block configures Dartdoc, a documentation generator for Dart code, to display undocumented categories and specify error types and link settings.", "metadata": {"repo": "magiclabs/tezart", "file": "dartdoc_options.yaml", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Based on the provided summaries, here's a concise and holistic summary of the file 'dartdoc_options.yaml':\n\n\"This configuration file sets up Dartdoc to show all categories, regardless of documentation status, and specifies how errors and links should be handled.\""}
{"code": "## Technical Architecture of the project\n\n### Tezart is a Dart package\n\nOne of the most important choices made while creating this project , was to provide **tezart** as **dart** [library package](https://dart.dev/tools/pub/glossary#library-package). That means **Tezart** is a package that other packages or applications can depend on. \nTo clarify the purpose, you need to use **tezart** in a Flutter application or dart application which are an entrypoint ( usually with a `.dart` file that contains `main()` )\n\n### Implementation choices \n\nThe project follows the convention to have all the implementation code placed under `lib/src`. \n\nWe have create an organization under `lib/src` according to the features provided by this package :  \n\n    \u251c\u2500\u2500 lib\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 src\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 common\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 feature-1\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 feature-2\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 ...\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 feature-n\n\n", "explanation": "**Purpose:** Tezart is a Dart package designed for other packages or applications to depend on.\n\n**Functionality:** It provides a library that can be used in Flutter or Dart applications, with implementation code organized under `lib/src` according to features.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/ARCHITECTURE.md", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'docs/ARCHITECTURE.md':\n\n**Tezart Architecture:**\n\nThe Tezart Dart package organizes code into small mini-libraries, improving maintainability, extensibility, and testability. Features are separated under `lib/src` and their APIs must be exported from `tezart.dart` to make them public."}
{"code": "The code under `lib/src` is considered **private**; To make any APIs provided under `lib/src` **public**, you must export them from the `tezart.dart` file that's directly under `lib/` \n\n\n### Tezart as mini librairies\n\nOne of the best practices while building a dart package is to break the package into small and individual librairies. Therefore, **Tezart** will be easy to maintain, extend and test. \n\nSo, according to our organization under `lib/src` , each feature is in its own mini library. **This one is very important for the project architecture ! We are trying to avoid tighly coupled between features**\n\n    \u251c\u2500\u2500 lib\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 src\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 common\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 feature-1 ( one mini-library )\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 feature-2 ( another mini-library )\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 ...\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 feature-n ( yet another mini-library )\n\nTo make any feature or API public, the `tezart.dart` file directly under `lib/` must export it : \n\n```dart\nexport 'src/file_feature_1.dart'\nexport 'src/file_feature_2.dart'\n...", "explanation": "Here is a concise summary:\n\n**Purpose:** Organize Tezart code into small, individual mini-libraries to improve maintainability, extensibility, and testability.\n\n**Functionality:** Features are separated under `lib/src` (e.g., `feature-1`, `feature-2`, etc.), and to make them public, their APIs must be exported from the `tezart.dart` file.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/ARCHITECTURE.md", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'docs/ARCHITECTURE.md':\n\n**Tezart Architecture:**\n\nThe Tezart Dart package organizes code into small mini-libraries, improving maintainability, extensibility, and testability. Features are separated under `lib/src` and their APIs must be exported from `tezart.dart` to make them public."}
{"code": "export 'src/file_feature_n.dart'\n```\n\n### Calling RPCs\n\nTo interact with the blockchain, we have decided to clearly list the RCPs calls that we will be interacting with in `lib/src/core/rpc/impl/rpc_interface_paths.dart`.\n\nFor better library maintenance, **please declare the RPCS interfaces you use in that file.**\n\n", "explanation": "**Summary:**\n\nThis block is a code snippet that exports a Dart file named \"file_feature_n\" from another location (\"src/\"). The surrounding text describes how to interact with the blockchain using RPC (Remote Procedure Call) calls, specifically asking users to list used RPC interfaces in a designated file for library maintenance.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/ARCHITECTURE.md", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'docs/ARCHITECTURE.md':\n\n**Tezart Architecture:**\n\nThe Tezart Dart package organizes code into small mini-libraries, improving maintainability, extensibility, and testability. Features are separated under `lib/src` and their APIs must be exported from `tezart.dart` to make them public."}
{"code": "## Tezart\n\n[![Dart env](https://img.shields.io/static/v1?label=License&message=MIT&color=blue)](https://github.com/moneytrackio/tezart/blob/main/LICENSE)\n[![GitHub Actions](https://github.com/moneytrackio/tezart/workflows/Run%20tests/badge.svg)](https://github.com/moneytrackio/tezart/actions?query=workflow%3A%22Run+tests%22)\n[![Coverage with codecov.io](https://codecov.io/gh/moneytrackio/tezart/branch/main/graph/badge.svg?token=0BOIGV5QCT)](https://codecov.io/gh/moneytrackio/tezart)\n\n[filename](parts/_introduction.md ':include')\n\n[filename](parts/_quickstart.md ':include')\n\n[filename](parts/_api_overview_and_examples.md ':include')\n\n[filename](parts/_api_reference.md ':include')\n\n[filename](parts/_contribute.md ':include')", "explanation": "This block is likely documentation for a software project, specifically Tezart. It appears to be a brief introduction to the project, including links to other documents that provide more detailed information on how to get started, use the API, and contribute to the project.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/README.md", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary of the file 'docs/README.md':\n\n**Introduction to Tezart**\n\nThis is an introductory guide to Tezart, providing links to further documentation for getting started, using the API, and contributing to the project."}
{"code": "<img src=\"img/logo.png?raw=true\" style=\"width: 100px;\"></img>\n\n# Tezart <small>2.0.4</small>\n\n> A magic way to interact with the Tezos blockchain using [dart](https://dart.dev/).\n\n- Simple and lightweight\n- Use in dart package and Flutter applications\n\n[GitHub](https://github.com/moneytrackio/tezart/)\n[Getting Started](#Tezart)", "explanation": "Here is a concise summary:\n\n**Purpose:** Tezart library for interacting with Tezos blockchain.\n\n**Functionality:** A lightweight, simple way to use in Dart packages and Flutter applications.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/_coverpage.md", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'docs/_coverpage.md' based on your provided code block summaries:\n\n**Tezart: Simple Tezos Blockchain Integration**\n\nA lightweight library for interacting with the Tezos blockchain, designed for seamless integration in Dart packages and Flutter applications."}
{"code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>tezart - Dart library to connect to Tezos clients. Send transactions and interact with smart contracts.</title>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"description\" content=\"Description\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0\">\n  <link rel=\"stylesheet\" href=\"//cdn.jsdelivr.net/npm/docsify@4/lib/themes/vue.css\">\n</head>\n<body>\n  <div id=\"app\"></div>\n  <script>\n    window.$docsify = {\n      coverpage: true,\n      name: 'tezart',\n      repo: 'https://github.com/moneytrackio/tezart',\n      loadSidebar: true,\n      logo: 'img/logo.png',\n      markdown: {\n          // https://marked.js.org/#/USING_PRO.md#renderer\n          renderer: {\n              image: function(href, title) {\n                  return `<img src=\"${href}\" data-origin=\"${href}\" alt=\"${title}\">`\n              }\n          }\n      }\n    }\n  </script>\n  <!-- Docsify v4 -->", "explanation": "**Summary:** This block is an HTML template with a script that initializes a documentation system called Docsify, likely used for documenting the Tezart library, which interacts with Tezos clients and smart contracts.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/index.html", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'docs/index.html':\n\n**Summary:** HTML template initializing Docsify documentation system for Tezart library, loading JavaScript libraries and adding custom CSS styling for responsive design."}
{"code": "  <script src=\"//cdn.jsdelivr.net/npm/docsify@4\"></script>\n  <script src=\"https://cdn.jsdelivr.net/npm/docsify-tabs@1\"></script>\n\n  <!-- Prism -->\n  <script src=\"//cdn.jsdelivr.net/npm/prismjs@1/components/prism-sh.min.js\"></script>\n  <script src=\"//cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js\"></script>\n  <script src=\"//cdn.jsdelivr.net/npm/prismjs@1/components/prism-dart.min.js\"></script> \n  <script src=\"//cdn.jsdelivr.net/npm/prismjs@1/components/prism-docker.min.js\"></script> \n  <style>\n    /* sidebar logo */\n    .app-name-link > img:nth-child(1){\n      width: 100px;\n    }\n  </style>\n</body>\n</html>\n", "explanation": "This block is a snippet of HTML code that loads JavaScript libraries for:\n\n* Docsify (a documentation builder)\n* Docsify-tabs (an extension for tabs in Docsify)\n* Prism (a syntax highlighting library)\n\nIt also adds a custom CSS style rule to resize an image logo on the sidebar.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/index.html", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'docs/index.html':\n\n**Summary:** HTML template initializing Docsify documentation system for Tezart library, loading JavaScript libraries and adding custom CSS styling for responsive design."}
{"code": "## API Overview and Examples\n\nIn the following examples we suppose that :\n\n- the package `tezart` is imported correctly\n- `client` is a `TezartClient` object defined with a running tezos node url\n- `rpcInterface` is the `RpcInterface` of `client`\n- `source` is a `Keystore` object defined using a revealed wallet and that has enough tez\n\n```dart\nimport 'package:tezart/tezart.dart';\n\nfinal source = Keystore.fromSeed('edsk3RR5U7JsUJ8ctjsuymUPayxMm4LHXaB7VJSfeyMb8fAvbJUnsa');\nfinal client = TezartClient('http://localhost:20000/');\nfinal rpcInterface = client.rpcInterface;\n```\n\n### Enable logging\n\nif you want this library to perform logging into the sandard output, you ay to enable it :\n```dart\nenableTezartLogger();\n```\n\nand/or if you want tezart to log into the [developer tools log](https://api.flutter.dev/flutter/dart-developer/dart-developer-library.html)\n```dart\nenableTezartDevLogs();\n```\n\n\n\n### Tezos Chain Operations\n\n#### Operation\n\n`Operation` is the class that represents Tezos's single operation.\n", "explanation": "**Summary:**\n\nThis block provides an API overview and examples for interacting with a Tezos blockchain using the `tezart` package in Dart.\n\n**Functionality:**\n\n* Importing necessary packages and setting up a Tezos client\n* Enabling logging for debugging purposes\n* Performing Tezos chain operations, including creating and executing single operations", "metadata": {"repo": "magiclabs/tezart", "file": "docs/parts/_api_overview_and_examples.md", "chunk_number": 1, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\nThis file provides an API overview and examples for working with Tezos blockchain using the `tezart` package in Dart. It covers injecting, monitoring, and executing operations on the blockchain, as well as generating OperationsLists for origination, transferring funds, revealing keys, and calling contract functions. The file also includes a Tezos smart contract code snippet that performs arithmetic operations based on input conditions."}
{"code": "We implemented 3 types of operations:\n\n- [`TransactionOperation`](https://pub.dev/documentation/tezart/latest/tezart/TransactionOperation-class.html): is the operation defined by the kind `transaction`. It is used to make transfers and smart contracts calls\n- [`OriginationOperation`](https://pub.dev/documentation/tezart/latest/tezart/OriginationOperation-class.html): is the operation defined by the kind `origination`. It is used to originate smart contracts\n- [`RevealOperation`](https://pub.dev/documentation/tezart/latest/tezart/RevealOperation-class.html): is the operation defined by the kind `reveal`. It is the first operation that need to be sent from a new address. This will reveal the public key associated to an address so that everyone can verify the signature for the operation and any future operations.\n\nIn order to inject an operation, you have to include it in an [OperationsList](#operationslist) object\n\n#### OperationsList\n", "explanation": "This block defines three types of Tezos operations:\n\n1. `TransactionOperation`: makes transfers and contract calls.\n2. `OriginationOperation`: originates smart contracts.\n3. `RevealOperation`: reveals a new public key.\n\nThese operations must be injected into an `OperationsList` object to be executed.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/parts/_api_overview_and_examples.md", "chunk_number": 2, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\nThis file provides an API overview and examples for working with Tezos blockchain using the `tezart` package in Dart. It covers injecting, monitoring, and executing operations on the blockchain, as well as generating OperationsLists for origination, transferring funds, revealing keys, and calling contract functions. The file also includes a Tezos smart contract code snippet that performs arithmetic operations based on input conditions."}
{"code": "`OperationsList` is the central class that allows you to execute, simulate, estimate and monitor a group of operations.\n\n> The source of the operations is always stored in `OperationsList`, because the operations of the same group must have the same source in Tezos.\n\n##### Add Operation objects\n\nYou can append and prepend an `Operation` using `appendOperation` and `prependOperation` methods\n\n```dart\nfinal operationsList = OperationsList(rpcInterface: rpcInterface, source: source);\nfinal destination = Keystore.random();\nfinal transactionOperation = TransactionOperation(amount: 100, destination: destination.address);\n\noperationsList.appendOperation(transactionOperation);\n```\n\n##### Simulate\n\nIn order to simulate the execution of an `OperationsList` object you have to estimate its fees before:\n\n```dart\nawait operationsList.estimate(); // computes the counters, storage limits, gas limits and fees\nawait operationsList.simulate(); // will throw an error if anything wrong happens\n```\n\n##### Execute\n", "explanation": "**Summary:**\n\nThe `OperationsList` class is a central component that manages a group of operations in Tezos, enabling execution, simulation, estimation, and monitoring.\n\n**Key Functionality:**\n\n1. Adds operation objects using `appendOperation` and `prependOperation` methods.\n2. Simulates the execution of an `OperationsList` object after estimating fees.\n3. Executes the operations within the list.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/parts/_api_overview_and_examples.md", "chunk_number": 3, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\nThis file provides an API overview and examples for working with Tezos blockchain using the `tezart` package in Dart. It covers injecting, monitoring, and executing operations on the blockchain, as well as generating OperationsLists for origination, transferring funds, revealing keys, and calling contract functions. The file also includes a Tezos smart contract code snippet that performs arithmetic operations based on input conditions."}
{"code": "You can inject an `OperationsList` using the `execute` method. It will estimate, simulate and inject the operation group in the chain.\n\n```dart\nawait operationsList.execute();\n```\n\n##### Monitor\n\nYou can monitor an injected `OperationsList` using the `monitor` method. It will wait for the operation to be included in a block\n\n```dart\nawait operationsList.execute();\nawait operationsList.monitor(); // <=> await operationsList.executeAndMonitor()\n```\n\n#### TezartClient\n\n`TezartClient` implements some helper methods that construct the `OperationsList` object for you:\n\n- `transferOperation` : returns an `OperationsList` containing a `TransactionOperation` and a `RevealOperation` if the source is not revealed (this behaviour can be disabled by setting `reveal` named parameter to `false`)\n- `revealKeyOperation` : returns an `OperationsList` containing a `RevealOperation`", "explanation": "Here is a concise summary of the purpose and functionality:\n\n**Purpose:** Inject, monitor, and execute operations in a blockchain chain.\n\n**Functionality:**\n\n* Use `execute()` method to inject and estimate an operation group.\n* Use `monitor()` method to wait for the operation to be included in a block (can also be used with `execute()`).\n* `TezartClient` provides helper methods to construct `OperationsList` objects, including:\n\t+ `transferOperation`: creates an operations list for transferring funds.\n\t+ `revealKeyOperation`: creates an operations list for revealing a key.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/parts/_api_overview_and_examples.md", "chunk_number": 4, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\nThis file provides an API overview and examples for working with Tezos blockchain using the `tezart` package in Dart. It covers injecting, monitoring, and executing operations on the blockchain, as well as generating OperationsLists for origination, transferring funds, revealing keys, and calling contract functions. The file also includes a Tezos smart contract code snippet that performs arithmetic operations based on input conditions."}
{"code": "- `originateContractOperation` : returns an `OperationsList` containing an `OriginationOperation` (including the auto reveal behaviour described in `transferOperation`)\n\n```dart\nfinal destination = Keystore.random();\n\nfinal operationsList = await client.transferOperation({\n    source: source,\n    destination: desination,\n    amount: 10,\n    reveal: true,\n});\n```\n\n#### Contract\n\n##### Origination\n\nIn order to generate an `OperationsList` that makes a contract origination, you have to:\n\n- originate the contract `OperationsList` using `originateContractOperation`'s `TezartClient` method\n- `executeAndMonitor` the `OperationsList` object\n- retrieve the originated contract's address using the `OriginationOperation`'s `contractAddress` method\n\n```dart", "explanation": "Here is a concise summary:\n\n**Purpose:** Generate an OperationsList for origination of a contract.\n\n**Functionality:** Use originateContractOperation to create an OperationsList, execute it with executeAndMonitor, then retrieve the contract's address using contractAddress method.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/parts/_api_overview_and_examples.md", "chunk_number": 5, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\nThis file provides an API overview and examples for working with Tezos blockchain using the `tezart` package in Dart. It covers injecting, monitoring, and executing operations on the blockchain, as well as generating OperationsLists for origination, transferring funds, revealing keys, and calling contract functions. The file also includes a Tezos smart contract code snippet that performs arithmetic operations based on input conditions."}
{"code": "final code = [ { 'prim': 'storage', 'args': [ {'prim': 'nat'} ] }, { 'prim': 'parameter', 'args': [ { 'prim': 'or', 'args': [ { 'prim': 'nat', 'annots': ['%divide'] }, { 'prim': 'or', 'args': [ { 'prim': 'unit', 'annots': ['%double'] }, { 'prim': 'nat', 'annots': ['%replace'] } ] } ] } ] }, { 'prim': 'code', 'args': [ [ {'prim': 'UNPAIR'}, { 'prim': 'IF_LEFT', 'args': [ [ {'prim': 'DUP'}, { 'prim': 'PUSH', 'args': [ {'prim': 'nat'}, {'int': '5'} ] }, {'prim': 'COMPARE'}, {'prim': 'LT'}, { 'prim': 'IF', 'args': [ [], [ { 'prim': 'PUSH', 'args': [ {'prim': 'string'}, {'string': 'WrongCondition: params.divisor > 5'} ] }, {'prim': 'FAILWITH'} ] ] }, {'prim': 'SWAP'}, {'prim': 'EDIV'}, { 'prim': 'IF_NONE', 'args': [ [ { 'prim': 'PUSH', 'args': [ {'prim': 'int'}, {'int': '20'} ] }, {'prim': 'FAILWITH'} ], [ {'prim': 'CAR'} ] ] } ], [ { 'prim': 'IF_LEFT', 'args': [ [ {'prim': 'DROP'}, { 'prim': 'PUSH', 'args': [ {'prim': 'nat'}, {'int': '2'} ] }, {'prim': 'MUL'} ], [ {'prim': 'SWAP'}, {'prim': 'DROP'} ] ] } ] ] }, { 'prim': 'NIL', 'args': [ {'prim': 'operation'} ] }, {'prim': 'PAIR'} ] ] } ];", "explanation": "This block is a Tezos smart contract code snippet, which defines a function that:\n\n* Takes two parameters: `divisor` (a natural number) and `parameter` (an optional or parameter)\n* Checks if the divisor is greater than 5\n* If true, returns an error message with \"WrongCondition\"\n* Otherwise, performs arithmetic operations on the parameters (edivision or multiplication)\n* Returns the result as a pair.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/parts/_api_overview_and_examples.md", "chunk_number": 6, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\nThis file provides an API overview and examples for working with Tezos blockchain using the `tezart` package in Dart. It covers injecting, monitoring, and executing operations on the blockchain, as well as generating OperationsLists for origination, transferring funds, revealing keys, and calling contract functions. The file also includes a Tezos smart contract code snippet that performs arithmetic operations based on input conditions."}
{"code": "final storage = {'int' : '12'};\n\nfinal originationOperationsList = await client.originateContractOperation(\n    source: source,\n    code: code,\n    storage: storage,\n    balance: 10,\n);\nawait originationOperationsList.executeAndMonitor();\nfinal originationOperation = originationOperationsList.operations.firstWhere((operation) => operation is OriginationOperation);\nfinal contractAddress = originationOperation.contractAddress;\n```\n\n##### Call\n\nIn order to make a contract call to an entrypoint, you have to:\n\n- construct a `Contract` object using the contract address\n- use `callOperation`'s `Contract` method to generate the `OperationsList` object\n- `executeAndMonitor` the `OperationsList` object\n\n```dart\nfinal contract = Contract(contractAddress: contractAddress, rpcInterface: rpcInterface);\nfinal callContractOperationsList = await contract.callOperation(\n    entrypoint: 'divide',\n    params: 42,\n    source: source,\n);\nawait callContractOperationsList.executeAndMonitor();\n```\n\n##### Storage\n", "explanation": "**Purpose:** Initialize a Tezos contract by providing storage and execute its origination operation.\n\n**Functionality:**\n\n1. Store initial data in a dictionary (`storage`).\n2. Originate the contract with the provided code, source, balance, and storage.\n3. Execute and monitor the origination operation.\n\n**Contract Call:**\n\n1. Construct a `Contract` object using the contract's address.\n2. Call the specified entrypoint (function) on the contract with given parameters.\n3. Execute and monitor the call operation.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/parts/_api_overview_and_examples.md", "chunk_number": 7, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\nThis file provides an API overview and examples for working with Tezos blockchain using the `tezart` package in Dart. It covers injecting, monitoring, and executing operations on the blockchain, as well as generating OperationsLists for origination, transferring funds, revealing keys, and calling contract functions. The file also includes a Tezos smart contract code snippet that performs arithmetic operations based on input conditions."}
{"code": "You can fetch the storage of a contract using `storage` getter of `Contract` class. The storage is converted from Micheline to Dart basic objects.\n\n```dart\nfinal contract = Contract(contractAddress: contractAddress, rpcInterface: rpcInteface);\nawait contract.storage;\n```\n\n##### Introspection\n\nYou can fetch the list of the entrypoints of a contract using `entrypoints` getter.\n\n```dart\nfinal contract = Contract(contractAddress: contractAddress, rpcInterface: rpcInterface);\nawait contract.entrypoints;\n```\n\nIf you want the types in Micheline of these entrypoints you can use `getContractEntrypoints`'s `RpcInterface`. This will return a `Map` that maps the entrypoints names to its types in Micheline.\n\n```dart\nawait rpcInterface.getContractEntrypoints(contractAddress);\n```", "explanation": "**Purpose:** Provide functionality for interacting with smart contract data on a blockchain network.\n**Functionality:** Fetch contract storage, entrypoints, and their Micheline types using the `Contract` class and RPC interface methods.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/parts/_api_overview_and_examples.md", "chunk_number": 8, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\nThis file provides an API overview and examples for working with Tezos blockchain using the `tezart` package in Dart. It covers injecting, monitoring, and executing operations on the blockchain, as well as generating OperationsLists for origination, transferring funds, revealing keys, and calling contract functions. The file also includes a Tezos smart contract code snippet that performs arithmetic operations based on input conditions."}
{"code": "## API Reference\n\nThe methods and classes of this library are documented in the [API Reference](https://pub.dev/documentation/tezart/latest/)", "explanation": "This block provides a link to the official API documentation for the \"TezArt\" library, allowing users to access detailed information on its methods and classes.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/parts/_api_reference.md", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'docs/parts/_api_reference.md':\n\n**API Reference**\n\nAccess official TezArt library documentation for methods and classes."}
{"code": "## Contribute\nThere are many ways to contribute to this project.\nYou can : \n- add some example into the `example folder`,\n- contribute to the source code, \n- submit bug reports or feature requests,\n- ask questions about it on [r/Tezos](http://reddit.com/r/tezos/) or the [Tezos StackExchange](https://tezos.stackexchange.com/). \n\n[Pull Requests are welcome as well !](#feature-requests-and-bugs)\n\n### Project versionning\n\nThe versioning scheme we use is [SemVer](http://semver.org/). Version numbers\nfollows the MAJOR.MINOR.PATCH pattern:\n\n- **MAJOR** version for incompatible API changes,\n- **MINOR** version for backwards compatible features, and\n- **PATCH** version for make backwards compatible bug fixes.\n\nRead [dart package versioning](https://dart.dev/tools/pub/versioning) to learn more.\n\n### Branching model\n\nThis repository use a simple branch model, because we will not maintain more\nthan 1 major version of the library in parallel.\n\n- `main` branch is the stable branch, containing the latest released version of", "explanation": "**Summary:**\n\nThis block provides information on how to contribute to a project, including adding examples, submitting bug reports or feature requests, and asking questions online. It also explains the project's versioning scheme (SemVer) and branching model.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/parts/_contribute.md", "chunk_number": 1, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'docs/parts/_contribute.md':\n\n**Contribution Guide**\n\nThis guide outlines the steps for contributing to a project, including setting up a development environment, following branching rules, and utilizing utility functions for development assistance. It also provides instructions on verifying code changes, updating documentation, and merging pull requests."}
{"code": "  the library;\n- `develop` branch is the development branch, from which all new features branch\n  must be created, and pull requests targeted.\n\nAll the releases are created from tags, themselves created from `main` branch.\n\nContributors must use the following rules when creating branches:\n\n- `release/<feature-name>` for major changes;\n- `feat/<feature-name>` for backwards compatible changes;\n- `fix/<fix-name>` for backwards compatible bug fixes.\n\n### Setup your development environment\n\n> *The following setup only works for Mac and Linux*\n\nTo ensure that you can contribute to this project, you will need to setup your environment :\n\n#### A. Install prerequisites\nYou can follow the instructions in the prerequisites [section](#prerequisites)\n\n#### B. Setup Lefthook\n\nTo install lefthook, just follow [this](https://github.com/Arkweid/lefthook/blob/master/docs/full_guide.md#installation) guide, then run :\n\n```bash\nlefthook install\n```\n\n#### C. Verify your setup \n", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Guide for contributors on how to set up their development environment and follow branching rules.\n\n**Functionality:**\n\n* Describes the project's branching structure (development branch, tags, releases)\n* Specifies naming conventions for branches\n* Provides instructions on setting up a development environment, including installing prerequisites and Lefthook.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/parts/_contribute.md", "chunk_number": 2, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'docs/parts/_contribute.md':\n\n**Contribution Guide**\n\nThis guide outlines the steps for contributing to a project, including setting up a development environment, following branching rules, and utilizing utility functions for development assistance. It also provides instructions on verifying code changes, updating documentation, and merging pull requests."}
{"code": "To ensure that your environment is ready for contribution, please run the following command at the root of the project: \n\n```bash\n./tezart doctor\n```\n\nYou can add an alias like this `alias tezart='./tezart'` to avoid  calling the command line with `./`\n \nFollowing is a sample of a correct setup :\n\n<img src=\"img/a-sample-correct-setup.png?raw=true\"></img>\n\n\n### Edit this documentation\n\nThe following documentation is provided in `tezart/docs/` directory and you call the following command to serve it \nlocally : \n\n```bash\n./tezart docs\n```\n\n<img src=\"img/a-sample-tezart-docs.png?raw=true\"></img>\n\n### Utility functions\n\nWe provide some utility functions through `tezart` to help you in your development process. \n\nFollowing is the output usage : \n\n<img src=\"img/a-current-usage.png?raw=true\"></img>\n\n### Tests policy\n\n- Integration tests for exposed classes: `TezartClient` `RpcInterface` `Keystore` `Signature`.\n- Unit tests for private classes.\n- Ensure code coverage is higher than 85%.\n\n### Pull Request advice\n", "explanation": "**Purpose:** To ensure a project environment is ready for contribution and provide utilities for development.\n\n**Functionality:**\n\n1. Run command `./tezart doctor` at project root to verify setup.\n2. Display documentation locally with `./tezart docs`.\n3. Utilize utility functions through `tezart` for development assistance.\n4. Follow testing policy for code coverage and integration/unit tests.\n\n**Key Features:**\n\n* Setup verification\n* Documentation display\n* Utility functions support\n* Testing guidelines", "metadata": {"repo": "magiclabs/tezart", "file": "docs/parts/_contribute.md", "chunk_number": 3, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'docs/parts/_contribute.md':\n\n**Contribution Guide**\n\nThis guide outlines the steps for contributing to a project, including setting up a development environment, following branching rules, and utilizing utility functions for development assistance. It also provides instructions on verifying code changes, updating documentation, and merging pull requests."}
{"code": "- Ensure to have a correct output for `tezart doctor` in your development environment. \n- Update the `docs/README.md` if necessary with details of changes that you've made. This includes new API,\n   useful command-line option, etc...\n- You may merge the Pull Request in once you have the sign-off of two other developers, or if you \n   do not have permission to do that, you may request the second reviewer to merge it for you.\n", "explanation": "This block outlines a development workflow:\n\n* Verify code changes with `tezart doctor`.\n* Update documentation (`docs/README.md`) with change details.\n* Merge Pull Request after 2nd developer review or request another to merge.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/parts/_contribute.md", "chunk_number": 4, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'docs/parts/_contribute.md':\n\n**Contribution Guide**\n\nThis guide outlines the steps for contributing to a project, including setting up a development environment, following branching rules, and utilizing utility functions for development assistance. It also provides instructions on verifying code changes, updating documentation, and merging pull requests."}
{"code": "### What it is\n\n[Tezart](https://github.com/moneytrackio/tezart) is a [Dart](https://dart.dev/) library for building decentralized applications on [Tezos](https://tezos.com) blockchain.\n\nTezart interacts with a Tezos node to send transactions, interact with smart contracts and much more!\n\nSee the [Quick start](#quick-start) guide for more details.\n\n### Special Thanks\n\n[Tezos Foundation](https://tezos.foundation/) and [MoneyTrack](https://moneytrack.io/) for the effort.\n\n### Example\n\n1. [Install Dart](#install-dart) and [run a Tezos sandbox locally](#run-a-tezos-sandbox-locally-optional)\n2. Clone the project:\n```bash\ngit clone https://github.com/moneytrackio/tezart.git\n```\n3. run pub get:\n```bash\ncd tezart/\npub get\n```\n4. Execute the example:\n```bash\ndart example/example.dart\n```\n\n> tezart/example/example.dart\n\n```dart\n// Copyright (c), Moneytrack.io authors.\n// All rights reserved. Use of this source code is governed by a\n// MIT license that can be found in the LICENSE file.\n\nimport 'package:tezart/tezart.dart';\n", "explanation": "**Summary**\n\nTezart is a Dart library for building decentralized apps on the Tezos blockchain, enabling interactions with smart contracts and transactions.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/parts/_introduction.md", "chunk_number": 1, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**File Summary:**\n\nThe file 'docs/parts/_introduction.md' introduces Tezart, a Dart library for building decentralized apps on the Tezos blockchain. It demonstrates how to generate a Keystore object from a mnemonic phrase and manage it using various functions such as creating, extracting secrets, and printing properties."}
{"code": "// Sample mnemonic\nconst String mnemonic =\n    'brief hello carry loop squeeze unknown click abstract lounge figure logic oblige child ripple about vacant scheme magnet open enroll stuff valve hobby what';\n\n// Sample secret key\nconst String secretKey =\n    'edskRpwW3bAgx7GsbyTrbb5NUP7b1tz34AvfV2Vm4En5LgEzeUmg3Ys815UDYNNFG6JvrrGqA9CNU2h8hsLVVLfuEQPkZNtkap';\n\n// Sample seed\nconst String seed = 'edsk3RR5U7JsUJ8ctjsuymUPayxMm4LHXaB7VJSfeyMb8fAvbJUnsa';\n\n///\n/// This is a simple example of using tezart\n/// In this example, we assume that you are running\n/// a tezos blockchain locally at http://localhost:20000\n///\n/// In the README.md of the project, we provided a command line\n/// to help you launch a local blockchain with docker.\n///\nFuture<void> main() async {\n  /// Generate keystore from mnemonic\n  var keystore = Keystore.fromMnemonic(mnemonic);\n\n  // Sample output of keystore created from mnemonic\n  print(keystore.secretKey);", "explanation": "**Purpose:** Demonstrates how to generate a Tezos keystore using a mnemonic phrase.\n\n**Functionality:**\n\n1. Creates a `Keystore` object from a given mnemonic phrase.\n2. Extracts a secret key from the generated keystore.\n3. Prints the secret key to the console.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/parts/_introduction.md", "chunk_number": 2, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**File Summary:**\n\nThe file 'docs/parts/_introduction.md' introduces Tezart, a Dart library for building decentralized apps on the Tezos blockchain. It demonstrates how to generate a Keystore object from a mnemonic phrase and manage it using various functions such as creating, extracting secrets, and printing properties."}
{"code": "  // => edskRpwW3bAgx7GsbyTrbb5NUP7b1tz34AvfV2Vm4En5LgEzeUmg3Ys815UDYNNFG6JvrrGqA9CNU2h8hsLVVLfuEQPkZNtkap\n  print(keystore.publicKey);\n  // => edpkvGRiJj7mCSZtcTabQkfgKky8AEDGPTCmmWyT1Vg17Lqt3cD5TU\n  print(keystore.address);\n  // => tz1LmRFP1yFg4oTwfThfbrJx2BfZVAK2h7eW\n\n  /// Generate keystore from secret key\n  keystore = Keystore.fromSecretKey(secretKey);\n\n  // Sample output of keystore created from secretkey\n  print(keystore.secretKey);\n  // => edskRpwW3bAgx7GsbyTrbb5NUP7b1tz34AvfV2Vm4En5LgEzeUmg3Ys815UDYNNFG6JvrrGqA9CNU2h8hsLVVLfuEQPkZNtkap\n  print(keystore.publicKey);\n  // => edpkvGRiJj7mCSZtcTabQkfgKky8AEDGPTCmmWyT1Vg17Lqt3cD5TU\n  print(keystore.address);\n  // => tz1LmRFP1yFg4oTwfThfbrJx2BfZVAK2h7eW\n\n  /// Generate keystore from seed\n  keystore = Keystore.fromSeed(seed);\n\n  // Sample output of keystore created from seed\n  print(keystore.secretKey);\n  // => edskRpwW3bAgx7GsbyTrbb5NUP7b1tz34AvfV2Vm4En5LgEzeUmg3Ys815UDYNNFG6JvrrGqA9CNU2h8hsLVVLfuEQPkZNtkap\n  print(keystore.publicKey);", "explanation": "Here is a concise summary of the purpose and functionality:\n\n**Purpose:** Generate and manage a Keystore object.\n\n**Functionality:**\n\n* Create a Keystore from a secret key or seed.\n* Print the Keystore's properties:\n\t+ Secret Key (edsk... format)\n\t+ Public Key (edpk... format)\n\t+ Address (tz1... format)\n\nNote: This appears to be code in a programming language, likely Dart, and is using libraries specific to Tezos, a cryptocurrency.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/parts/_introduction.md", "chunk_number": 3, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**File Summary:**\n\nThe file 'docs/parts/_introduction.md' introduces Tezart, a Dart library for building decentralized apps on the Tezos blockchain. It demonstrates how to generate a Keystore object from a mnemonic phrase and manage it using various functions such as creating, extracting secrets, and printing properties."}
{"code": "  // => edpkvGRiJj7mCSZtcTabQkfgKky8AEDGPTCmmWyT1Vg17Lqt3cD5TU\n  print(keystore.address);\n  // => tz1LmRFP1yFg4oTwfThfbrJx2BfZVAK2h7eW\n\n  ///\n  /// Transfer\n  /// In this example, we are using a wallet that has enough tez to make the transfer\n  /// We make the transfer and monitor the operation\n  /// All amounts are in \u00b5tz\n  ///\n  final sourceKeystore = Keystore.fromSecretKey(\n      'edskRpm2mUhvoUjHjXgMoDRxMKhtKfww1ixmWiHCWhHuMEEbGzdnz8Ks4vgarKDtxok7HmrEo1JzkXkdkvyw7Rtw6BNtSd7MJ7');\n  final destinationKeystore = Keystore.random();\n  final client = TezartClient('http://localhost:20000');\n  final amount = 10000;\n  final operationsList = await client.transferOperation(\n    source: sourceKeystore,\n    destination: destinationKeystore.address,\n    amount: amount,\n  );\n  await operationsList.executeAndMonitor();\n  print(await client.getBalance(address: destinationKeystore.address));\n  // => 10000\n}\n\n```", "explanation": "Here is a concise summary:\n\n**Block Purpose:** Demonstrate a Tezos (Tezart) transaction using a wallet's secret key.\n\n**Functionality:**\n\n1. Retrieves the address of an existing keystore.\n2. Transfers 10,000 \u00b5tz from one wallet to another.\n3. Monitors and executes the transfer operation.\n4. Prints the updated balance of the destination wallet.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/parts/_introduction.md", "chunk_number": 4, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**File Summary:**\n\nThe file 'docs/parts/_introduction.md' introduces Tezart, a Dart library for building decentralized apps on the Tezos blockchain. It demonstrates how to generate a Keystore object from a mnemonic phrase and manage it using various functions such as creating, extracting secrets, and printing properties."}
{"code": "## Quick start\n\n### Prerequisites\n\n#### Install dart\n\nYou can install **Dart SDK**, by following the [official dart documentation](https://dart.dev/get-dart).\n\n> *The minimal required version to use this package is 2.12*\n\n#### Run a Tezos sandbox locally *(optional)*\n\n> *You can skip this part if you want to use a public Tezos node.*\n\n1- If you don't have **Docker**, please install it by following the [official docker documentation](https://docs.docker.com/get-docker/)\n\n2- You can use [flextesa's sandbox](https://assets.tqtezos.com/docs/setup/2-sandbox/) by running the following command : \n\n> *Flextesa's sandbox is an ephemeral and isolated sandbox. It can be useful to experiment with faster networks or to automate reproducible tests.*\n\n```bash\ndocker run --rm \\\n    --name my-sandbox \\\n    --detach -p 20000:20000 \\\n    tqtezos/flextesa:20210316 edobox start\n```\n\n### Use this package in a small dart app\n\n1. Use `dart create` to create a command-line app:\n\n```dart\ndart create -t console-full tezart_example\n```\n", "explanation": "Here is a summary of the purpose and functionality of this block:\n\n**Purpose:** Guide users on how to set up Dart SDK, install a Tezos sandbox (optional), and use a package in a small Dart app.\n\n**Functionality:**\n\n* Provides instructions for installing the Dart SDK\n* Offers an optional step to run a local Tezos sandbox using Docker\n* Demonstrates how to create a simple Dart command-line app using `dart create`", "metadata": {"repo": "magiclabs/tezart", "file": "docs/parts/_quickstart.md", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'docs/parts/_quickstart.md':\n\n**Quickstart Guide**\n\nThis block guides users through setting up a Dart development environment, installing a Tezos sandbox (optional), creating a simple app, and running an example transaction client using the TezArt library."}
{"code": "2. Add tezart to your dependencies:\n\n```yaml\ndependencies:\n  tezart: ^2.0.4\n```\n\n```bash\ncd tezart_example\npub get\n```\n\n3. Change `lib/tezart_example.dart` to :\n\n```dart\nimport 'package:tezart/tezart.dart';\n\nFuture<void> main() async {\n  const String secretKey = 'edskRpm2mUhvoUjHjXgMoDRxMKhtKfww1ixmWiHCWhHuMEEbGzdnz8Ks4vgarKDtxok7HmrEo1JzkXkdkvyw7Rtw6BNtSd7MJ7';\n  final sourceKeystore = Keystore.fromSecretKey(secretKey);\n  final destination = Keystore.random().address;\n  final client = TezartClient('http://localhost:20000/');\n  final amount = 10000;\n\n  print('Starting transfer of $amount \u00b5tz from ${sourceKeystore.address} to ${destination} ...');\n  final operationsList = await client.transferOperation(\n    source: sourceKeystore,\n    destination: destination,\n    amount: amount,\n  );\n  await operationsList.execute();\n  print('Transfer completed.');\n\n  print('Monitoring the operation ...');\n  await operationsList.monitor();\n  print('Monitoring completed.');\n}\n```\n\n4. Change `bin/tezart_example.dart` to :\n\n```dart", "explanation": "Here is a concise summary:\n\n**Purpose:** This block sets up a Tezos transaction client using the TezArt library.\n\n**Functionality:** It adds the TezArt dependency, configures a simple transaction client, and provides an example code snippet for transferring 10,000 microtez from one address to another.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/parts/_quickstart.md", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'docs/parts/_quickstart.md':\n\n**Quickstart Guide**\n\nThis block guides users through setting up a Dart development environment, installing a Tezos sandbox (optional), creating a simple app, and running an example transaction client using the TezArt library."}
{"code": "import 'package:tezart_example/tezart_example.dart' as tezart_example;\n\nvoid main(List<String> arguments) async {\n  await tezart_example.main();\n}\n```\n\n5. Run the app :\n\n```bash\ndart run\n```\n\n> Output\n\n<img src=\"img/quick-start-example-output.gif?raw=true\"></img>\n", "explanation": "**Purpose:** This block is a Dart script that runs an example application.\n\n**Functionality:**\n\n1. It imports an external module (`tezart_example.dart`) and assigns it the alias `tezart_example`.\n2. The `main` function is defined, which waits for the imported module to complete its execution using `await tezart_example.main();`.\n3. The script exits after running the imported module's `main` function.\n\n**Action:** To run this script, execute `dart run` in a terminal.", "metadata": {"repo": "magiclabs/tezart", "file": "docs/parts/_quickstart.md", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'docs/parts/_quickstart.md':\n\n**Quickstart Guide**\n\nThis block guides users through setting up a Dart development environment, installing a Tezos sandbox (optional), creating a simple app, and running an example transaction client using the TezArt library."}
{"code": "// Copyright (c), Moneytrack.io authors.\n// All rights reserved. Use of this source code is governed by a\n// MIT license that can be found in the LICENSE file.\n\nimport 'package:tezart/tezart.dart';\n\n// Sample mnemonic\nconst String mnemonic =\n    'brief hello carry loop squeeze unknown click abstract lounge figure logic oblige child ripple about vacant scheme magnet open enroll stuff valve hobby what';\n\n// Sample secret key\nconst String secretKey =\n    'edskRpwW3bAgx7GsbyTrbb5NUP7b1tz34AvfV2Vm4En5LgEzeUmg3Ys815UDYNNFG6JvrrGqA9CNU2h8hsLVVLfuEQPkZNtkap';\n\n// Sample seed\nconst String seed = 'edsk3RR5U7JsUJ8ctjsuymUPayxMm4LHXaB7VJSfeyMb8fAvbJUnsa';\n\n///\n/// This is a simple example of using tezart\n/// In this example, we assume that you are running\n/// a tezos blockchain locally at http://localhost:2000\n///\n/// In the README.md of the project, we provided a command line\n/// to help you launch a local blockchain with docker.\n///\nFuture<void> main() async {\n  /// Generate keystore from mnemonic", "explanation": "Here is a concise summary:\n\n**Purpose:** This code demonstrates how to use the Tezart package for interacting with a Tezos blockchain.\n\n**Functionality:** It generates a key store from a mnemonic phrase, secret key, and seed, assuming a local Tezos blockchain at http://localhost:2000.", "metadata": {"repo": "magiclabs/tezart", "file": "example/example.dart", "chunk_number": 1, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'example/example.dart':\n\n**Summary**: A sample code that demonstrates how to interact with the Tezos blockchain using the Tezart package. It showcases generating a key store from various inputs, as well as transferring Tezos tokens using the TezartClient library, including wallet creation, operation execution, and balance retrieval."}
{"code": "  var keystore = Keystore.fromMnemonic(mnemonic);\n\n  // Sample output of keystore created from mnemonic\n  print(keystore.secretKey);\n  // => edskRpwW3bAgx7GsbyTrbb5NUP7b1tz34AvfV2Vm4En5LgEzeUmg3Ys815UDYNNFG6JvrrGqA9CNU2h8hsLVVLfuEQPkZNtkap\n  print(keystore.publicKey);\n  // => edpkvGRiJj7mCSZtcTabQkfgKky8AEDGPTCmmWyT1Vg17Lqt3cD5TU\n  print(keystore.address);\n  // => tz1LmRFP1yFg4oTwfThfbrJx2BfZVAK2h7eW\n\n  /// Generate keystore from secret key\n  keystore = Keystore.fromSecretKey(secretKey);\n\n  // Sample output of keystore created from secretkey\n  print(keystore.secretKey);\n  // => edskRpwW3bAgx7GsbyTrbb5NUP7b1tz34AvfV2Vm4En5LgEzeUmg3Ys815UDYNNFG6JvrrGqA9CNU2h8hsLVVLfuEQPkZNtkap\n  print(keystore.publicKey);\n  // => edpkvGRiJj7mCSZtcTabQkfgKky8AEDGPTCmmWyT1Vg17Lqt3cD5TU\n  print(keystore.address);\n  // => tz1LmRFP1yFg4oTwfThfbrJx2BfZVAK2h7eW\n\n  /// Generate keystore from seed\n  keystore = Keystore.fromSeed(seed);\n\n  // Sample output of keystore created from seed\n  print(keystore.secretKey);", "explanation": "**Summary**\n\nThis block creates a Keystore object, which holds private keys and addresses for cryptocurrency transactions. The Keystore can be generated from:\n\n* A mnemonic phrase (a string)\n* A secret key (a hexadecimal string)\n* A seed value (unknown format)\n\nThe resulting Keystore contains the following properties:\n\n* `secretKey`: a private key\n* `publicKey`: a public address\n* `address`: a cryptocurrency address", "metadata": {"repo": "magiclabs/tezart", "file": "example/example.dart", "chunk_number": 2, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'example/example.dart':\n\n**Summary**: A sample code that demonstrates how to interact with the Tezos blockchain using the Tezart package. It showcases generating a key store from various inputs, as well as transferring Tezos tokens using the TezartClient library, including wallet creation, operation execution, and balance retrieval."}
{"code": "  // => edskRpwW3bAgx7GsbyTrbb5NUP7b1tz34AvfV2Vm4En5LgEzeUmg3Ys815UDYNNFG6JvrrGqA9CNU2h8hsLVVLfuEQPkZNtkap\n  print(keystore.publicKey);\n  // => edpkvGRiJj7mCSZtcTabQkfgKky8AEDGPTCmmWyT1Vg17Lqt3cD5TU\n  print(keystore.address);\n  // => tz1LmRFP1yFg4oTwfThfbrJx2BfZVAK2h7eW\n\n  ///\n  /// Transfer\n  /// In this example, we are using a wallet that has enough tez to make the transfer\n  /// We make the transfer and monitor the operation\n  /// All amounts are in \u00b5tz\n  ///\n  final sourceKeystore = Keystore.fromSecretKey(\n      'edskRpm2mUhvoUjHjXgMoDRxMKhtKfww1ixmWiHCWhHuMEEbGzdnz8Ks4vgarKDtxok7HmrEo1JzkXkdkvyw7Rtw6BNtSd7MJ7');\n  final destinationKeystore = Keystore.random();\n  final client = TezartClient('http://localhost:20000');\n  final amount = 10000;\n  final operationsList = await client.transferOperation(\n    source: sourceKeystore,\n    destination: destinationKeystore.address,\n    amount: amount,\n  );\n  await operationsList.executeAndMonitor();", "explanation": "Here is a concise summary:\n\nThis block of code demonstrates how to transfer Tezos (Tez) tokens using the TezartClient library. It creates two wallets, generates a transfer operation, and executes it while monitoring its progress.", "metadata": {"repo": "magiclabs/tezart", "file": "example/example.dart", "chunk_number": 3, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'example/example.dart':\n\n**Summary**: A sample code that demonstrates how to interact with the Tezos blockchain using the Tezart package. It showcases generating a key store from various inputs, as well as transferring Tezos tokens using the TezartClient library, including wallet creation, operation execution, and balance retrieval."}
{"code": "  print(await client.getBalance(address: destinationKeystore.address));\n  // => 10000\n}\n", "explanation": "This block retrieves and prints the balance associated with a specific address using a client object, with the expected output being \"10000\".", "metadata": {"repo": "magiclabs/tezart", "file": "example/example.dart", "chunk_number": 4, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'example/example.dart':\n\n**Summary**: A sample code that demonstrates how to interact with the Tezos blockchain using the Tezart package. It showcases generating a key store from various inputs, as well as transferring Tezos tokens using the TezartClient library, including wallet creation, operation execution, and balance retrieval."}
{"code": "// Copyright (c), Moneytrack.io authors.\n// All rights reserved. Use of this source code is governed by a\n// MIT license that can be found in the LICENSE file.\n\nimport 'package:tezart/tezart.dart';\n\n///\n/// This is a simple example of using tezart\n/// In this example, we assume that you are running\n/// a tezos blockchain locally at http://localhost:20000\n///\n/// In the README.md of the project, we provided a command line\n/// to help you launch a local blockchain with docker.\n///\nFuture<void> main() async {\n  ///\n  /// Enable the log (Optional)\n  ///\n  enableTezartLogger();\n\n  ///\n  /// Transfer\n  /// In this example, we are using a wallet that has enough tez to make the transfer\n  /// We make the transfer and monitor the operation\n  /// All amounts are in \u00b5tz\n  ///\n  final sourceKeystore = Keystore.fromSecretKey(\n      'edskRpm2mUhvoUjHjXgMoDRxMKhtKfww1ixmWiHCWhHuMEEbGzdnz8Ks4vgarKDtxok7HmrEo1JzkXkdkvyw7Rtw6BNtSd7MJ7');\n  final destinationKeystore = Keystore.random();", "explanation": "Here is a concise summary:\n\n**Purpose:** A simple example of using tezart, a Tezos blockchain library.\n\n**Functionality:**\n\n* Enables logging (optional)\n* Transfers tokens between two wallets:\n\t+ Source wallet uses a pre-defined secret key.\n\t+ Destination wallet is generated randomly.", "metadata": {"repo": "magiclabs/tezart", "file": "example/example_with_log.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**Purpose:** Tezart example demonstrating a token transfer between two accounts.\n\n**Functionality:** Initiates, executes, and monitors a transfer operation between source and destination Tezos accounts, printing the updated balance."}
{"code": "  final client = TezartClient('http://localhost:20000');\n  final amount = 10000;\n  final operationsList = await client.transferOperation(\n    source: sourceKeystore,\n    destination: destinationKeystore.address,\n    amount: amount,\n  );\n  await operationsList.executeAndMonitor();\n  print(await client.getBalance(address: destinationKeystore.address));\n  // => 10000\n}\n", "explanation": "**Purpose:** Execute a transfer operation between two Tezos accounts.\n\n**Functionality:** \n\n1. Create a `TezartClient` instance.\n2. Initiate a transfer from one account (`sourceKeystore`) to another (`destinationKeystore.address`).\n3. Execute and monitor the transaction.\n4. Print the updated balance of the destination account.", "metadata": {"repo": "magiclabs/tezart", "file": "example/example_with_log.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**Purpose:** Tezart example demonstrating a token transfer between two accounts.\n\n**Functionality:** Initiates, executes, and monitors a transfer operation between source and destination Tezos accounts, printing the updated balance."}
{"code": "# EXAMPLE USAGE\n# Refer for explanation to following link:\n# https://github.com/Arkweid/lefthook/blob/master/docs/full_guide.md\n#\n\npre-commit:\n  parallel: true\n  commands:\n    dartanalyzer:\n      files: &staged_files git status --short | grep '^\\w.' | xargs ls -1 2>/dev/null | grep .dart$ | grep -v .mocks.dart$\n      run: dart analyze --fatal-infos --fatal-warnings {files}\n\n    dartfmt:\n      files: *staged_files\n      run:  dart format --set-exit-if-changed -l \"120\" {files}\n", "explanation": "This block defines a configuration for pre-commit hooks in a Git repository, specifically for Dart projects. It runs two commands:\n\n1. `dartanalyzer`: Analyzes staged Dart files with fatal errors.\n2. `dartfmt`: Formats staged Dart files with a 120-line limit. \n\nBoth commands are run in parallel (if supported).", "metadata": {"repo": "magiclabs/tezart", "file": "lefthook.yml", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lefthook.yml':\n\n**lefthook.yml**: Configures pre-commit hooks for Dart projects, running `dartanalyzer` and `dartfmt` in parallel to enforce coding standards and formatting conventions."}
{"code": "/// Exception thrown when an error occurs during crypto operation.\nabstract class CommonException implements Exception {\n  String get key;\n  String get message;\n  dynamic get originalException;\n\n  @override\n  String toString() {\n    return '$runtimeType: got code $key with msg `$message.`';\n  }\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Exception class for crypto-related errors.\n**Functionality:** Customizable exception with key, message, and original exception properties, providing detailed error information when thrown.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/common/exceptions/common_exception.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise and to-the-point holistic summary of the file 'lib/src/common/exceptions/common_exception.dart':\n\n**Summary:** A customizable crypto-related exception class that provides detailed error information with key, message, and original exception properties."}
{"code": "import 'package:ansicolor/ansicolor.dart';\nimport 'package:logging/logging.dart';\nimport 'dart:developer';\n\nfinal _green = AnsiPen()..green();\nfinal _cyan = AnsiPen()..cyan();\nfinal _yellow = AnsiPen()..yellow();\nfinal _red = AnsiPen()..red();\n\n///\n/// the AnsiPen color xterm\n/// So the trick here is to switch/case and color while printing\n///\nvoid _printOutput({\n  required DateTime time,\n  required String level,\n  required String name,\n  required String message,\n}) {\n  dynamic levelColored;\n  switch (level) {\n    case 'INFO':\n      levelColored = _green(level);\n      break;\n    case 'WARNING':\n      levelColored = _yellow(level);\n      break;\n    case 'SEVERE':\n      levelColored = _red(level);\n      break;\n    default:\n      levelColored = _cyan(level);\n      break;\n  }\n  print('$time[$levelColored] - $name : $message');\n}\n\n/// Enables the logs to be displayed in the console.\nvoid enableTezartLogger({Level level = Level.ALL}) {\n  Logger.root.level = level;\n  Logger.root.onRecord.listen((record) {\n    _printOutput(", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Colorize log output in console.\n\n**Functionality:** Maps log levels to specific colors (green, yellow, red, cyan), then prints log messages with colored level indicators using ANSI escape codes.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/common/logger/common_logger.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'lib/src/common/logger/common_logger.dart':\n\n**Summary:** \nThis file enables customizable logging with colorized output in the console. It maps log levels to specific colors and prints messages with colored level indicators, allowing for developer logs at various levels."}
{"code": "      time: record.time,\n      name: record.loggerName,\n      level: record.level.name,\n      message: record.message,\n    );\n  });\n}\n\n/// Enables the developer logs.\nvoid enableTezartDevLogs({Level level = Level.ALL}) {\n  Logger.root.level = level;\n  Logger.root.onRecord.listen((record) {\n    log(record.message, level: record.level.value, time: record.time, name: record.loggerName);\n  });\n}\n", "explanation": "**Purpose:** Logs developer logs at various levels.\n\n**Functionality:** Listens for logger records and forwards them to a logging function, enabling customized logging output.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/common/logger/common_logger.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'lib/src/common/logger/common_logger.dart':\n\n**Summary:** \nThis file enables customizable logging with colorized output in the console. It maps log levels to specific colors and prints messages with colored level indicators, allowing for developer logs at various levels."}
{"code": "/// Utils related to enums\nclass EnumUtil {\n  /// Searches [stringType] in [values] and converts it to [T]\n  ///\n  /// if [stringType] doesn't exist a StateError is thrown\n  static T? stringToEnum<T>(Iterable<T> values, String stringType) {\n    return values.firstWhere(\n      (f) => f.toString().substring(f.toString().indexOf('.') + 1).toString() == stringType,\n    );\n  }\n\n  /// Converts [enumValue] to its string representation\n  static String enumToString<T>(T enumValue) => enumValue.toString().split('.').last;\n}\n", "explanation": "**Summary**\n\nThis is a utility class (`EnumUtil`) that provides two methods:\n\n1. `stringToEnum`: Converts a string to an enum value, throwing an error if not found.\n2. `enumToString`: Converts an enum value to its string representation.\n\nBoth methods are generic and work with any type of enum (T).", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/common/utils/enum_util.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**lib/src/common/utils/enum_util.dart**\n\nUtility class providing bidirectional enum conversions: `stringToEnum` and `enumToString`, working with any enum type."}
{"code": "extension ListExtension on List {\n  /// Flattens this\n  List<T> flatten<T>() => fold(\n      [],\n      (List<dynamic> value, dynamic element) => [\n            ...value,\n            ...(element is List ? element.flatten() : [element]),\n          ]).cast<T>();\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** To recursively flatten nested lists into a single, flattened list.\n\n**Functionality:** The `flatten()` method takes a list and recursively unwinds any nested lists, returning a new list with all elements concatenated.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/common/utils/list_extension.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary of the file 'lib/src/common/utils/list_extension.dart':\n\n**Purpose:**\nFlatten nested lists into a single list.\n\n**Functionality:** \nRecursively unwind nested lists, concatenating all elements into a new flat list."}
{"code": "extension MapExtension on Map {\n  /// Fetches [key] in this and throws ArgumentError if [key] is not found\n  T fetch<T>(dynamic key) {\n    if (this[key] == null) throw ArgumentError.value(key);\n\n    return this[key];\n  }\n}\n", "explanation": "**Purpose:** Provides a method for fetching values from a map, throwing an error if the requested key is missing.\n\n**Functionality:** The `fetch` method retrieves a value of type `T` associated with a given dynamic key, or throws an `ArgumentError` if the key is not found in the map.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/common/utils/map_extension.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary:\n\n**lib/src/common/utils/map_extension.dart**\n\nProvides a `fetch` method for safely retrieving values from maps by key, throwing an error if the key is missing."}
{"code": "abstract class BaseValidator {\n  bool get isValid;\n  // a function that throws the adequate error if the input is invalid\n  void validate();\n}\n", "explanation": "**Summary**\n\nThis block defines an abstract class `BaseValidator` with two properties:\n\n1. **isValid**: A boolean indicating whether the input is valid.\n2. **validate(): void**: A method that throws an error if the input is invalid.\n\nIn other words, it's a template for creating validators that check the validity of inputs and report errors if necessary.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/common/validators/base_validator.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary:\n\n`BaseValidator`: An abstract class providing a basic validation template with `isValid` property and `validate()` method, enabling creation of specific validators to check input validity and report errors."}
{"code": "import 'package:tezart/src/crypto/crypto.dart';\nimport 'package:tezart/tezart.dart';\n\nimport 'base_validator.dart';\n\n/// A validator that checks whether [str] is a valid hexadecimal\nclass HexValidator implements BaseValidator {\n  final String str;\n\n  HexValidator(this.str);\n\n  /// Returns true if [str] is a valid hexadecimal\n  @override\n  bool get isValid => RegExp(r'^[a-fA-F0-9]+$').hasMatch(str);\n\n  /// Throws [CryptoError] if [str] is not a valid hexadecimal\n  @override\n  void validate() {\n    if (!isValid) throw CryptoError(type: CryptoErrorTypes.invalidHex);\n  }\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Validates whether a string is a valid hexadecimal value.\n\n**Functionality:** Checks for hexadecimal characters using a regular expression, throwing an error if invalid.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/common/validators/hex_validator.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'lib/src/common/validators/hex_validator.dart':\n\n**Validates Hexadecimal Strings**: Ensures input strings conform to hexadecimal format, raising errors on invalid inputs using regex pattern checks."}
{"code": "import 'package:tezart/tezart.dart';\n\nimport 'base_validator.dart';\n\n/// A validator that checks whether [simulationResult] is applied\n///\n/// [simulationResult] is supposed to be the result of [rpcInterface.runOperations] of [rpcInterface.preapplyOperations]\nclass SimulationResultValidator implements BaseValidator {\n  final Map<String, dynamic> simulationResult;\n\n  SimulationResultValidator(this.simulationResult);\n\n  /// Returns true if the status of this is 'applied'\n  @override\n  bool get isValid {\n    return _status == 'applied';\n  }\n\n  String get _status {\n    return _operationResult['status'];\n  }\n\n  String get _kind {\n    return simulationResult['kind'];\n  }\n\n  Map<String, dynamic> get _operationResult {\n    final operationResult = simulationResult['metadata']?['operation_result'];\n    if (operationResult == null) throw ArgumentError.notNull(\"simulationResult['metadata']?['operation_result']\");\n\n    return operationResult;\n  }\n\n  String get _reason {\n    final errors = _operationResult['errors'];\n", "explanation": "Here is a concise summary of the block:\n\n**Purpose:** A validator that checks if a simulation result is applied.\n\n**Functionality:** Verifies the status of a simulation result from Tezart's rpcInterface, returning true if it's 'applied'.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/common/validators/simulation_result_validator.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise holistic summary:\n\n**Simulation Result Validator**\n\nValidates simulation results by checking their application status with Tezart's RPC interface, throwing errors for invalid or unapplied results."}
{"code": "    if (errors == null) throw ArgumentError.notNull(\"_operationResult['errors']\");\n\n    // ignore the protocol part of the error (\"proto.007-PsDELPH1\" part)\n    return _operationResult['errors'].map((el) => (el['id'] as String?)?.split('.').sublist(2).join('.')).join(', ');\n  }\n\n  /// Throws [TezartNodeError] if [_status] is not 'applied'\n  @override\n  void validate() {\n    if (!isValid) {\n      final metadata = {\n        'operationKind': _kind,\n        'reason': _reason,\n      };\n\n      throw TezartNodeError(\n        type: TezartNodeErrorTypes.simulationFailed,\n        metadata: metadata,\n      );\n    }\n  }\n}\n", "explanation": "Here is a summary of the block:\n\n**Purpose:** Validates operation result and throws errors if invalid.\n\n**Functionality:**\n\n* Checks if \"errors\" is null, throwing an error if so.\n* Extracts and formats error IDs from operation result.\n* Validates operation status and throws TezartNodeError if not 'applied'.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/common/validators/simulation_result_validator.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise holistic summary:\n\n**Simulation Result Validator**\n\nValidates simulation results by checking their application status with Tezart's RPC interface, throwing errors for invalid or unapplied results."}
{"code": "/// A library that allows contracts manipulations\n///\n/// It exposes:\n/// - [Contract]\n/// - [BigMap]\nlibrary contract;\n\nexport 'impl/contract.dart';\nexport 'impl/big_map.dart';\n", "explanation": "This block defines a library called \"contract\" with the purpose of allowing contract manipulations, exposing two key features: Contract and BigMap functionality.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/contracts/contract.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary:\n\n**Summary**\n\nThe 'lib/src/contracts/contract.dart' file defines a library that enables contract manipulations, providing access to fundamental features such as `Contract` and `BigMap`."}
{"code": "import 'dart:typed_data';\n\nimport 'package:convert/convert.dart';\nimport 'package:tezart/src/core/rpc/impl/rpc_interface.dart';\nimport 'package:tezart/src/crypto/crypto.dart';\nimport 'package:tezart/src/micheline_decoder/micheline_decoder.dart';\nimport 'package:tezart/src/micheline_encoder/micheline_encoder.dart';\n\n/// A class that allows big maps values fetching\n///\n/// - [name] is the name of this if it is annotated\n/// - [id] the id of this\n/// - [valueType] the value type of this in Micheline\n/// - [keyType] the key type of this in Micheline\nclass BigMap {\n  final String? name;\n  final String id;\n  final Map<String, dynamic> valueType, keyType;\n\n  BigMap({\n    required this.name,\n    required this.id,\n    required this.valueType,\n    required this.keyType,\n  });\n\n  /// Fetches [key] from this using [rpcInterface]\n  ///\n  /// if the key is not found a [TezartHttpError] is thrown\n  /// - [key] is supposed to be a Dart Type. It will be converted using [MichelineEncoder]", "explanation": "Here is a concise summary:\n\n**Purpose:** A class for fetching values from Big Maps in Tezos blockchain.\n\n**Functionality:** Allows retrieval of values associated with specific keys, using Micheline encoding/decoding and RPC interface. Throws error if key not found.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/contracts/impl/big_map.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary:\n\nThe `BigMap` class in `lib/src/contracts/impl/big_map.dart` fetches values from Tezos blockchain's Big Maps using Micheline encoding/decoding and RPC interface, returning the associated value for a given key or throwing an error if not found."}
{"code": "  Future<dynamic> fetch({required dynamic key, required RpcInterface rpcInterface}) async {\n    final michelineKey = MichelineEncoder(type: keyType, params: key).encode();\n    final encodedScriptExpression = await _encodedScriptExpression(\n      decodedKey: michelineKey,\n      rpcInterface: rpcInterface,\n    );\n\n    final michelineValue = await rpcInterface.bigMapValue(id: id, encodedScriptExpression: encodedScriptExpression);\n\n    return MichelineDecoder(type: valueType, data: michelineValue).decode();\n  }\n\n  Future<String> _encodedScriptExpression({dynamic decodedKey, required RpcInterface rpcInterface}) async {\n    final packedKey = await rpcInterface.pack(data: decodedKey, type: keyType);\n    final bytesKey = Uint8List.fromList(hex.decode(packedKey));\n    final hashKey = hashWithDigestSize(size: 256, bytes: bytesKey);\n\n    return encodeWithPrefix(prefix: Prefixes.expr, bytes: hashKey);\n  }\n}\n", "explanation": "Here is a concise summary:\n\n**Block Purpose:** Fetch data from a Big Map (a type of data storage) using RPC interface.\n\n**Functionality:** Encodes key and script expression, sends request to RPC interface, decodes response, and returns result. \n\nLet me know if you'd like me to clarify anything!", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/contracts/impl/big_map.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary:\n\nThe `BigMap` class in `lib/src/contracts/impl/big_map.dart` fetches values from Tezos blockchain's Big Maps using Micheline encoding/decoding and RPC interface, returning the associated value for a given key or throwing an error if not found."}
{"code": "import 'package:memoize/memoize.dart';\nimport 'package:tezart/tezart.dart';\n\n/// A class that handles Tezos's contracts\n///\n/// - [contractAddress] is the address of this\n///\n/// It allows to :\n/// - fetch the balance, storage, entrypoints of a contract\n/// - compute the [OperationsList] related to a call of an entrypoint of a contract\n///\n/// If [contractAddress] is not found a [TezartHttpError] is thrown while calling a method of this\nclass Contract {\n  final String contractAddress;\n  final RpcInterface rpcInterface;\n\n  Contract({required this.contractAddress, required this.rpcInterface});\n\n  /// Returns the balance of this\n  Future<int> get balance async => int.parse((await _contractInfo)['balance']);\n\n  /// Returns the storage in Dart Type of this using [MichelineDecoder]\n  Future<dynamic> get storage async {\n    final contractInfo = await _contractInfo;\n    final michelineStorage = contractInfo['script']['storage'];\n    final type = await _storageType;\n", "explanation": "Here is a concise summary:\n\n**Contract Class**\n\nHandles Tezos contracts, providing functionality for:\n\n* Fetching contract balance, storage, and entrypoints\n* Computing operations related to contract calls\n* Throws error if contract address not found\n\nInitializes with `contractAddress` and `RpcInterface`.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/contracts/impl/contract.dart", "chunk_number": 1, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary of the file 'lib/src/contracts/impl/contract.dart':\n\nThe `Contract` class provides functionality for interacting with Tezos contracts, including decoding Micheline data, retrieving entrypoints, executing operations, and managing contract balance and storage. It takes a `contractAddress` and an `RpcInterface` as input, allowing for customizable fees and limits in operation execution."}
{"code": "    return MichelineDecoder(type: type, data: michelineStorage).decode();\n  }\n\n  /// Returns a [List] containing the entrypoints of this\n  Future<List<String>> get entrypoints async =>\n      memo0(() async => (await rpcInterface.getContractEntrypoints(contractAddress)).keys.toList())();\n\n  /// Returns a [OperationsList] containing a [TransactionOperation] related to a call of an entrypoint of the contract\n  ///\n  /// - [entrypoint] is the entrypoint we want to call. Default value is 'default'\n  /// - [params] is the parameters in Dart Types of the call operation. [MichelineEncoder] is used for conversion to Micheline\n  /// - [source] is the [Keystore] initiating the operation\n  /// - [amount] is the amount of the operation. Default value is 0\n  ///\n  /// - when [params] are incompatible with the entrypoint signature, a [TypeError] is thrown\n  Future<OperationsList> callOperation({\n    String entrypoint = 'default',\n    dynamic params,\n    required Keystore source,\n    int amount = 0,\n    int? customFee,", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** To provide functions for interacting with a contract: decoding Micheline data, retrieving entrypoints, and executing operations.\n\n**Functionality:**\n\n* `decode()`: Decodes Micheline data.\n* `get entrypoints`: Retrieves a list of entrypoints associated with the contract.\n* `callOperation()`: Executes an operation on the contract, taking parameters, source, amount, and custom fee as input.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/contracts/impl/contract.dart", "chunk_number": 2, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary of the file 'lib/src/contracts/impl/contract.dart':\n\nThe `Contract` class provides functionality for interacting with Tezos contracts, including decoding Micheline data, retrieving entrypoints, executing operations, and managing contract balance and storage. It takes a `contractAddress` and an `RpcInterface` as input, allowing for customizable fees and limits in operation execution."}
{"code": "    int? customGasLimit,\n    int? customStorageLimit,\n  }) async {\n    final type = await _type(entrypoint);\n    final michelineParams = MichelineEncoder(type: type, params: params).encode();\n\n    return OperationsList(\n      source: source,\n      rpcInterface: rpcInterface,\n    )..appendOperation(TransactionOperation(\n        amount: amount,\n        destination: contractAddress,\n        params: michelineParams,\n        entrypoint: entrypoint,\n        customFee: customFee,\n        customGasLimit: customGasLimit,\n        customStorageLimit: customStorageLimit,\n      ));\n  }\n\n  Future<Map<String, dynamic>> get _contractInfo => rpcInterface.getContract(contractAddress);\n  Future<Map<String, dynamic>> get _storageType async {\n    return memo0<Future<Map<String, dynamic>>>(() async {\n      final contractInfo = await _contractInfo;\n      final List code = contractInfo['script']['code'];\n\n      return code.firstWhere((element) => element['prim'] == 'storage')['args'].first;\n    })();\n  }\n", "explanation": "Here is a concise summary:\n\nThis block creates a transaction operation and adds it to an operations list, allowing for customizable fees and limits. It also retrieves contract information and storage type through RPC interfaces.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/contracts/impl/contract.dart", "chunk_number": 3, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary of the file 'lib/src/contracts/impl/contract.dart':\n\nThe `Contract` class provides functionality for interacting with Tezos contracts, including decoding Micheline data, retrieving entrypoints, executing operations, and managing contract balance and storage. It takes a `contractAddress` and an `RpcInterface` as input, allowing for customizable fees and limits in operation execution."}
{"code": "  Future<Map<String, dynamic>> _type(String entrypoint) =>\n      rpcInterface.getContractEntrypointType(address: contractAddress, entrypoint: entrypoint);\n}\n", "explanation": "This block appears to be a function that:\n\n**Purpose:** Retrieves the type of a contract's entry point.\n**Functionality:** Calls an RPC interface method to fetch this information.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/contracts/impl/contract.dart", "chunk_number": 4, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary of the file 'lib/src/contracts/impl/contract.dart':\n\nThe `Contract` class provides functionality for interacting with Tezos contracts, including decoding Micheline data, retrieving entrypoints, executing operations, and managing contract balance and storage. It takes a `contractAddress` and an `RpcInterface` as input, allowing for customizable fees and limits in operation execution."}
{"code": "import 'package:logging/logging.dart';\nimport 'package:memoize/memoize.dart';\nimport 'package:tezart/src/core/rpc/rpc_interface.dart';\nimport 'package:tezart/src/keystore/keystore.dart';\nimport 'package:tezart/src/models/operation/operation.dart';\nimport 'package:tezart/src/models/operations_list/operations_list.dart';\n\nimport 'tezart_node_error.dart';\n\n/// A client that connects to the Tezos node.\n///\n/// ```dart\n/// final client = TezartClient('http://localhost:20000/');\n/// ```\n///\n/// The methods throw [TezartNodeError] if a node error occurs.\\\n/// Injection operations are retried 3 times if a counter error ocurs.\\\n/// Amounts are in \u00b5tz. 1tz = 1000000\u00b5tz.\nclass TezartClient {\n  final log = Logger('TezartClient');\n\n  /// A [RpcInterface] instance, generated using `url`\n  final RpcInterface rpcInterface;\n\n  /// Default constructor.\n  TezartClient(String url) : rpcInterface = RpcInterface(url);\n\n  /// Returns an [OperationsList] containing a [TransactionOperation] that transfers [amount] from [source]", "explanation": "**Summary:**\n\nThe `TezartClient` class is a client that connects to a Tezos node, allowing for interactions with the node through RPC calls. It provides methods to execute transactions and retrieve operation data, handling errors and retries as needed.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/client/impl/tezart_client.dart", "chunk_number": 1, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/core/client/impl/tezart_client.dart':\n\nThe TezartClient class provides asynchronous interactions with a Tezos node through RPC calls, allowing for transactions and data retrieval while handling errors and retries. It includes functions for transferring funds between accounts, revealing public keys, checking key reveal status, retrieving balances, and originating contracts on the blockchain. The client offers customization options for fees, gas limits, storage limits, and reveal status, with error handling and retry mechanisms in place."}
{"code": "  /// to [destination] and returns the operation group id.\\\n  ///\n  /// - [customFee] if set, will be used instead of the default fees computed by OperationFeesSetterVisitor\n  /// - [customGasLimit] if set, will be used instead of the default gasLimit computed by OperationFeesSetterVisitor\n  /// - [customStorageLimit] if set, will be used instead of the default storageLimit computed by OperationFeesSetterVisitor\n  /// - [reveal] if set to true, will prepend a [RevealOperation] if [source] is not already revealed\n  ///\n  /// ```dart\n  /// final source = Keystore.fromSecretKey('edskRpm2mUhvoUjHjXgMoDRxMKhtKfww1ixmWiHCWhHuMEEbGzdnz8Ks4vgarKDtxok7HmrEo1JzkXkdkvyw7Rtw6BNtSd7MJ7');\n  /// final destination = 'tz1LmRFP1yFg4oTwfThfbrJx2BfZVAK2h7eW';\n  /// final amount = 1000;\n  /// await client.transferOperation(source: source, destination: destionation, amount: amount);\n  /// ```\n  ///\n  /// Retries 3 times if a counter error occurs ([TezartNodeErrorTypes.counterError]).", "explanation": "Here is a concise summary:\n\nThis block allows for a transfer operation between two Tezos accounts (`source` and `destination`) with customizable fees, gas limit, and storage limit. It can also prepend a reveal operation if the source account is not already revealed. The function retries three times in case of a counter error.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/client/impl/tezart_client.dart", "chunk_number": 2, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/core/client/impl/tezart_client.dart':\n\nThe TezartClient class provides asynchronous interactions with a Tezos node through RPC calls, allowing for transactions and data retrieval while handling errors and retries. It includes functions for transferring funds between accounts, revealing public keys, checking key reveal status, retrieving balances, and originating contracts on the blockchain. The client offers customization options for fees, gas limits, storage limits, and reveal status, with error handling and retry mechanisms in place."}
{"code": "  Future<OperationsList> transferOperation({\n    required Keystore source,\n    required String destination,\n    required int amount,\n    int? customFee,\n    int? customGasLimit,\n    int? customStorageLimit,\n    bool reveal = true,\n  }) async {\n    return _catchHttpError<OperationsList>(() async {\n      log.info('request transfer $amount \u00b5tz from $source.address to the destination $destination');\n\n      final operationsList = OperationsList(source: source, rpcInterface: rpcInterface)\n        ..appendOperation(\n          TransactionOperation(\n            amount: amount,\n            destination: destination,\n            customFee: customFee,\n            customGasLimit: customGasLimit,\n            customStorageLimit: customStorageLimit,\n          ),\n        );\n      if (reveal) {\n        await _prependRevealIfNotRevealed(\n          operationsList,\n          source,\n          customFee: customFee,\n          customGasLimit: customGasLimit,\n          customStorageLimit: customStorageLimit,\n        );\n      }\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Asynchronously transfers a specified amount of MTC (\u00b5tz) from a Keystore source to a destination.\n\n**Functionality:** Creates a list of operations for a transfer, optionally prepends a reveal operation if not already revealed, and returns the result as a Future.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/client/impl/tezart_client.dart", "chunk_number": 3, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/core/client/impl/tezart_client.dart':\n\nThe TezartClient class provides asynchronous interactions with a Tezos node through RPC calls, allowing for transactions and data retrieval while handling errors and retries. It includes functions for transferring funds between accounts, revealing public keys, checking key reveal status, retrieving balances, and originating contracts on the blockchain. The client offers customization options for fees, gas limits, storage limits, and reveal status, with error handling and retry mechanisms in place."}
{"code": "      return operationsList;\n    });\n  }\n\n  /// Returns an [OperationsList] that reveals [source] publicKey.\n  OperationsList revealKeyOperation(\n    Keystore source, {\n    int? customFee,\n    int? customGasLimit,\n    int? customStorageLimit,\n  }) {\n    log.info('request to revealKey');\n\n    return OperationsList(source: source, rpcInterface: rpcInterface)\n      ..appendOperation(RevealOperation(\n        customFee: customFee,\n        customGasLimit: customGasLimit,\n        customStorageLimit: customStorageLimit,\n      ));\n  }\n\n  /// Returns `true` if the public key of [address] is revealed.\n  Future<bool> isKeyRevealed(String address) async {\n    return memo1<String, Future<bool>>((String address) async {\n      log.info('request to find if isKeyRevealed');\n      final managerKey = await rpcInterface.managerKey(address);\n\n      return managerKey != null;\n    })(address);\n  }\n\n  /// Returns the balance in \u00b5tz of `address`.\n  Future<int> getBalance({required String address}) {\n    log.info('request to getBalance');", "explanation": "Here is a concise summary:\n\n**Summary:**\n\nThis block contains four functions for interacting with an Ethereum key store, allowing for operations such as revealing a public key, checking if a key is revealed, and retrieving balance information.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/client/impl/tezart_client.dart", "chunk_number": 4, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/core/client/impl/tezart_client.dart':\n\nThe TezartClient class provides asynchronous interactions with a Tezos node through RPC calls, allowing for transactions and data retrieval while handling errors and retries. It includes functions for transferring funds between accounts, revealing public keys, checking key reveal status, retrieving balances, and originating contracts on the blockchain. The client offers customization options for fees, gas limits, storage limits, and reveal status, with error handling and retry mechanisms in place."}
{"code": "    return _catchHttpError<int>(() => rpcInterface.balance(address));\n  }\n\n  /// Waits for [operationId] to be included in a block.\n  ///\n  /// ```dart\n  /// final operationsList = await client.revealKeyOperation(source);\n  /// await operationsList.execute();\n  /// await client.monitorOperation(operationsList.result.id);\n  /// ```\n  Future<String> monitorOperation(String operationId) {\n    return _catchHttpError<String>(() async {\n      log.info('monitoring the operation $operationId');\n\n      return rpcInterface.monitorOperation(operationId: operationId);\n    });\n  }\n\n  /// Returns an [OperationsList] that originates a contract initiated by [source]\n  ///\n  /// - [source] is the [Keystore] initiating the operation\n  /// - [code] is the code of the smart contract in Micheline\n  /// - [storage] is the initial storage of the contract in Micheline\n  /// - [balance] is the balance of the originated contract\n  /// - [customFee] if set, will be used instead of the default fees computed by OperationFeesSetterVisitor", "explanation": "Here is a concise summary:\n\nThis code block contains three functions:\n\n1. A function that retrieves an account's balance.\n2. A function (`monitorOperation`) that waits for an operation to be included in a blockchain block.\n3. A function that originates a contract with specified parameters and returns an `OperationsList` object.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/client/impl/tezart_client.dart", "chunk_number": 5, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/core/client/impl/tezart_client.dart':\n\nThe TezartClient class provides asynchronous interactions with a Tezos node through RPC calls, allowing for transactions and data retrieval while handling errors and retries. It includes functions for transferring funds between accounts, revealing public keys, checking key reveal status, retrieving balances, and originating contracts on the blockchain. The client offers customization options for fees, gas limits, storage limits, and reveal status, with error handling and retry mechanisms in place."}
{"code": "  /// - [customGasLimit] if set, will be used instead of the default gasLimit computed by OperationFeesSetterVisitor\n  /// - [customStorageLimit] if set, will be used instead of the default storageLimit computed by OperationFeesSetterVisitor\n  /// - [reveal] if set to true, will prepend a [RevealOperation] if [source] is not already revealed\n  ///\n  Future<OperationsList> originateContractOperation({\n    required Keystore source,\n    required List<Map<String, dynamic>> code,\n    required dynamic storage,\n    required int balance,\n    int? customFee,\n    int? customGasLimit,\n    int? customStorageLimit,\n    bool reveal = true,\n  }) async {\n    return _catchHttpError<OperationsList>(() async {\n      log.info('request to originateContract');\n\n      var operationsList = OperationsList(\n        source: source,\n        rpcInterface: rpcInterface,\n      )..appendOperation(\n          OriginationOperation(\n            balance: balance,\n            code: code,\n            storage: storage,", "explanation": "**Purpose:** Originates a new contract on a blockchain.\n\n**Functionality:** This block sends an \"originateContract\" operation to the blockchain, creating a new contract with specified code, storage, and balance. It can also customize gas limit, storage limit, and reveal status.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/client/impl/tezart_client.dart", "chunk_number": 6, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/core/client/impl/tezart_client.dart':\n\nThe TezartClient class provides asynchronous interactions with a Tezos node through RPC calls, allowing for transactions and data retrieval while handling errors and retries. It includes functions for transferring funds between accounts, revealing public keys, checking key reveal status, retrieving balances, and originating contracts on the blockchain. The client offers customization options for fees, gas limits, storage limits, and reveal status, with error handling and retry mechanisms in place."}
{"code": "            customFee: customFee,\n            customGasLimit: customGasLimit,\n            customStorageLimit: customStorageLimit,\n          ),\n        );\n      if (reveal) {\n        await _prependRevealIfNotRevealed(\n          operationsList,\n          source,\n          customFee: customFee,\n          customGasLimit: customGasLimit,\n          customStorageLimit: customStorageLimit,\n        );\n      }\n\n      return operationsList;\n    });\n  }\n\n  Future<T> _catchHttpError<T>(Future<T> Function() func) {\n    return catchHttpError<T>(func, onError: (TezartHttpError e) {\n      log.severe('Http Error', e);\n    });\n  }\n\n  Future<void> _prependRevealIfNotRevealed(\n    OperationsList list,\n    Keystore source, {\n    int? customFee,\n    int? customGasLimit,\n    int? customStorageLimit,\n  }) async =>\n      await isKeyRevealed(source.address)\n          ? null\n          : list.prependOperation(RevealOperation(\n              customFee: customFee,\n              customGasLimit: customGasLimit,", "explanation": "**Block Summary**\n\nThis block prepares an operations list by:\n\n1. Setting custom fee, gas limit, and storage limit.\n2. If reveal is enabled:\n\t* Checking if a key has been revealed (using `_prependRevealIfNotRevealed` function).\n\t* Prepending a Reveal Operation to the list if not revealed.\n\n**Key Functions**\n\n* `_catchHttpError`: catches HTTP errors in a future and logs them.\n* `_prependRevealIfNotRevealed`: checks if a key has been revealed and prepends a Reveal Operation to the operations list if not.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/client/impl/tezart_client.dart", "chunk_number": 7, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/core/client/impl/tezart_client.dart':\n\nThe TezartClient class provides asynchronous interactions with a Tezos node through RPC calls, allowing for transactions and data retrieval while handling errors and retries. It includes functions for transferring funds between accounts, revealing public keys, checking key reveal status, retrieving balances, and originating contracts on the blockchain. The client offers customization options for fees, gas limits, storage limits, and reveal status, with error handling and retry mechanisms in place."}
{"code": "              customStorageLimit: customStorageLimit,\n            ));\n}\n", "explanation": "This block appears to be a function parameter, specifically setting a value for \"customStorageLimit\".", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/client/impl/tezart_client.dart", "chunk_number": 8, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/core/client/impl/tezart_client.dart':\n\nThe TezartClient class provides asynchronous interactions with a Tezos node through RPC calls, allowing for transactions and data retrieval while handling errors and retries. It includes functions for transferring funds between accounts, revealing public keys, checking key reveal status, retrieving balances, and originating contracts on the blockchain. The client offers customization options for fees, gas limits, storage limits, and reveal status, with error handling and retry mechanisms in place."}
{"code": "import 'package:tezart/src/common/exceptions/common_exception.dart';\nimport 'package:tezart/src/common/utils/enum_util.dart';\nimport 'package:tezart/src/common/utils/map_extension.dart';\nimport 'package:tezart/src/core/rpc/rpc_interface.dart';\n\n/// Exhaustive list of node errors.\nenum TezartNodeErrorTypes {\n  /// Already revealed public key.\n  ///\n  /// Happens when trying to reveal an already revealed key.\n  alreadyRevealedKey,\n\n  /// Operation monitoring timedout.\n  ///\n  /// Happens when the monitoring of an operation times out :\n  /// - time between two blocks exceeded the limit.\n  /// - waited for too much blocks without retrieving the operation id.\n  monitoringTimedOut,\n\n  /// Counter already used error.\n  ///\n  /// Happens when the counter of an operation has already been used.\n  counterError,\n\n  /// Simulation status is != applied\n  simulationFailed,\n\n  /// Unhandled error.\n  unhandled,\n}\n\n/// Exception thrown when an error occurs during an RPC node call.\n///", "explanation": "Here is a concise summary:\n\n**Purpose:** Define custom exceptions for Tezart-related errors.\n\n**Functionality:** Throws exceptions based on predefined enum values (TezartNodeErrorTypes) representing specific error scenarios when interacting with RPC nodes, such as revealing an already revealed key or monitoring timed out operations.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/client/impl/tezart_node_error.dart", "chunk_number": 1, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise holistic summary:\n\n**Tezart Node Error Handling**\n\nThe `tezart_node_error.dart` file defines a custom exception class (`TezartNodeError`) for handling errors in Tezos node interactions. It provides predefined error types (enum) and allows dynamic message creation. The code throws exceptions based on specific scenarios, such as revealing an already revealed key or monitoring timed out operations. It also analyzes error messages using regular expressions to determine the error type and returns a human-readable explanation."}
{"code": "/// You can translate the error messages using [key] or [type].\n///\n/// ```dart\n/// try {\n///   await RpcFailingCall();\n/// } on TezartNodeError catch (e) {\n///   print(e.message); // \"You're trying to reveal an already revealed key.\"\n///   print(e.key); // 'alreadyRevealedKey'\n/// }\nclass TezartNodeError extends CommonException {\n  final TezartHttpError? cause;\n  final TezartNodeErrorTypes? _inputType;\n  final String? _inputMessage;\n  final Map<String, String> metadata;\n\n  Map<TezartNodeErrorTypes, String> get staticErrorsMessages {\n    return {\n      TezartNodeErrorTypes.alreadyRevealedKey: \"You're trying to reveal an already revealed key.\",\n      TezartNodeErrorTypes.counterError: 'A counter error occured',\n      TezartNodeErrorTypes.unhandled: 'Unhandled error: $_errorMsg',\n    };\n  }\n\n  final dynamicErrorMessages = {\n    TezartNodeErrorTypes.monitoringTimedOut: (String operationId) => 'Monitoring the operation $operationId timed out',", "explanation": "Here is a concise summary:\n\n**Purpose:** A custom exception class (`TezartNodeError`) for handling errors in a Tezos node.\n\n**Functionality:** Provides error messages based on specific types (e.g., `alreadyRevealedKey`, `counterError`), and allows dynamic message creation for certain error types.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/client/impl/tezart_node_error.dart", "chunk_number": 2, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise holistic summary:\n\n**Tezart Node Error Handling**\n\nThe `tezart_node_error.dart` file defines a custom exception class (`TezartNodeError`) for handling errors in Tezos node interactions. It provides predefined error types (enum) and allows dynamic message creation. The code throws exceptions based on specific scenarios, such as revealing an already revealed key or monitoring timed out operations. It also analyzes error messages using regular expressions to determine the error type and returns a human-readable explanation."}
{"code": "    TezartNodeErrorTypes.simulationFailed: (String operationKind, String reason) =>\n        'The simulation of the operation: \"$operationKind\" failed with error(s) : $reason',\n  };\n\n  /// Default constructor.\n  ///\n  /// - [type] is required.\n  /// - [message] is optional. If provided, it will be used.\n  ///     If not, it will use `staticErrorMessages[type]` or `dynamicErrorMessages[type]` (in this priority order).\n  /// - [metadata] is optional and must include metadata used to compute the message.\n  ///     example: `{ 'operationId': 'opId' }` for monitoring time out errors.\n  TezartNodeError({required TezartNodeErrorTypes type, String? message, metadata})\n      : _inputType = type,\n        _inputMessage = message,\n        metadata = metadata ?? {},\n        cause = null;\n\n  /// Named constructor to construct [TezartNodeError] by passing a [TezartHttpError] object.\n  TezartNodeError.fromHttpError(this.cause)\n      : _inputType = null,\n        _inputMessage = null,\n        metadata = {};\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Define error types for TezartNode.\n\n**Functionality:**\n\n* Enumerate simulation failure errors with specific reasons.\n* Provide constructors to create TezartNodeError objects:\n\t+ Default constructor takes type, optional message, and metadata.\n\t+ Named constructor creates from a TezartHttpError object.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/client/impl/tezart_node_error.dart", "chunk_number": 3, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise holistic summary:\n\n**Tezart Node Error Handling**\n\nThe `tezart_node_error.dart` file defines a custom exception class (`TezartNodeError`) for handling errors in Tezos node interactions. It provides predefined error types (enum) and allows dynamic message creation. The code throws exceptions based on specific scenarios, such as revealing an already revealed key or monitoring timed out operations. It also analyzes error messages using regular expressions to determine the error type and returns a human-readable explanation."}
{"code": "  /// Type of this.\n  TezartNodeErrorTypes get type => _inputType ?? _computedType;\n\n  /// Human readable explanation of this.\n  @override\n  String get message => _inputMessage ?? _computedMessage;\n\n  TezartNodeErrorTypes get _computedType {\n    if (RegExp(r'Counter.*already used.*').hasMatch(_errorMsg ?? '')) {\n      return TezartNodeErrorTypes.counterError;\n    }\n\n    if (RegExp(r'previously_revealed_key').hasMatch(_errorId ?? '')) {\n      return TezartNodeErrorTypes.alreadyRevealedKey;\n    }\n\n    if (RegExp(r'counter_in_the_past').hasMatch(_errorId ?? '')) {\n      return TezartNodeErrorTypes.counterError;\n    }\n\n    return TezartNodeErrorTypes.unhandled;\n  }\n\n  // TODO: what to do when there is multiple errors ?\n  String? get _errorId {\n    final response = cause?.responseBody;\n\n    try {\n      return response.first['id'];\n    } on NoSuchMethodError {\n      return null;\n    }\n  }\n\n  String? get _errorMsg {\n    final response = cause?.responseBody;\n\n    try {\n      return response.first['msg'] ?? response.first['id'];", "explanation": "Here is a concise summary:\n\n**Purpose:** Determine the type of error and provide a human-readable explanation.\n\n**Functionality:**\n\n* Analyze error messages using regular expressions to determine the error type (e.g., counterError, alreadyRevealedKey).\n* Extract specific details from the error response (error ID, message) when available.\n* Return a default error type if not matched.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/client/impl/tezart_node_error.dart", "chunk_number": 4, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise holistic summary:\n\n**Tezart Node Error Handling**\n\nThe `tezart_node_error.dart` file defines a custom exception class (`TezartNodeError`) for handling errors in Tezos node interactions. It provides predefined error types (enum) and allows dynamic message creation. The code throws exceptions based on specific scenarios, such as revealing an already revealed key or monitoring timed out operations. It also analyzes error messages using regular expressions to determine the error type and returns a human-readable explanation."}
{"code": "    } on NoSuchMethodError {\n      return cause?.clientError.message;\n    }\n  }\n\n  /// String representation of type.\n  @override\n  String get key => EnumUtil.enumToString(type);\n\n  String get _computedMessage {\n    if (staticErrorsMessages.containsKey(type)) {\n      return staticErrorsMessages[type]!;\n    }\n\n    switch (type) {\n      case TezartNodeErrorTypes.monitoringTimedOut:\n        return dynamicErrorMessages[type]!(metadata.fetch<String>('operationId'));\n      case TezartNodeErrorTypes.simulationFailed:\n        return dynamicErrorMessages[type]!(metadata.fetch<String>('operationKind'), metadata.fetch<String>('reason'));\n      default:\n        throw UnimplementedError('Unimplemented error type $type');\n    }\n  }\n\n  /// Cause of this.\n  ///\n  /// It represents the error that caused this.\n  @override\n  TezartHttpError? get originalException => cause;\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Returns an error message or representation based on the type of error.\n\n**Functionality:**\n\n* Handles `NoSuchMethodError` by returning the client error message.\n* Provides a string representation of the error type via `key`.\n* Computes and returns a custom error message for specific error types using switch statements.\n* Exposes the original cause of the error via `originalException`.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/client/impl/tezart_node_error.dart", "chunk_number": 5, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise holistic summary:\n\n**Tezart Node Error Handling**\n\nThe `tezart_node_error.dart` file defines a custom exception class (`TezartNodeError`) for handling errors in Tezos node interactions. It provides predefined error types (enum) and allows dynamic message creation. The code throws exceptions based on specific scenarios, such as revealing an already revealed key or monitoring timed out operations. It also analyzes error messages using regular expressions to determine the error type and returns a human-readable explanation."}
{"code": "/// A library that allows making calls to Tezos nodes.\n///\n/// It exposes:\n/// - [TezartClient]\n/// - [TezartNodeError]\nlibrary tezart_client;\n\nexport 'impl/tezart_client.dart';\nexport 'impl/tezart_node_error.dart';\n", "explanation": "Here is a concise summary:\n\n**Summary:** A library (tezart_client) that enables making calls to Tezos nodes, exposing client functionality and error handling.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/client/tezart_client.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'lib/src/core/client/tezart_client.dart':\n\n**Summary:** A Tezos client library providing node interaction and error handling capabilities."}
{"code": "import 'dart:convert';\n\nimport 'package:tezart/src/core/client/impl/tezart_node_error.dart';\nimport 'package:tezart/src/core/rpc/impl/rpc_interface.dart';\n\nimport 'rpc_interface_paths.dart' as paths;\n\nclass OperationsMonitor {\n  final RpcInterface rpcInterface;\n\n  OperationsMonitor(this.rpcInterface);\n\n  Future<String> monitor({\n    required String chain,\n    required String level,\n    required String operationId,\n  }) async {\n    // TODO: compute timeout based on time between blocks (problem in the CI when the blockchain just started)\n    const timeoutBetweenChunks = Duration(minutes: 3);\n    const nbOfBlocksToWait = 2;\n\n    final predHash = await _predecessorHash(chain: chain, level: level);\n    final isOpIdIncludedInPredBlock = await _isOperationIdIncludedInBlock(\n      blockHash: predHash,\n      operationId: operationId,\n    );\n    if (isOpIdIncludedInPredBlock) return predHash;\n\n    final rs = await rpcInterface.httpClient.getStream(paths.monitor(chain));", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Class:** OperationsMonitor\n**Purpose:** Monitor operations on a Tezos blockchain.\n**Functionality:** Uses RPC interface to retrieve predecessor hash, check if operation ID exists in previous blocks, and return the corresponding block hash.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/impl/operations_monitor.dart", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'lib/src/core/rpc/impl/operations_monitor.dart':\n\nThis file contains the `OperationsMonitor` class, which monitors operations on a Tezos blockchain via RPC interface. It checks for the presence of an operation ID in previous blocks, waits for a block with the operation ID to be processed and returns its hash if found, or throws an error if not found after a specified timeout."}
{"code": "    await for (var value in rs.data?.stream.timeout(timeoutBetweenChunks).take(nbOfBlocksToWait) ?? Stream.empty()) {\n      final decodedValue = json.decode(String.fromCharCodes(value));\n      final headBlockHash = decodedValue['hash'];\n      final isOpIdIncludedInBlock = await _isOperationIdIncludedInBlock(\n        blockHash: headBlockHash,\n        operationId: operationId,\n      );\n\n      if (isOpIdIncludedInBlock) return headBlockHash;\n    }\n\n    throw TezartNodeError(\n      type: TezartNodeErrorTypes.monitoringTimedOut,\n      metadata: {'operationId': operationId},\n    );\n  }\n\n  Future<String> _predecessorHash({required String chain, required String level}) async {\n    final block = await rpcInterface.block(chain: chain, level: level);\n\n    return block['header']['predecessor'] as String;\n  }\n\n  Future<bool> _isOperationIdIncludedInBlock({required String blockHash, required String operationId}) async {\n    await Future.delayed(Duration(seconds: 2));", "explanation": "Here is a concise summary:\n\n**Purpose:** Wait for a block with an operation ID to be processed and return its hash.\n\n**Functionality:** \n\n1. Iterate through blocks with a timeout between chunks.\n2. Check each block's header for the operation ID.\n3. If found, return the block hash.\n4. If not found after waiting for a specified number of blocks, throw an error.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/impl/operations_monitor.dart", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'lib/src/core/rpc/impl/operations_monitor.dart':\n\nThis file contains the `OperationsMonitor` class, which monitors operations on a Tezos blockchain via RPC interface. It checks for the presence of an operation ID in previous blocks, waits for a block with the operation ID to be processed and returns its hash if found, or throws an error if not found after a specified timeout."}
{"code": "    final operationHashesList = await rpcInterface.transactionsOperationHashes(level: blockHash);\n\n    return operationHashesList.contains(operationId);\n  }\n\n  // Don't delete this, might be useful to compute timeout between chunks\n  // Future<Map<String, dynamic>> _constants([chain = 'main', level = 'head']) async {\n  //   return _memo['constants'] ??= () async {\n  //     final response = await httpClient.get(paths.constants(chain: chain, level: level));\n\n  //     return response.data as Map<String, dynamic>;\n  //   }();\n  // }\n\n  // Future<Duration> _timeBetweenBlocks([chain = 'main', level = 'head']) async {\n  //   return _memo['_timeBetweenBlocks'] ??= () async {\n  //     final response = await constants(chain, level);\n\n  //     return Duration(seconds: int.parse(response['time_between_blocks'].first));\n  //   }();\n  // }\n}\n", "explanation": "Here is a concise summary:\n\nThis block checks if an operation exists in a list of transaction hashes for a given blockchain block hash. It returns true or false depending on whether the operation ID is found in the list.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/impl/operations_monitor.dart", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'lib/src/core/rpc/impl/operations_monitor.dart':\n\nThis file contains the `OperationsMonitor` class, which monitors operations on a Tezos blockchain via RPC interface. It checks for the presence of an operation ID in previous blocks, waits for a block with the operation ID to be processed and returns its hash if found, or throws an error if not found after a specified timeout."}
{"code": "import 'dart:async';\nimport 'dart:convert';\nimport 'package:logging/logging.dart';\nimport 'package:memoize/memoize.dart';\nimport 'package:tezart/src/core/rpc/impl/operations_monitor.dart';\nimport 'package:tezart/src/models/operations_list/operations_list.dart';\n\nimport 'tezart_http_client.dart';\nimport 'rpc_interface_paths.dart' as paths;\n\n/// A class that handles the calls to a Tezos RPC Node\n///\n/// - [url] is the url of the node\nclass RpcInterface {\n  static const _randomSignature =\n      'edsigu165B7VFf3Dpw2QABVzEtCxJY2gsNBNcE3Ti7rRxtDUjqTFRpg67EdAQmY6YWPE5tKJDMnSTJDFu65gic8uLjbW2YwGvAZ';\n  final TezartHttpClient httpClient;\n  final log = Logger('RpcInterface');\n\n  RpcInterface(String url) : httpClient = TezartHttpClient(url);\n\n  /// Returns the block's hash of [chain] and [level]\n  Future<String> branch([chain = 'main', level = 'head']) async {\n    log.info('request for branch [ chain:$chain, level:$level]');\n    var response = await httpClient.get(paths.branch(chain: chain, level: level));\n", "explanation": "Here is a summary of the purpose and functionality of this block:\n\n**Class:** RpcInterface\n**Purpose:** Handles calls to a Tezos RPC Node\n**Functionality:** Provides methods for interacting with the node, including retrieving data (e.g. branch hash) using HTTP requests.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/impl/rpc_interface.dart", "chunk_number": 1, "total_chunks": 10}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise and holistic summary of the file 'lib/src/core/rpc/impl/rpc_interface.dart':\n\n**Summary:** This Dart file provides asynchronous functions for interacting with a Tezos RPC Node API, allowing for data retrieval and operation management.\n\n**Functions:**\n\n1. Data Retrieval:\n\t* `chainId`: Retrieves chain ID by blockchain name.\n\t* `protocol`: Retrieves protocol of a specific blockchain and level.\n\t* `counter`: Retrieves counter value for a given source in a specified blockchain and level.\n\t* `pendingOperations`, `injectOperation`, `forgeOperations`: Interact with the API to retrieve or manage pending operations.\n2. Operation Management:\n\t* `preapplyOperations` and `runOperations`: Make HTTP requests to pre-apply or execute operations on a blockchain network.\n3. Contract Information:\n\t* `getManagerKey`, `getBalance`, `getContract`: Retrieve information about a smart contract's address, balance, and complete status.\n4. Entry Points:\n\t* `getContractEntrypoints` and `getContractEntrypointType`: Return entry point data for a given contract address.\n\n**Overall:** This file provides essential functionality for interacting with a Tezos RPC Node API, enabling data retrieval, operation management, and smart contract information access."}
{"code": "    return response.data;\n  }\n\n  /// Returns the chain id of [chain]\n  Future<String> chainId([chain = 'main']) async {\n    log.info('request for chainId [ chain:$chain ]');\n    var response = await httpClient.get(paths.chainId(chain));\n\n    return response.data;\n  }\n\n  /// Returns the protocol of [chain] and [level]\n  Future<String> protocol([chain = 'main', level = 'head']) async {\n    log.info('request for protocol [ chain:$chain, level:$level]');\n    var response = await httpClient.get(paths.protocol(chain: chain, level: level));\n\n    return response.data['protocol'];\n  }\n\n  /// Returns the counter of [source] in the chain defined by [chain] and [level]\n  Future<int> counter(String source, [chain = 'main', level = 'head']) async {\n    log.info('request for counter [ chain:$chain, level:$level]');\n    final response = await httpClient.get(paths.counter(source: source, chain: chain, level: level));\n\n    return int.parse(response.data);\n  }\n\n  /// Returns the pending operations of [chain]", "explanation": "Here is a concise summary:\n\n**Purpose:** This block contains four asynchronous functions that make HTTP requests to retrieve data from an API.\n\n**Functionality:**\n\n1. `response.data`: Returns the response data.\n2. `chainId(chain)`: Retrieves the chain ID of a specified blockchain (defaulting to 'main' if none specified).\n3. `protocol(chain, level)`: Retrieves the protocol of a specific blockchain and level (defaulting to 'main' and 'head' if none specified).\n4. `counter(source, [chain, level])`: Retrieves the counter value for a given source in a specific blockchain and level (defaulting to 'main' and 'head' if none specified).", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/impl/rpc_interface.dart", "chunk_number": 2, "total_chunks": 10}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise and holistic summary of the file 'lib/src/core/rpc/impl/rpc_interface.dart':\n\n**Summary:** This Dart file provides asynchronous functions for interacting with a Tezos RPC Node API, allowing for data retrieval and operation management.\n\n**Functions:**\n\n1. Data Retrieval:\n\t* `chainId`: Retrieves chain ID by blockchain name.\n\t* `protocol`: Retrieves protocol of a specific blockchain and level.\n\t* `counter`: Retrieves counter value for a given source in a specified blockchain and level.\n\t* `pendingOperations`, `injectOperation`, `forgeOperations`: Interact with the API to retrieve or manage pending operations.\n2. Operation Management:\n\t* `preapplyOperations` and `runOperations`: Make HTTP requests to pre-apply or execute operations on a blockchain network.\n3. Contract Information:\n\t* `getManagerKey`, `getBalance`, `getContract`: Retrieve information about a smart contract's address, balance, and complete status.\n4. Entry Points:\n\t* `getContractEntrypoints` and `getContractEntrypointType`: Return entry point data for a given contract address.\n\n**Overall:** This file provides essential functionality for interacting with a Tezos RPC Node API, enabling data retrieval, operation management, and smart contract information access."}
{"code": "  Future<Map<String, dynamic>> pendingOperations([chain = 'main']) async {\n    log.info('request for pendingOperations [ chain:$chain]');\n    final response = await httpClient.get(paths.pendingOperations(chain));\n\n    return response.data;\n  }\n\n  /// Injects the forged operation [data] in [chain] and returns the operation id\n  Future<String> injectOperation(String data, [chain = 'main']) async {\n    log.info('request for injectOperation [ chain:$chain]');\n    final response = await httpClient.post(paths.injectOperation(chain), data: jsonEncode(data));\n\n    return response.data;\n  }\n\n  /// Returns the forged operation of [operationsList] in the chain defined by [chain] and [level]\n  Future<String> forgeOperations(OperationsList operationsList, [chain = 'main', level = 'head']) async {\n    log.info('request for forgeOperations [ chain:$chain, level:$level]');\n    var content = {\n      'branch': await branch(),\n      'contents': operationsList.operations.map((operation) => operation.toJson()).toList(),\n    };\n", "explanation": "Here is a concise summary:\n\nThis block defines three asynchronous functions that interact with an API using `httpClient`:\n\n1. **pendingOperations**: Returns a list of pending operations for a given blockchain chain.\n2. **injectOperation**: Injects forged operation data into a blockchain chain and returns the operation ID.\n3. **forgeOperations**: Forges a list of operations on a specific blockchain chain, returning the resulting operation.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/impl/rpc_interface.dart", "chunk_number": 3, "total_chunks": 10}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise and holistic summary of the file 'lib/src/core/rpc/impl/rpc_interface.dart':\n\n**Summary:** This Dart file provides asynchronous functions for interacting with a Tezos RPC Node API, allowing for data retrieval and operation management.\n\n**Functions:**\n\n1. Data Retrieval:\n\t* `chainId`: Retrieves chain ID by blockchain name.\n\t* `protocol`: Retrieves protocol of a specific blockchain and level.\n\t* `counter`: Retrieves counter value for a given source in a specified blockchain and level.\n\t* `pendingOperations`, `injectOperation`, `forgeOperations`: Interact with the API to retrieve or manage pending operations.\n2. Operation Management:\n\t* `preapplyOperations` and `runOperations`: Make HTTP requests to pre-apply or execute operations on a blockchain network.\n3. Contract Information:\n\t* `getManagerKey`, `getBalance`, `getContract`: Retrieve information about a smart contract's address, balance, and complete status.\n4. Entry Points:\n\t* `getContractEntrypoints` and `getContractEntrypointType`: Return entry point data for a given contract address.\n\n**Overall:** This file provides essential functionality for interacting with a Tezos RPC Node API, enabling data retrieval, operation management, and smart contract information access."}
{"code": "    return memo1<Map<String, Object>, Future<String>>((Map<String, Object> content) async {\n      final response = await httpClient.post(paths.forgeOperations(chain: chain, level: level), data: content);\n      return response.data;\n    })(content);\n  }\n\n  /// Preapplies [operationsList] using [signature] in the chain defined by [chain] and [level] and returns the simlation result\n  Future<List<dynamic>> preapplyOperations({\n    required OperationsList operationsList,\n    required String signature,\n    chain = 'main',\n    level = 'head',\n  }) async {\n    log.info('request for preapplyOperations [ chain:$chain, level:$level]');\n    final content = [\n      {\n        'branch': await branch(),\n        'contents': operationsList.operations.map((operation) => operation.toJson()).toList(),\n        'signature': signature,\n        'protocol': await protocol(chain, level),\n      }\n    ];\n\n    var response = await httpClient.post(\n      paths.preapplyOperations(\n        chain: chain,\n        level: level,\n      ),", "explanation": "**Summary**\n\nThis block sends a POST request to a server using an HTTP client (`httpClient`) to pre-apply a list of operations to a blockchain at a specified `chain` and `level`. The request body contains the branch, contents (as JSON), signature, and protocol information. It returns the simulated result as a future list of dynamic values.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/impl/rpc_interface.dart", "chunk_number": 4, "total_chunks": 10}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise and holistic summary of the file 'lib/src/core/rpc/impl/rpc_interface.dart':\n\n**Summary:** This Dart file provides asynchronous functions for interacting with a Tezos RPC Node API, allowing for data retrieval and operation management.\n\n**Functions:**\n\n1. Data Retrieval:\n\t* `chainId`: Retrieves chain ID by blockchain name.\n\t* `protocol`: Retrieves protocol of a specific blockchain and level.\n\t* `counter`: Retrieves counter value for a given source in a specified blockchain and level.\n\t* `pendingOperations`, `injectOperation`, `forgeOperations`: Interact with the API to retrieve or manage pending operations.\n2. Operation Management:\n\t* `preapplyOperations` and `runOperations`: Make HTTP requests to pre-apply or execute operations on a blockchain network.\n3. Contract Information:\n\t* `getManagerKey`, `getBalance`, `getContract`: Retrieve information about a smart contract's address, balance, and complete status.\n4. Entry Points:\n\t* `getContractEntrypoints` and `getContractEntrypointType`: Return entry point data for a given contract address.\n\n**Overall:** This file provides essential functionality for interacting with a Tezos RPC Node API, enabling data retrieval, operation management, and smart contract information access."}
{"code": "      data: content,\n    );\n\n    // TODO: understand why array ? difference with run ??\n    return response.data.first['contents'];\n  }\n\n  /// Same as [preapplyOperations] but uses a random signature\n  Future<List<dynamic>> runOperations(OperationsList operationsList, [chain = 'main', level = 'head']) async {\n    log.info('request for runOperations [ chain:$chain, level:$level]');\n    var content = {\n      'operation': {\n        'branch': await branch(),\n        'contents': operationsList.operations.map((operation) => operation.toJson()).toList(),\n        'signature': _randomSignature\n      },\n      'chain_id': await chainId()\n    };\n\n    var response = await httpClient.post(paths.runOperations(chain: chain, level: level), data: content);\n\n    return response.data['contents'];\n  }\n\n  /// Returns the public key of [address]\n  ///\n  /// If the address is unknown by the node, it returns null\n  Future<String?> managerKey(String address, [chain = 'main', level = 'head']) async {", "explanation": "Here is a concise summary:\n\n**Purpose:** Two functions that interact with a node API: `preapplyOperations` and `runOperations`. \n\n**Functionality:**\n\n1. **preapplyOperations**: Returns contents data from a response, using a specific signature.\n2. **runOperations**: Similar to preapplyOperations but uses a random signature; it executes operations on a blockchain network.\n\nBoth functions interact with the node API, making HTTP requests and processing responses.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/impl/rpc_interface.dart", "chunk_number": 5, "total_chunks": 10}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise and holistic summary of the file 'lib/src/core/rpc/impl/rpc_interface.dart':\n\n**Summary:** This Dart file provides asynchronous functions for interacting with a Tezos RPC Node API, allowing for data retrieval and operation management.\n\n**Functions:**\n\n1. Data Retrieval:\n\t* `chainId`: Retrieves chain ID by blockchain name.\n\t* `protocol`: Retrieves protocol of a specific blockchain and level.\n\t* `counter`: Retrieves counter value for a given source in a specified blockchain and level.\n\t* `pendingOperations`, `injectOperation`, `forgeOperations`: Interact with the API to retrieve or manage pending operations.\n2. Operation Management:\n\t* `preapplyOperations` and `runOperations`: Make HTTP requests to pre-apply or execute operations on a blockchain network.\n3. Contract Information:\n\t* `getManagerKey`, `getBalance`, `getContract`: Retrieve information about a smart contract's address, balance, and complete status.\n4. Entry Points:\n\t* `getContractEntrypoints` and `getContractEntrypointType`: Return entry point data for a given contract address.\n\n**Overall:** This file provides essential functionality for interacting with a Tezos RPC Node API, enabling data retrieval, operation management, and smart contract information access."}
{"code": "    log.info('request for managerKey [ chain:$chain, level:$level]');\n    var response = await httpClient.get(paths.managerKey(address: address, chain: chain, level: level));\n\n    return response.data;\n  }\n\n  /// Returns the balance of [address] in the chain defined by [chain] and [level]\n  Future<int> balance(String address, [chain = 'main', level = 'head']) async {\n    log.info('request for balance [ chain:$chain, level:$level]');\n    var response = await httpClient.get(paths.balance(chain: chain, level: level, address: address));\n\n    return int.parse(response.data['balance']);\n  }\n\n  /// Returns the complete status of the contract whom address is [address]\n  Future<Map<String, dynamic>> getContract(String address, [chain = 'main', level = 'head']) async {\n    log.info('request for contract : $address');\n\n    var response = await httpClient.get(paths.contract(chain: chain, level: level, contractAddress: address));\n\n    return response.data;\n  }\n", "explanation": "Here is a concise summary:\n\n**Functionality Summary**\n\nThis block contains three functions that make GET requests using an `httpClient`:\n\n1. **getManagerKey**: Retrieves manager key for a given address on specified chain and level.\n2. **getBalance**: Returns balance of an address in a specific chain and level.\n3. **getContract**: Fetches complete status of a contract with the given address.\n\nEach function logs an info message before making the request, indicating its purpose.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/impl/rpc_interface.dart", "chunk_number": 6, "total_chunks": 10}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise and holistic summary of the file 'lib/src/core/rpc/impl/rpc_interface.dart':\n\n**Summary:** This Dart file provides asynchronous functions for interacting with a Tezos RPC Node API, allowing for data retrieval and operation management.\n\n**Functions:**\n\n1. Data Retrieval:\n\t* `chainId`: Retrieves chain ID by blockchain name.\n\t* `protocol`: Retrieves protocol of a specific blockchain and level.\n\t* `counter`: Retrieves counter value for a given source in a specified blockchain and level.\n\t* `pendingOperations`, `injectOperation`, `forgeOperations`: Interact with the API to retrieve or manage pending operations.\n2. Operation Management:\n\t* `preapplyOperations` and `runOperations`: Make HTTP requests to pre-apply or execute operations on a blockchain network.\n3. Contract Information:\n\t* `getManagerKey`, `getBalance`, `getContract`: Retrieve information about a smart contract's address, balance, and complete status.\n4. Entry Points:\n\t* `getContractEntrypoints` and `getContractEntrypointType`: Return entry point data for a given contract address.\n\n**Overall:** This file provides essential functionality for interacting with a Tezos RPC Node API, enabling data retrieval, operation management, and smart contract information access."}
{"code": "  /// Returns a map containing the entrypoints and their types of a contract defined by [address]\n  Future<Map<String, dynamic>> getContractEntrypoints(String address, [chain = 'main', level = 'head']) async {\n    log.info('request for contract entrypoints : $address');\n\n    return memo1<String, Future<Map<String, dynamic>>>((String address) async {\n      var response = await httpClient.get(paths.contractEntrypoints(\n        chain: chain,\n        level: level,\n        contractAddress: address,\n      ));\n\n      return response.data['entrypoints'];\n    })(address);\n  }\n\n  /// Returns the type of [entrypoint] of the contract defined by [address]\n  Future<Map<String, dynamic>> getContractEntrypointType({\n    required String address,\n    required String entrypoint,\n    chain = 'main',\n    level = 'head',\n  }) async {\n    log.info('request for contract : $address, entrypoint: $entrypoint');\n\n    return memo2<String, String, Future<Map<String, dynamic>>>((String address, String entrypoint) async {", "explanation": "Here is a concise summary:\n\nThis block provides two functions to retrieve information about a smart contract's entrypoints.\n\n* `getContractEntrypoints`: Returns a map of entrypoints and their types for a given contract address.\n* `getContractEntrypointType`: Returns the type of a specific entrypoint for a given contract address.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/impl/rpc_interface.dart", "chunk_number": 7, "total_chunks": 10}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise and holistic summary of the file 'lib/src/core/rpc/impl/rpc_interface.dart':\n\n**Summary:** This Dart file provides asynchronous functions for interacting with a Tezos RPC Node API, allowing for data retrieval and operation management.\n\n**Functions:**\n\n1. Data Retrieval:\n\t* `chainId`: Retrieves chain ID by blockchain name.\n\t* `protocol`: Retrieves protocol of a specific blockchain and level.\n\t* `counter`: Retrieves counter value for a given source in a specified blockchain and level.\n\t* `pendingOperations`, `injectOperation`, `forgeOperations`: Interact with the API to retrieve or manage pending operations.\n2. Operation Management:\n\t* `preapplyOperations` and `runOperations`: Make HTTP requests to pre-apply or execute operations on a blockchain network.\n3. Contract Information:\n\t* `getManagerKey`, `getBalance`, `getContract`: Retrieve information about a smart contract's address, balance, and complete status.\n4. Entry Points:\n\t* `getContractEntrypoints` and `getContractEntrypointType`: Return entry point data for a given contract address.\n\n**Overall:** This file provides essential functionality for interacting with a Tezos RPC Node API, enabling data retrieval, operation management, and smart contract information access."}
{"code": "      var response = await httpClient.get(paths.contractEntrypoint(\n        chain: chain,\n        level: level,\n        contractAddress: address,\n        entrypoint: entrypoint,\n      ));\n\n      return response.data;\n    })(address, entrypoint);\n  }\n\n  /// Returns the applied transactions hashes in [chain] and [level]\n  Future<List<String>> transactionsOperationHashes({\n    required String level,\n    chain = 'main',\n  }) async {\n    final response = await httpClient.get(paths.operationHashes(\n      chain: chain,\n      level: level,\n      offset: 3,\n    ));\n    return response.data.cast<String>().toList();\n  }\n\n  /// Waits for [operationId] to be included in a block\n  ///\n  /// Throws a [TezartNodeErrorTypes.monitoringTimedOut] if the operation is not included in the next two blocks\n  // TODO: wait for multiple blocks\n  Future<String> monitorOperation({\n    required String operationId,\n    chain = 'main',\n    level = 'head',\n  }) async {", "explanation": "Here is a concise summary of each block:\n\n**Block 1**\n\n* Purpose: Fetch contract entrypoint data from a server\n* Functionality: Sends GET request to retrieve contract data and returns response data\n\n**Block 2**\n\n* Purpose: Retrieve operation hashes in a chain and level\n* Functionality: Sends GET request to retrieve operation hashes and returns them as a list of strings\n\n**Block 3**\n\n* Purpose: Wait for an operation to be included in a block\n* Functionality: Waits for specified operation to be included in a block, throwing an error if it's not included within two blocks.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/impl/rpc_interface.dart", "chunk_number": 8, "total_chunks": 10}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise and holistic summary of the file 'lib/src/core/rpc/impl/rpc_interface.dart':\n\n**Summary:** This Dart file provides asynchronous functions for interacting with a Tezos RPC Node API, allowing for data retrieval and operation management.\n\n**Functions:**\n\n1. Data Retrieval:\n\t* `chainId`: Retrieves chain ID by blockchain name.\n\t* `protocol`: Retrieves protocol of a specific blockchain and level.\n\t* `counter`: Retrieves counter value for a given source in a specified blockchain and level.\n\t* `pendingOperations`, `injectOperation`, `forgeOperations`: Interact with the API to retrieve or manage pending operations.\n2. Operation Management:\n\t* `preapplyOperations` and `runOperations`: Make HTTP requests to pre-apply or execute operations on a blockchain network.\n3. Contract Information:\n\t* `getManagerKey`, `getBalance`, `getContract`: Retrieve information about a smart contract's address, balance, and complete status.\n4. Entry Points:\n\t* `getContractEntrypoints` and `getContractEntrypointType`: Return entry point data for a given contract address.\n\n**Overall:** This file provides essential functionality for interacting with a Tezos RPC Node API, enabling data retrieval, operation management, and smart contract information access."}
{"code": "    return _operationsMonitor.monitor(chain: chain, level: level, operationId: operationId);\n  }\n\n  OperationsMonitor get _operationsMonitor => memo0(() => OperationsMonitor(this))();\n\n  /// Returns the block hash of [chain] and [level]\n  Future<Map<String, dynamic>> block({required String chain, required String level}) async {\n    final response = await httpClient.get(paths.block(chain: chain, level: level));\n\n    return response.data;\n  }\n\n  /// Returns the constants of the chain defined by [chain] and [level]\n  Future<Map<String, dynamic>> constants([chain = 'main', level = 'head']) async {\n    return memo2<String, String, Future<Map<String, dynamic>>>((String chain, String level) async {\n      log.info('request to constants');\n      final response = await httpClient.get(paths.constants(chain: chain, level: level));\n\n      return response.data;\n    })(chain, level);\n  }\n\n  /// Packs [data] using [type]\n  ///\n  /// - [data] is the data to pack, it must be in Micheline\n  /// - [type] is the type of [data]", "explanation": "Here is a concise summary:\n\nThis block contains methods for interacting with blockchain data.\n\n* `_operationsMonitor` returns an instance of `OperationsMonitor`.\n* `block`: Retrieves the block hash from a specified chain and level.\n* `constants`: Retrieves constants from a specified chain and level.\n* `pack`: Packs Micheline data using a specified type.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/impl/rpc_interface.dart", "chunk_number": 9, "total_chunks": 10}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise and holistic summary of the file 'lib/src/core/rpc/impl/rpc_interface.dart':\n\n**Summary:** This Dart file provides asynchronous functions for interacting with a Tezos RPC Node API, allowing for data retrieval and operation management.\n\n**Functions:**\n\n1. Data Retrieval:\n\t* `chainId`: Retrieves chain ID by blockchain name.\n\t* `protocol`: Retrieves protocol of a specific blockchain and level.\n\t* `counter`: Retrieves counter value for a given source in a specified blockchain and level.\n\t* `pendingOperations`, `injectOperation`, `forgeOperations`: Interact with the API to retrieve or manage pending operations.\n2. Operation Management:\n\t* `preapplyOperations` and `runOperations`: Make HTTP requests to pre-apply or execute operations on a blockchain network.\n3. Contract Information:\n\t* `getManagerKey`, `getBalance`, `getContract`: Retrieve information about a smart contract's address, balance, and complete status.\n4. Entry Points:\n\t* `getContractEntrypoints` and `getContractEntrypointType`: Return entry point data for a given contract address.\n\n**Overall:** This file provides essential functionality for interacting with a Tezos RPC Node API, enabling data retrieval, operation management, and smart contract information access."}
{"code": "  Future<String> pack({\n    required dynamic data,\n    required Map<String, dynamic> type,\n    chain = 'main',\n    level = 'head',\n  }) async {\n    final content = {\n      'data': data,\n      'type': type,\n    };\n    final response = await httpClient.post(paths.pack(chain: chain, level: level), data: content);\n\n    return response.data['packed'];\n  }\n\n  /// Returns the value of a key in a big map\n  ///\n  /// - [id] is the id of the big map\n  /// - [encodedScriptExpression] is the encoded version of the key we are trying to fetch\n  Future bigMapValue({\n    required String id,\n    required String encodedScriptExpression,\n    chain = 'main',\n    level = 'head',\n  }) async {\n    final response = await httpClient.get(paths.bigMapValue(\n      level: level,\n      chain: chain,\n      id: id,\n      encodedScriptExpression: encodedScriptExpression,\n    ));\n\n    return response.data;\n  }\n}\n", "explanation": "Here is a concise summary:\n\n**Two asynchronous functions:**\n\n1. `pack`: Packs data into a JSON object using an HTTP POST request.\n2. `bigMapValue`: Retrieves a value from a large map using an encoded key and an HTTP GET request.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/impl/rpc_interface.dart", "chunk_number": 10, "total_chunks": 10}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise and holistic summary of the file 'lib/src/core/rpc/impl/rpc_interface.dart':\n\n**Summary:** This Dart file provides asynchronous functions for interacting with a Tezos RPC Node API, allowing for data retrieval and operation management.\n\n**Functions:**\n\n1. Data Retrieval:\n\t* `chainId`: Retrieves chain ID by blockchain name.\n\t* `protocol`: Retrieves protocol of a specific blockchain and level.\n\t* `counter`: Retrieves counter value for a given source in a specified blockchain and level.\n\t* `pendingOperations`, `injectOperation`, `forgeOperations`: Interact with the API to retrieve or manage pending operations.\n2. Operation Management:\n\t* `preapplyOperations` and `runOperations`: Make HTTP requests to pre-apply or execute operations on a blockchain network.\n3. Contract Information:\n\t* `getManagerKey`, `getBalance`, `getContract`: Retrieve information about a smart contract's address, balance, and complete status.\n4. Entry Points:\n\t* `getContractEntrypoints` and `getContractEntrypointType`: Return entry point data for a given contract address.\n\n**Overall:** This file provides essential functionality for interacting with a Tezos RPC Node API, enabling data retrieval, operation management, and smart contract information access."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nfinal pendingOperations = (String chain) => '${_chainPath(chain)}/mempool/pending_operations';\nfinal branch = ({required String chain, required String level}) => '${_levelPath(chain: chain, level: level)}/hash';\nfinal block = ({required String chain, required String level}) => _levelPath(level: level, chain: chain);\nfinal chainId = (String chain) => '${_chainPath(chain)}/chain_id';\n\nfinal counter = ({required String chain, required String level, required String source}) =>\n    '${_levelPath(chain: chain, level: level)}/context/contracts/$source/counter';\n\nfinal protocol =\n    ({required String chain, required String level}) => '${_levelPath(chain: chain, level: level)}/metadata';\n\nfinal forgeOperations = ({required String chain, required String level}) =>\n    '${_levelPath(chain: chain, level: level)}/helpers/forge/operations';\n\nfinal runOperations = ({required String chain, required String level}) =>", "explanation": "Here is a concise summary:\n\n**Purpose:** Define string constants for blockchain-related URLs.\n\n**Functionality:** A set of functions that return URL strings with placeholders for various blockchain parameters (chain, level, source). These URLs seem to be related to pending operations, branch metadata, and other blockchain-specific data.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/impl/rpc_interface_paths.dart", "chunk_number": 1, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary of the file 'lib/src/core/rpc/impl/rpc_interface_paths.dart':\n\n**Purpose:** Define string constants for blockchain-related URLs.\n\n**Functionality:** Generate URL paths by concatenating input parameters (chain, level, contractAddress, etc.) for various blockchain resources and operations."}
{"code": "    '${_levelPath(chain: chain, level: level)}/helpers/scripts/run_operation';\n\nfinal preapplyOperations = ({required String chain, required String level}) =>\n    '${_levelPath(chain: chain, level: level)}/helpers/preapply/operations';\n\nfinal injectOperation = (String chain) => 'injection/operation?chain=$chain';\n\nfinal balance = ({required String chain, required String level, required String address}) =>\n    '${_levelPath(chain: chain, level: level)}/context/contracts/$address';\n\nfinal managerKey = ({required String chain, required String level, required String address}) =>\n    '${_levelPath(chain: chain, level: level)}/context/contracts/$address/manager_key';\n\nfinal monitor = (String chain) => 'monitor/heads/$chain';\nfinal operationHashes = ({\n  required String chain,\n  required String level,\n  int? offset,\n}) =>\n    '${_levelPath(chain: chain, level: level)}/operation_hashes/${offset ?? ''}';\n\nfinal constants =", "explanation": "Here is a concise summary:\n\nThis block defines various string functions that generate paths to different API endpoints for blockchain-related operations. The functions are used to build URLs by concatenating strings with variable inputs such as chain, level, address, etc.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/impl/rpc_interface_paths.dart", "chunk_number": 2, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary of the file 'lib/src/core/rpc/impl/rpc_interface_paths.dart':\n\n**Purpose:** Define string constants for blockchain-related URLs.\n\n**Functionality:** Generate URL paths by concatenating input parameters (chain, level, contractAddress, etc.) for various blockchain resources and operations."}
{"code": "    ({required String chain, required String level}) => '${_levelPath(chain: chain, level: level)}/context/constants';\n\nfinal contract = ({\n  required String chain,\n  required String level,\n  required String contractAddress,\n}) =>\n    '${_levelPath(chain: chain, level: level)}/context/contracts/$contractAddress';\n\nfinal contractEntrypoints = ({\n  required String chain,\n  required String level,\n  required String contractAddress,\n}) =>\n    '${contract(chain: chain, level: level, contractAddress: contractAddress)}/entrypoints';\n\nfinal contractEntrypoint = ({\n  required String chain,\n  required String level,\n  required String contractAddress,\n  required String entrypoint,\n}) =>\n    '${contractEntrypoints(chain: chain, level: level, contractAddress: contractAddress)}/$entrypoint';\n\nfinal pack = ({required String level, required String chain}) =>\n    '${_levelPath(level: level, chain: chain)}/helpers/scripts/pack_data';\n\nfinal bigMapValue = ({\n  required String level,\n  required String chain,\n  required String id,", "explanation": "Here is a concise summary:\n\nThis block defines several functions that generate URLs for various blockchain-related resources, including:\n\n* A base path for contracts (_levelPath)\n* Contract URLs with specific contract addresses (contract)\n* Entry points within contracts (contractEntrypoints and contractEntrypoint)\n* Scripts to pack data (pack)\n* Big Map value URLs (bigMapValue)\n\nEach function takes required string parameters such as chain, level, and contractAddress.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/impl/rpc_interface_paths.dart", "chunk_number": 3, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary of the file 'lib/src/core/rpc/impl/rpc_interface_paths.dart':\n\n**Purpose:** Define string constants for blockchain-related URLs.\n\n**Functionality:** Generate URL paths by concatenating input parameters (chain, level, contractAddress, etc.) for various blockchain resources and operations."}
{"code": "  required String encodedScriptExpression,\n}) =>\n    '${_levelPath(level: level, chain: chain)}/context/big_maps/$id/$encodedScriptExpression';\n\nfinal _chainPath = (String chain) => 'chains/$chain';\nfinal _levelPath = ({required String level, required String chain}) => '${_chainPath(chain)}/blocks/$level';\n", "explanation": "Here is a summary of the purpose and functionality:\n\n**Block Summary**\n\nThis block generates a URL path string by combining various input parameters (level, chain, id, and encoded script expression). It appears to be related to querying or retrieving data from blockchain big maps.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/impl/rpc_interface_paths.dart", "chunk_number": 4, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary of the file 'lib/src/core/rpc/impl/rpc_interface_paths.dart':\n\n**Purpose:** Define string constants for blockchain-related URLs.\n\n**Functionality:** Generate URL paths by concatenating input parameters (chain, level, contractAddress, etc.) for various blockchain resources and operations."}
{"code": "import 'dart:io';\n\nimport 'package:dio/dio.dart' as http_client;\nimport 'package:pretty_dio_logger/pretty_dio_logger.dart';\nimport 'package:logging/logging.dart';\nimport 'package:retry/retry.dart';\n\nimport 'tezart_http_error.dart';\n\nclass TezartHttpClient {\n  final log = Logger('TezartHttpClient');\n  late http_client.Dio client;\n  final String url;\n\n  // Add client as optional parameter for testing\n  TezartHttpClient(this.url, {http_client.Dio? client}) {\n    // ensure that the url ends with '/' (double / is ok)\n    final baseUrl = '$url/';\n\n    if (client != null) {\n      this.client = client;\n      this.client.options.baseUrl = baseUrl;\n      return;\n    }\n\n    final options = http_client.BaseOptions(baseUrl: baseUrl, contentType: 'application/json');\n    this.client = http_client.Dio(options);\n    this.client.interceptors.add(PrettyDioLogger(\n          logPrint: log.finest,\n          requestHeader: true,\n          requestBody: true,\n          responseBody: true,\n          responseHeader: false,", "explanation": "Here is a concise summary:\n\n**Purpose:** A custom HTTP client class (`TezartHttpClient`) for making API requests.\n\n**Functionality:** Handles API requests with logging, error handling, and retry capabilities using DIO (Dart's HTTP client) and other libraries.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/impl/tezart_http_client.dart", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'lib/src/core/rpc/impl/tezart_http_client.dart':\n\n**Purpose:** A custom HTTP client (`TezartHttpClient`) for making API requests with retry capabilities and error handling.\n\n**Functionality:** Handles API requests using DIO, logging errors, and retrying on socket exceptions. Provides `post`, `get`, and `getStream` functions, as well as error handling mechanisms (_retryOnSocketException_ and _handleClientError_) to ensure reliable HTTP interactions."}
{"code": "          compact: false,\n        ));\n  }\n\n  Future<http_client.Response> post(String path, {dynamic data}) {\n    log.info('request to post to path: $path');\n    return _retryOnSocketException(\n      () => _handleClientError(\n        () => client.post(path, data: data),\n      ),\n    );\n  }\n\n  Future<http_client.Response> get(String path, {Map<String, dynamic>? params}) {\n    log.info('request to get from path: $path');\n\n    return _retryOnSocketException(\n      () => _handleClientError(\n        () => client.get(path, queryParameters: params),\n      ),\n    );\n  }\n\n  Future<http_client.Response<http_client.ResponseBody>> getStream(\n    String path, {\n    Map<String, dynamic>? params,\n  }) {\n    return _retryOnSocketException(\n      () => _handleClientError(\n        () => client.get<http_client.ResponseBody>(\n          path,\n          queryParameters: params,\n          options: http_client.Options(\n            responseType: http_client.ResponseType.stream,\n          ), // set responseType to `stream`\n        ),\n      ),", "explanation": "Here is a concise summary:\n\n**Purpose:** Handle HTTP requests using a client.\n\n**Functionality:**\n\n* `post`: Posts data to a specified path.\n* `get`: Retrieves data from a specified path, with optional query parameters.\n* `getStream`: Retrieves a stream response from a specified path, with optional query parameters.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/impl/tezart_http_client.dart", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'lib/src/core/rpc/impl/tezart_http_client.dart':\n\n**Purpose:** A custom HTTP client (`TezartHttpClient`) for making API requests with retry capabilities and error handling.\n\n**Functionality:** Handles API requests using DIO, logging errors, and retrying on socket exceptions. Provides `post`, `get`, and `getStream` functions, as well as error handling mechanisms (_retryOnSocketException_ and _handleClientError_) to ensure reliable HTTP interactions."}
{"code": "    );\n  }\n\n  Future<T> _retryOnSocketException<T>(Future<T> Function() func) {\n    final r = RetryOptions(maxAttempts: 3);\n\n    return r.retry<T>(\n      func,\n      retryIf: (e) {\n        return e is TezartHttpError && e.originalException is SocketException;\n      },\n    );\n  }\n\n  Future<T> _handleClientError<T>(Function func) async {\n    try {\n      return await func();\n    } on http_client.DioError catch (e) {\n      log.severe('Error in http call', e);\n      throw TezartHttpError(e);\n    }\n  }\n}\n", "explanation": "Here is a summary of the purpose and functionality of this block:\n\n**Purpose:** Provides two functions for handling errors in HTTP requests.\n\n**Functionality:**\n\n1. `_retryOnSocketException`: Retries an HTTP request up to 3 times if it fails due to a socket exception.\n2. `_handleClientError`: Wraps an HTTP function call, catches DioError exceptions, logs the error, and throws a TezartHttpError exception.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/impl/tezart_http_client.dart", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'lib/src/core/rpc/impl/tezart_http_client.dart':\n\n**Purpose:** A custom HTTP client (`TezartHttpClient`) for making API requests with retry capabilities and error handling.\n\n**Functionality:** Handles API requests using DIO, logging errors, and retrying on socket exceptions. Provides `post`, `get`, and `getStream` functions, as well as error handling mechanisms (_retryOnSocketException_ and _handleClientError_) to ensure reliable HTTP interactions."}
{"code": "import 'package:dio/dio.dart' as http_client;\nimport 'package:tezart/src/common/exceptions/common_exception.dart';\nimport 'package:tezart/src/common/utils/enum_util.dart';\nimport 'package:tezart/src/core/client/tezart_client.dart';\n\nenum TezartHttpErrorTypes {\n  connectTimeout,\n  receiveTimeout,\n  response,\n  cancel,\n  unhandled,\n}\n\n// Wrapper around DioError\n// complete missing methods if needed\nclass TezartHttpError extends CommonException {\n  final http_client.DioError clientError;\n  final staticErrorsMessages = {\n    TezartHttpErrorTypes.connectTimeout: 'Opening connection timed out',\n    TezartHttpErrorTypes.receiveTimeout: 'Receiving connection timed out',\n    TezartHttpErrorTypes.cancel: 'The request has been cancelled',\n    TezartHttpErrorTypes.unhandled: 'Network Error',\n  };\n  final errorTypesMapping = {\n    http_client.DioErrorType.connectTimeout: TezartHttpErrorTypes.connectTimeout,\n    http_client.DioErrorType.receiveTimeout: TezartHttpErrorTypes.receiveTimeout,", "explanation": "**Summary**\n\nThis block imports necessary packages and defines an error handling system for HTTP requests using Dio library.\n\nIt provides:\n\n* An enum `TezartHttpErrorTypes` to categorize HTTP errors\n* A class `TezartHttpError` that extends a custom exception, wrapping DioError with additional error types and messages.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/impl/tezart_http_error.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'lib/src/core/rpc/impl/tezart_http_error.dart':\n\n**Summary:** This file provides an error handling system for HTTP requests using the Dio library, mapping Dio errors to custom `TezartHttpErrorTypes` and wrapping them in a `TezartHttpError` class."}
{"code": "    http_client.DioErrorType.response: TezartHttpErrorTypes.response,\n    http_client.DioErrorType.cancel: TezartHttpErrorTypes.cancel,\n  };\n\n  TezartHttpError(this.clientError);\n\n  dynamic get responseBody => _response?.data;\n  int? get statusCode => _response?.statusCode;\n  TezartHttpErrorTypes get type {\n    return errorTypesMapping[clientError.type] ?? TezartHttpErrorTypes.unhandled;\n  }\n\n  http_client.Response? get _response => clientError.response;\n\n  @override\n  String get key => EnumUtil.enumToString(type);\n  @override\n  String get message => _response?.statusMessage ?? staticErrorsMessages[type]!;\n  @override\n  http_client.DioError get originalException => clientError;\n}\n\nFuture<T> catchHttpError<T>(Future<T> Function() func, {void Function(TezartHttpError)? onError}) async {\n  try {\n    return await func();\n  } on TezartHttpError catch (e) {\n    if (onError != null) onError(e);\n    throw TezartNodeError.fromHttpError(e);\n  }\n}\n", "explanation": "Here is a concise summary of the purpose and functionality:\n\n**Block Purpose:** Error handling for HTTP requests using Dio library.\n\n**Functionality:**\n\n* Maps Dio error types to custom error types (TezartHttpErrorTypes).\n* Provides getters for response body, status code, and error type.\n* Converts original Dio exception to TezartNodeError.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/impl/tezart_http_error.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'lib/src/core/rpc/impl/tezart_http_error.dart':\n\n**Summary:** This file provides an error handling system for HTTP requests using the Dio library, mapping Dio errors to custom `TezartHttpErrorTypes` and wrapping them in a `TezartHttpError` class."}
{"code": "/// A library that handles the calls to the RPC node\n///\n/// Exposes:\n/// - [RpcInterface]\n/// - [TezartHttpError]\nlibrary rpc_interface;\n\nexport 'impl/rpc_interface.dart';\nexport 'impl/tezart_http_error.dart';\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Handles RPC (Remote Procedure Call) calls to an external node.\n\n**Functionality:** Exposes two interfaces for interacting with the node: `RpcInterface` and `TezartHttpError`.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/core/rpc/rpc_interface.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'lib/src/core/rpc/rpc_interface.dart':\n\n**Purpose:** Handles RPC calls to an external node.\n\n**Summary:** Provides two interfaces (`RpcInterface` and `TezartHttpError`) for interacting with an external node through Remote Procedure Calls (RPC)."}
{"code": "/// Exports low-level cryptographic operations needed to sign Tezos\n/// transactions.\nlibrary crypto;\n\nexport 'impl/encode_decode.dart';\nexport 'impl/encrypted_secret_key_to_seed.dart';\nexport 'impl/derivator.dart';\nexport 'impl/digest.dart';\nexport 'impl/mnemonic.dart';\nexport 'impl/external_crypto_wrapper.dart';\nexport 'impl/crypto_error.dart';\nexport 'impl/secret_key_seed_conversion.dart';\nexport 'impl/prefixes.dart';\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Provides low-level cryptographic operations for signing Tezos transactions.\n\n**Functionality:** Exports various implementations of cryptographic functions, including encoding, decoding, encryption, hashing, and error handling.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/crypto/crypto.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise and holistic summary:\n\n**lib/src/crypto/crypto.dart**\n\nProvides low-level cryptographic operations for signing Tezos transactions, exporting functions for encoding, decryption, encryption, hashing, and error handling."}
{"code": "import 'package:tezart/src/common/exceptions/common_exception.dart';\nimport 'package:tezart/src/common/utils/enum_util.dart';\n\n/// Exhaustive list of cryptographic error types.\nenum CryptoErrorTypes {\n  /// Prefix not found error.\n  ///\n  /// Happens when :\n  /// - trying to encode with an unknown prefix.\n  /// - trying to ignore an unknown prefix.\n  prefixNotFound,\n\n  /// Invalid seed bytes length\n  ///\n  /// Happens when the seed bytes length is != 32.\n  seedBytesLengthError,\n\n  /// Invalid (string) seed length.\n  ///\n  /// Happens when the seed length is != 54.\n  seedLengthError,\n\n  /// Invalid (string) secret key length.\n  ///\n  /// Happens when the secret key length is != 98.\n  secretKeyLengthError,\n\n  /// Invalid (string) encrypted secret key length.\n  ///\n  /// Happens when the encrypted secret key length is != 88.\n  encryptedSecretKeyLengthError,\n\n  /// Invalid mnemonic.\n  ///\n  /// Happens when :\n  /// - the mnemonic is short.\n  /// - the mnemonic contains an unknown word.\n  invalidMnemonic,\n", "explanation": "**Summary:**\n\nThis block defines a custom enum `CryptoErrorTypes` that lists exhaustive error types for cryptographic operations, such as prefix not found, seed bytes/length errors, secret key length errors, encrypted secret key length errors, and invalid mnemonic.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/crypto/impl/crypto_error.dart", "chunk_number": 1, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'lib/src/crypto/impl/crypto_error.dart':\n\nThis Dart code defines a custom enum `CryptoErrorTypes` with exhaustive error types for cryptographic operations, and a `CryptoError` class that extends an exception, providing a way to translate error messages. The `catchUnhandledErrors` function catches unhandled errors and re-throws them as `CryptoError` instances."}
{"code": "  /// Invalid checksum.\n  ///\n  /// Happens when :\n  /// - the checksum of a secret key is invalid.\n  /// - the checksum of a seed is invalid.\n  invalidChecksum,\n\n  /// Hexadecimal data length is odd.\n  ///\n  /// Happens when the length of an hexadecimal representation of a list of bytes is odd.\n  invalidHexDataLength,\n\n  /// Invalid hexadecimal string.\n  ///\n  /// Happens when the hexadecimal string contains invalid characters (`[a-fA-F0-9]`).\n  invalidHex,\n\n  /// Unhandled error.\n  unhandled,\n}\n\n/// Exception thrown when an error occurs during a cryptographic operation.\n///\n/// You can translate the error messages using [key] or [type].\n///\n/// ```dart\n/// try {\n///   aCryptoOperation();\n/// } on CryptoError catch (e) {\n///   print(e.message); // 'Prefix not found'\n///   print(e.key); // 'prefixNotFound'\n/// }\nclass CryptoError extends CommonException {\n  final CryptoErrorTypes _inputType;\n  final String? _inputMessage;\n  final dynamic cause;\n\n  final staticErrorsMessages = {", "explanation": "Here is a concise summary:\n\nThis block defines an enum (`CryptoErrorTypes`) with error types for cryptographic operations, including invalid checksum, hexadecimal data length, and unhandled errors. It also defines a `CryptoError` class that extends another exception class, providing a way to translate error messages.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/crypto/impl/crypto_error.dart", "chunk_number": 2, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'lib/src/crypto/impl/crypto_error.dart':\n\nThis Dart code defines a custom enum `CryptoErrorTypes` with exhaustive error types for cryptographic operations, and a `CryptoError` class that extends an exception, providing a way to translate error messages. The `catchUnhandledErrors` function catches unhandled errors and re-throws them as `CryptoError` instances."}
{"code": "    CryptoErrorTypes.prefixNotFound: 'Prefix not found',\n    CryptoErrorTypes.seedBytesLengthError: 'The seed must be 32 bytes long',\n    CryptoErrorTypes.seedLengthError: 'The seed must be 54 characters long',\n    CryptoErrorTypes.secretKeyLengthError: 'The secret key must 98 characters long',\n    CryptoErrorTypes.invalidMnemonic: 'The mnemonic is invalid',\n    CryptoErrorTypes.invalidChecksum: 'Invalid checksum',\n    CryptoErrorTypes.invalidHexDataLength: \"Hexadecimal data's length must be even\",\n    CryptoErrorTypes.invalidHex: 'Invalid hexadecimal',\n  };\n  final dynamicErrorMessages = {\n    CryptoErrorTypes.unhandled: (dynamic e) => 'Unhandled error: $e',\n  };\n\n  /// Default constructor.\n  ///\n  /// - [type] is required.\n  /// - [message] is optional. If provided, it will be used.\n  ///     If not, it will use `staticErrorMessages[type]` or `dynamicErrorMessages[type]` (in this priority order).\n  /// - [cause] is optional, it represents the error that caused this.", "explanation": "Here is a concise summary:\n\n**Purpose:** Define error types for cryptographic operations.\n\n**Functionality:** Provide static error messages for specific errors and a dynamic error message function for unhandled errors. Allow creation of CryptoError instances with optional type, message, and cause.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/crypto/impl/crypto_error.dart", "chunk_number": 3, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'lib/src/crypto/impl/crypto_error.dart':\n\nThis Dart code defines a custom enum `CryptoErrorTypes` with exhaustive error types for cryptographic operations, and a `CryptoError` class that extends an exception, providing a way to translate error messages. The `catchUnhandledErrors` function catches unhandled errors and re-throws them as `CryptoError` instances."}
{"code": "  CryptoError({required CryptoErrorTypes type, String? message, this.cause})\n      : _inputType = type,\n        _inputMessage = message;\n\n  /// Type of this.\n  CryptoErrorTypes get type => _inputType;\n\n  /// Human readable explanation of this.\n  @override\n  String get message => _inputMessage ?? _computedMessage;\n\n  String get _computedMessage {\n    if (staticErrorsMessages.containsKey(type)) {\n      return staticErrorsMessages[type]!;\n    }\n\n    switch (type) {\n      case CryptoErrorTypes.unhandled:\n        return dynamicErrorMessages[type]!(cause);\n      default:\n        throw UnimplementedError('Unimplemented error type $type');\n    }\n  }\n\n  /// String representation of type.\n  @override\n  String get key => EnumUtil.enumToString(type);\n\n  /// Cause of this, might be null.\n  ///\n  /// It represents the error that caused this.\n  @override\n  dynamic get originalException => cause;\n}\n\nT catchUnhandledErrors<T>(T Function() func) {\n  try {\n    return func();\n  } catch (e) {\n    if (e is CryptoError) {\n      rethrow;\n    }", "explanation": "Here is a concise summary:\n\n**CryptoError class:**\n\n* Represents an error that occurs during cryptographic operations.\n* Has properties for:\n\t+ `type`: error type (e.g., unhandled, invalid input)\n\t+ `message`: human-readable explanation\n\t+ `key`: string representation of the error type\n\t+ `originalException`: cause of the error (may be null)\n\n**catchUnhandledErrors function:**\n\n* A wrapper around a function to catch and re-throw CryptoError instances.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/crypto/impl/crypto_error.dart", "chunk_number": 4, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'lib/src/crypto/impl/crypto_error.dart':\n\nThis Dart code defines a custom enum `CryptoErrorTypes` with exhaustive error types for cryptographic operations, and a `CryptoError` class that extends an exception, providing a way to translate error messages. The `catchUnhandledErrors` function catches unhandled errors and re-throws them as `CryptoError` instances."}
{"code": "    throw CryptoError(type: CryptoErrorTypes.unhandled, cause: e);\n  }\n}\n", "explanation": "**Purpose:** Throw a CryptoError when an unhandled error occurs.\n\n**Functionality:** Re-throw an exception with a specific type (CryptoErrorTypes.unhandled) and attach the original error (e) as the cause.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/crypto/impl/crypto_error.dart", "chunk_number": 5, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'lib/src/crypto/impl/crypto_error.dart':\n\nThis Dart code defines a custom enum `CryptoErrorTypes` with exhaustive error types for cryptographic operations, and a `CryptoError` class that extends an exception, providing a way to translate error messages. The `catchUnhandledErrors` function catches unhandled errors and re-throws them as `CryptoError` instances."}
{"code": "import 'package:pointycastle/export.dart';\nimport 'dart:typed_data';\n\nUint8List deriveBits({\n  required Uint8List passphrase,\n  required Uint8List salt,\n  required int iterationCount,\n  required int keyLength,\n}) {\n  final target = Uint8List(keyLength);\n  final params = Pbkdf2Parameters(salt, iterationCount, keyLength);\n  final derivator = PBKDF2KeyDerivator((HMac(SHA512Digest(), 128)));\n\n  derivator.init(params);\n  derivator.deriveKey(passphrase, 0, target, 0);\n\n  return target;\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Derives a cryptographic key from a passphrase using PBKDF2 (Password-Based Key Derivation Function 2) algorithm.\n\n**Functionality:** Takes a passphrase, salt, iteration count, and key length as inputs and generates a Uint8List of the derived key.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/crypto/impl/derivator.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**Derivator.dart**: Implements PBKDF2 to derive a cryptographic key from a passphrase with customizable salt, iteration count, and key length."}
{"code": "import 'package:pointycastle/digests/blake2b.dart';\nimport 'dart:typed_data';\n\nUint8List hashWithDigestSize({required int size, required Uint8List bytes}) =>\n    Blake2bDigest(digestSize: size ~/ 8).process(bytes);\n", "explanation": "**Summary**\n\nThis block defines a function `hashWithDigestSize` that computes a BLAKE2B hash of input `bytes` using a specified `digestSize`.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/crypto/impl/digest.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/crypto/impl/digest.dart':\n\n**Summary**: This file contains an implementation for computing a BLAKE2B hash with a specified digest size, used for various cryptographic purposes."}
{"code": "import 'dart:typed_data';\nimport 'package:convert/convert.dart' show hex;\nimport 'package:meta/meta.dart';\nimport 'package:collection/collection.dart';\nimport 'package:bs58check/bs58check.dart' as bs58check;\n\nimport 'crypto_error.dart';\nimport 'prefixes.dart';\n\nfinal _prefixesToBytes = {\n  Prefixes.tz1: Uint8List.fromList([6, 161, 159]),\n  Prefixes.tz2: Uint8List.fromList([6, 161, 161]),\n  Prefixes.tz3: Uint8List.fromList([6, 161, 164]),\n  Prefixes.KT: Uint8List.fromList([2, 90, 121]),\n  Prefixes.expr: Uint8List.fromList([13, 44, 64, 27]),\n  Prefixes.edpk: Uint8List.fromList([13, 15, 37, 217]),\n  Prefixes.edsk2: Uint8List.fromList([13, 15, 58, 7]),\n  Prefixes.spsk: Uint8List.fromList([17, 162, 224, 201]),\n  Prefixes.p2sk: Uint8List.fromList([16, 81, 238, 189]),\n  Prefixes.sppk: Uint8List.fromList([3, 254, 226, 86]),\n  Prefixes.p2pk: Uint8List.fromList([3, 178, 139, 127]),\n  Prefixes.edsk: Uint8List.fromList([43, 246, 78, 7]),\n  Prefixes.edesk: Uint8List.fromList([7, 90, 60, 179, 41]),", "explanation": "This block defines a map of network prefixes to their corresponding byte representations, allowing for the conversion of string-based network identifiers to binary data for use in cryptographic operations.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/crypto/impl/encode_decode.dart", "chunk_number": 1, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/crypto/impl/encode_decode.dart':\n\n**Purpose:** Provides utility functions for encoding and decoding binary data using various formats (HEX, Base58) with checksum validation.\n\n**Functionality:**\n\n* Encodes and decodes Uint8List payloads to/from string representations using hexadecimal and Base58 formats.\n* Validates checksums of base58-encoded strings.\n* Handles prefix bytes in predefined prefixes.\n* Offers functions for encoding and decoding without/with prefix considerations."}
{"code": "  Prefixes.edsig: Uint8List.fromList([9, 245, 205, 134, 18]),\n  Prefixes.spsig1: Uint8List.fromList([13, 115, 101, 19, 63]),\n  Prefixes.p2sig: Uint8List.fromList([54, 240, 44, 52]),\n  Prefixes.sig: Uint8List.fromList([4, 130, 43]),\n  Prefixes.Net: Uint8List.fromList([87, 82, 0]),\n  Prefixes.nce: Uint8List.fromList([69, 220, 169]),\n  Prefixes.b: Uint8List.fromList([1, 52]),\n  Prefixes.o: Uint8List.fromList([5, 116]),\n  Prefixes.Lo: Uint8List.fromList([133, 233]),\n  Prefixes.LLo: Uint8List.fromList([29, 159, 109]),\n  Prefixes.P: Uint8List.fromList([2, 170]),\n  Prefixes.Co: Uint8List.fromList([79, 179]),\n  Prefixes.id: Uint8List.fromList([153, 103])\n};\n\nString _encodeBase58(Uint8List payload) => bs58check.encode(payload);\nUint8List _decodeBase58(String string) => bs58check.decode(string);\nbool isChecksumValid(String string) {\n  try {\n    _decodeBase58(string);\n    return true;\n  } on ArgumentError catch (e) {\n    if (e.message == 'Invalid checksum') return false;\n\n    rethrow;\n  }\n}\n", "explanation": "Here is a summary of the code block:\n\n**Purpose:** Implement base58 encoding/decoding and checksum validation for various payloads.\n\n**Functionality:**\n\n* Defines a list of predefined byte arrays (prefixes) in Uint8List format.\n* Provides two functions:\n\t+ `_encodeBase58`: Encodes a Uint8List payload into a string using the bs58check library.\n\t+ `_decodeBase58`: Decodes a string back into a Uint8List payload using the bs58check library.\n\t+ `isChecksumValid`: Checks if a given base58-encoded string has a valid checksum.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/crypto/impl/encode_decode.dart", "chunk_number": 2, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/crypto/impl/encode_decode.dart':\n\n**Purpose:** Provides utility functions for encoding and decoding binary data using various formats (HEX, Base58) with checksum validation.\n\n**Functionality:**\n\n* Encodes and decodes Uint8List payloads to/from string representations using hexadecimal and Base58 formats.\n* Validates checksums of base58-encoded strings.\n* Handles prefix bytes in predefined prefixes.\n* Offers functions for encoding and decoding without/with prefix considerations."}
{"code": "Uint8List hexDecode(String encoded) => Uint8List.fromList(hex.decode(encoded));\nString hexEncode(Uint8List input) => hex.encode(input.toList());\n\n@visibleForTesting\nUint8List prefixBytes(Prefixes prefix) {\n  final prefixBytes = _prefixesToBytes[prefix];\n  if (prefixBytes == null) {\n    throw CryptoError(type: CryptoErrorTypes.prefixNotFound);\n  }\n\n  return _prefixesToBytes[prefix]!;\n}\n\n@visibleForTesting\nUint8List ignorePrefix(Uint8List bytes) {\n  for (final currentPrefix in _prefixesToBytes.keys) {\n    final currentPrefixBytes = prefixBytes(currentPrefix);\n\n    if (ListEquality().equals(bytes.sublist(0, currentPrefixBytes.length), currentPrefixBytes)) {\n      return bytes.sublist(currentPrefixBytes.length);\n    }\n  }\n  throw CryptoError(type: CryptoErrorTypes.prefixNotFound);\n}\n\nString encodeWithPrefix({required Prefixes prefix, required Uint8List bytes}) {\n  final prefixed = Uint8List.fromList(prefixBytes(prefix) + bytes);\n\n  return _encodeBase58(prefixed);\n}\n\nUint8List decodeWithoutPrefix(String str) {", "explanation": "Here is a summary of the purpose and functionality of this block:\n\n**Purpose:** Provides utility functions for encoding and decoding binary data using various formats (HEX, Base58).\n\n**Functionality:**\n\n* `hexDecode` and `hexEncode`: Convert between string and Uint8List representations using hexadecimal format.\n* `prefixBytes` and `ignorePrefix`: Handle prefix bytes in a list of predefined prefixes. Throws error if prefix not found.\n* `encodeWithPrefix`: Encodes input data with a specified prefix using Base58 encoding.\n* `decodeWithoutPrefix`: Decodes a string into Uint8List without considering any prefix.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/crypto/impl/encode_decode.dart", "chunk_number": 3, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/crypto/impl/encode_decode.dart':\n\n**Purpose:** Provides utility functions for encoding and decoding binary data using various formats (HEX, Base58) with checksum validation.\n\n**Functionality:**\n\n* Encodes and decodes Uint8List payloads to/from string representations using hexadecimal and Base58 formats.\n* Validates checksums of base58-encoded strings.\n* Handles prefix bytes in predefined prefixes.\n* Offers functions for encoding and decoding without/with prefix considerations."}
{"code": "  final decoded = _decodeBase58(str);\n\n  return ignorePrefix(decoded);\n}\n", "explanation": "This block decodes a Base58 string into its original form and returns it without a prefix.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/crypto/impl/encode_decode.dart", "chunk_number": 4, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/crypto/impl/encode_decode.dart':\n\n**Purpose:** Provides utility functions for encoding and decoding binary data using various formats (HEX, Base58) with checksum validation.\n\n**Functionality:**\n\n* Encodes and decodes Uint8List payloads to/from string representations using hexadecimal and Base58 formats.\n* Validates checksums of base58-encoded strings.\n* Handles prefix bytes in predefined prefixes.\n* Offers functions for encoding and decoding without/with prefix considerations."}
{"code": "import 'package:pinenacl/x25519.dart';\nimport 'package:pinenacl/ed25519.dart';\nimport 'package:tezart/src/crypto/crypto.dart' as crypto hide Prefixes;\nimport 'package:tezart/src/crypto/crypto.dart' show Prefixes;\n\nString encryptedSecretKeyToSeed({\n  required String encryptedSecretKey,\n  required String passphrase,\n}) {\n  final bytes = crypto.decodeWithoutPrefix(encryptedSecretKey);\n  final salt = bytes.sublist(0, 8);\n  final secretKeyBytes = bytes.sublist(8);\n  const iterationCount = 32768;\n  const keyLength = 32;\n  final nonce = Uint8List(24);\n\n  final encryptionKey = crypto.deriveBits(\n    passphrase: Uint8List.fromList(passphrase.codeUnits),\n    salt: salt,\n    iterationCount: iterationCount,\n    keyLength: keyLength,\n  );\n\n  final secretbox = SecretBox(encryptionKey);\n  final decryptedBytes = secretbox.decrypt(SignedMessage.fromList(signedMessage: secretKeyBytes), nonce: nonce);\n\n  final seed = crypto.encodeWithPrefix(\n    prefix: Prefixes.edsk2,\n    bytes: decryptedBytes,\n  );\n\n  return seed;\n}\n", "explanation": "**Functionality Summary**\n\nThis block is a function named `encryptedSecretKeyToSeed` that:\n\n* Takes an encrypted secret key and passphrase as input\n* Decrypts the secret key using a PBKDF2 (password-based key derivation) process with a specific salt, iteration count, and key length\n* Extracts a seed from the decrypted bytes, prefixing it with `edsk2`\n* Returns the encoded seed string", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/crypto/impl/encrypted_secret_key_to_seed.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n`encryptedSecretKeyToSeed`: Decrypts an encrypted secret key using PBKDF2, extracts a seed, and returns the encoded seed string (`\"edsk2\" + ...`)."}
{"code": "import 'package:bip39/bip39.dart' as bip39;\nimport 'package:meta/meta.dart';\nimport 'package:pinenacl/ed25519.dart';\nimport 'package:tezart/tezart.dart';\n\nimport 'crypto_error.dart';\n\n// These methods are a wrapper of (Nacl|PineNacl|Bouncy Castle) lib methods\nUint8List seedBytesFromMnemonic(String mnemonic, {String passphrase = ''}) {\n  if (!bip39.validateMnemonic(mnemonic)) {\n    throw CryptoError(type: CryptoErrorTypes.invalidMnemonic);\n  }\n\n  final seedBytes = bip39.mnemonicToSeed(mnemonic, passphrase: passphrase);\n\n  return seedBytes.sublist(0, 32);\n}\n\nByteList secretKeyBytesFromSeedBytes(Uint8List seed) => signingKeyFromSeedBytes(seed);\n\nByteList publicKeyBytesFromSeedBytes(Uint8List seed) => signingKeyFromSeedBytes(seed).verifyKey;\n\n@visibleForTesting\nSigningKey signingKeyFromSeedBytes(Uint8List seed) => SigningKey(seed: seed);\n\nByteList signDetached({required Uint8List bytes, required Uint8List secretKey}) {\n  final seed = secretKey.sublist(0, 32); // the seed is the first 32 bytes of the secret key\n", "explanation": "Here is a concise summary:\n\nThis block provides methods for:\n\n* Generating seed bytes from a mnemonic phrase and passphrase\n* Creating a secret key and public key from seed bytes using various libraries (Nacl, PineNacl, Bouncy Castle)\n* Signing data with a secret key, detaching the signature.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/crypto/impl/external_crypto_wrapper.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\nThe \"external_crypto_wrapper.dart\" file provides methods for generating seeds, creating keys, and signing data with various crypto libraries (Nacl, PineNacl, Bouncy Castle), enabling secure signature generation using public keys derived from seed bytes."}
{"code": "  return SigningKey(seed: seed).sign(bytes).sublist(0, 64);\n}\n", "explanation": "**Purpose:** Generates a signature using a signing key.\n\n**Functionality:** Takes input `bytes` and outputs its first 64 bytes signed by a public key generated from a provided `seed`.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/crypto/impl/external_crypto_wrapper.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\nThe \"external_crypto_wrapper.dart\" file provides methods for generating seeds, creating keys, and signing data with various crypto libraries (Nacl, PineNacl, Bouncy Castle), enabling secure signature generation using public keys derived from seed bytes."}
{"code": "import 'package:bip39/bip39.dart' as bip39;\n\nString generateMnemonic({int strength = 256}) => bip39.generateMnemonic(strength: strength);\n", "explanation": "**Summary:**\n\nThis block imports a library (BIP-39) and defines a function `generateMnemonic` that generates a mnemonic phrase based on a specified strength level (defaulting to 256).", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/crypto/impl/mnemonic.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary of the file 'lib/src/crypto/impl/mnemonic.dart':\n\n\"This Dart file imports BIP-39 library and defines `generateMnemonic` function to generate mnemonic phrases based on specified strength levels.\""}
{"code": "// ignore_for_file: constant_identifier_names\n\nenum Prefixes {\n  tz1,\n  tz2,\n  tz3,\n  KT,\n  expr,\n  edpk,\n  edsk2,\n  spsk,\n  p2sk,\n  sppk,\n  p2pk,\n  edsk,\n  edesk,\n  edsig,\n  spsig1,\n  p2sig,\n  sig,\n  Net,\n  nce,\n  b,\n  o,\n  Lo,\n  LLo,\n  P,\n  Co,\n  id,\n}\n", "explanation": "This block defines a set of named constants, specifically prefixes for cryptographic hashes or identities, using an enum (enumeration) in Dart programming language.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/crypto/impl/prefixes.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/crypto/impl/prefixes.dart':\n\n**File Summary:**\nThe `prefixes.dart` file defines a set of named constants for cryptographic hashes or identities using an enum, providing a standardized and readable way to represent various prefixes in Dart code."}
{"code": "import 'dart:typed_data';\n\nimport 'package:tezart/src/crypto/impl/prefixes.dart';\nimport 'package:tezart/tezart.dart';\n\nimport 'crypto_error.dart';\nimport 'encode_decode.dart';\nimport 'external_crypto_wrapper.dart';\n\n// 1. Convert secret key to bytes\n// 2. Cut first 4 bytes representing the prefix\n// 3. Take first 32 bytes representing the secret key\n// 4. encode the result using edsk2 prefix\n// returns the seed of the secret key\nString secretKeyToSeed(String secretKey) {\n  const seedPrefix = Prefixes.edsk2;\n  final bytes = Uint8List.fromList(decodeWithoutPrefix(secretKey).take(32).toList());\n\n  return encodeWithPrefix(\n    prefix: seedPrefix,\n    bytes: bytes,\n  );\n}\n\nString seedToSecretKey(String seed) {\n  const secretKeyPrefix = Prefixes.edsk;\n\n  final seedBytes = decodeWithoutPrefix(seed);\n  if (seedBytes.length != 32) {\n    throw CryptoError(type: CryptoErrorTypes.seedBytesLengthError);\n  }\n\n  final secretKey = secretKeyBytesFromSeedBytes(seedBytes);\n\n  return encodeWithPrefix(\n    prefix: secretKeyPrefix,", "explanation": "Here is a summary of the purpose and functionality of this block:\n\n**Purpose:** Convert between Tezos secret keys and seeds.\n\n**Functionality:**\n\n1. `secretKeyToSeed`: Converts a secret key to its corresponding seed.\n2. `seedToSecretKey`: Converts a seed back to its original secret key.\n\nBoth functions perform encoding and decoding operations using custom prefixes and error handling.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/crypto/impl/secret_key_seed_conversion.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'lib/src/crypto/impl/secret_key_seed_conversion.dart':\n\nThis file provides two functions: `secretKeyToSeed` and `seedToSecretKey`, for converting between Tezos secret keys and seeds, utilizing custom prefixes and error handling."}
{"code": "    bytes: Uint8List.fromList(secretKey.toList()),\n  );\n}\n", "explanation": "This block converts a secret key (assumed to be a string) into a byte list, using Dart's `Uint8List` class.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/crypto/impl/secret_key_seed_conversion.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'lib/src/crypto/impl/secret_key_seed_conversion.dart':\n\nThis file provides two functions: `secretKeyToSeed` and `seedToSecretKey`, for converting between Tezos secret keys and seeds, utilizing custom prefixes and error handling."}
{"code": "import 'dart:typed_data';\nimport 'package:blockchain_signer/blockchain_signer.dart';\nimport 'package:meta/meta.dart';\nimport 'package:equatable/equatable.dart';\n\n// internal Library\n//\n// we hide Prefixes from the crypto name and then show it without a name to avoid this:\n// `static const crypto.Prefixes _seedPrefix = crypto.Prefixes.edsk2;`\n// and have this instead :\n// `static const Prefixes = Prefixes.edsk2;\nimport 'package:tezart/src/crypto/crypto.dart' as crypto hide Prefixes;\nimport 'package:tezart/src/crypto/crypto.dart' show Prefixes;\nimport 'package:tezart/src/signature/signature.dart';\n\n/// A class that handles keystores and keys (seed, secret key, public key, address) computation.\n///\n/// - [secretKey] is always set\n/// - [mnemonic] might be null\n@immutable\nclass Keystore extends Equatable {\n  static const Prefixes _seedPrefix = Prefixes.edsk2;\n  static const Prefixes _publicKeyPrefix = Prefixes.edpk;\n  static const Prefixes _addressPrefix = Prefixes.tz1;\n  static const _secretKeyLength = 98;", "explanation": "Here is a concise summary:\n\n**Keystore Class**\n\nHandles keystores and key computations, including seed, secret key, public key, and address generation. Stores a secret key by default, with optional mnemonic support.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/keystore/impl/keystore.dart", "chunk_number": 1, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary of the file 'lib/src/keystore/impl/keystore.dart':\n\nThis Dart code defines a `Keystore` class that handles cryptographic key stores. It provides methods to create or initialize a `Keystore` object from various inputs, including mnemonic phrases, encrypted secret keys, and seeds. The class also offers properties and methods for signing data and validating checksums."}
{"code": "  static const _encryptedSecretKeyLength = 88;\n  static const _seedLength = 54;\n\n  final String secretKey;\n\n  final String? mnemonic;\n\n  RemoteSigner? signer;\n\n  Keystore._({required this.secretKey, this.mnemonic});\n\n  /// Generate a keyStore with a remote signer\n  ///\n  /// ```dart\n  /// await magic.tezos.fetchRemoteSigner();\n  /// Keystore.fromRemoteSigner(magic.tezos);\n  /// ```\n  Keystore.fromRemoteSigner(RemoteSigner this.signer) : secretKey = '', mnemonic = null;\n\n  /// A factory that generates a keystore from a secret key.\n  ///\n  /// ```dart\n  /// final keystore = Keystore.fromSecretKey('edskRpm2mUhvoUjHjXgMoDRxMKhtKfww1ixmWiHCWhHuMEEbGzdnz8Ks4vgarKDtxok7HmrEo1JzkXkdkvyw7Rtw6BNtSd7MJ7');\n  /// ```\n  ///\n  /// Throws [CryptoError] if :\\\n  /// - [secretKey] length is != 98\n  /// - [secretKey] checksum is invalid\n  factory Keystore.fromSecretKey(String secretKey) {\n    return crypto.catchUnhandledErrors(() {\n      if (secretKey.length != _secretKeyLength) {", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Create or initialize a `Keystore` object with a secret key.\n\n**Functionality:**\n\n* Initialize a `Keystore` object from a secret key.\n* Generate a `Keystore` object from a remote signer (with Tezos).\n* Provide factory methods for creating `Keystore` objects.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/keystore/impl/keystore.dart", "chunk_number": 2, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary of the file 'lib/src/keystore/impl/keystore.dart':\n\nThis Dart code defines a `Keystore` class that handles cryptographic key stores. It provides methods to create or initialize a `Keystore` object from various inputs, including mnemonic phrases, encrypted secret keys, and seeds. The class also offers properties and methods for signing data and validating checksums."}
{"code": "        throw crypto.CryptoError(type: crypto.CryptoErrorTypes.secretKeyLengthError);\n      }\n      _validateChecksum(secretKey);\n\n      return Keystore._(secretKey: secretKey);\n    });\n  }\n\n  /// A factory that generates a keystore from a seed.\n  ///\n  /// ```dart\n  /// final keystore = Keystore.fromSeed('edsk3RR5U7JsUJ8ctjsuymUPayxMm4LHXaB7VJSfeyMb8fAvbJUnsa');\n  /// ```\n  ///\n  /// Throws [CryptoError] if:\\\n  /// - [seed] length is != 54\n  /// - [seed] checksum is invalid\n  factory Keystore.fromSeed(String seed) {\n    return crypto.catchUnhandledErrors(() {\n      if (seed.length != _seedLength) {\n        throw crypto.CryptoError(type: crypto.CryptoErrorTypes.seedLengthError);\n      }\n      _validateChecksum(seed);\n\n      return Keystore._(secretKey: crypto.seedToSecretKey(seed));\n    });\n  }\n\n  /// A factory that generates a key store from a mnemonic, email and password (for fundraisers).\\\n  ///\n  /// [email] and [password] are optional.\\\n  /// ```dart", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Create a Keystore instance from various inputs.\n\n**Functionality:**\n\n* `Keystore.fromMnemonic`: Creates a Keystore from a mnemonic, email, and password.\n* `Keystore.fromSeed`: Creates a Keystore from a seed string.\n\t+ Both methods validate input length and checksum before generating the Keystore.\n\t+ If validation fails, throws a CryptoError with specific error type.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/keystore/impl/keystore.dart", "chunk_number": 3, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary of the file 'lib/src/keystore/impl/keystore.dart':\n\nThis Dart code defines a `Keystore` class that handles cryptographic key stores. It provides methods to create or initialize a `Keystore` object from various inputs, including mnemonic phrases, encrypted secret keys, and seeds. The class also offers properties and methods for signing data and validating checksums."}
{"code": "  /// final keystore = Keystore.fromMnemonic('brief hello carry loop squeeze unknown click abstract lounge figure logic oblige child ripple about vacant scheme magnet open enroll stuff valve hobby what');\n  /// ```\n  ///\n  /// Throws [CryptoError] if [mnemonic] is invalid.\n  factory Keystore.fromMnemonic(String mnemonic, {String email = '', String password = ''}) {\n    return crypto.catchUnhandledErrors(() {\n      final passphrase = '$email$password';\n      final seedBytes = crypto.seedBytesFromMnemonic(mnemonic, passphrase: passphrase);\n      final seed = crypto.encodeWithPrefix(prefix: _seedPrefix, bytes: seedBytes);\n      final secretKey = crypto.seedToSecretKey(seed);\n\n      return Keystore._(\n        secretKey: secretKey,\n        mnemonic: mnemonic,\n      );\n    });\n  }\n\n  factory Keystore.fromEncryptedSecretKey(\n    String encryptedSecretKey,\n    String passphrase,\n  ) {\n    return crypto.catchUnhandledErrors(() {\n      if (encryptedSecretKey.length != _encryptedSecretKeyLength) {", "explanation": "Here is a concise summary:\n\n**Purpose:** Creates a Keystore object from a mnemonic phrase or an encrypted secret key.\n\n**Functionality:**\n\n* **Mnemonic**: Takes a mnemonic string, generates a passphrase, derives a seed, and creates a Keystore object.\n* **Encrypted Secret Key**: Verifies the length of the encrypted secret key and uses it to create a Keystore object.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/keystore/impl/keystore.dart", "chunk_number": 4, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary of the file 'lib/src/keystore/impl/keystore.dart':\n\nThis Dart code defines a `Keystore` class that handles cryptographic key stores. It provides methods to create or initialize a `Keystore` object from various inputs, including mnemonic phrases, encrypted secret keys, and seeds. The class also offers properties and methods for signing data and validating checksums."}
{"code": "        throw crypto.CryptoError(type: crypto.CryptoErrorTypes.encryptedSecretKeyLengthError);\n      }\n\n      final seed = crypto.encryptedSecretKeyToSeed(\n        encryptedSecretKey: encryptedSecretKey,\n        passphrase: passphrase,\n      );\n\n      return Keystore.fromSeed(seed);\n    });\n  }\n\n  /// A factory that generates a random key store.\\\n  ///\n  /// ```dart\n  /// final keystore = Keystore.random();\n  /// ```\n  factory Keystore.random() {\n    return crypto.catchUnhandledErrors(() {\n      final generated = crypto.generateMnemonic();\n      return Keystore.fromMnemonic(generated);\n    });\n  }\n\n  /// The public key of this.\n  String get publicKey => crypto.catchUnhandledErrors(() {\n    if (signer != null) {\n      return signer?.publicKey as String;\n    }\n\n    final seedBytes = crypto.decodeWithoutPrefix(seed);\n    var pk = crypto.publicKeyBytesFromSeedBytes(seedBytes);\n\n    return crypto.encodeWithPrefix(\n      prefix: _publicKeyPrefix,\n      bytes: Uint8List.fromList(pk.toList()),\n    );\n  });\n", "explanation": "Here is a concise summary:\n\nThis block generates a Keystore object by:\n\n* Converting an encrypted secret key to seed, then creating a new Keystore from it.\n* Creating a random Keystore using a generated mnemonic.\n* Generating the public key associated with the Keystore (if signer exists) or a derived public key from the seed.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/keystore/impl/keystore.dart", "chunk_number": 5, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary of the file 'lib/src/keystore/impl/keystore.dart':\n\nThis Dart code defines a `Keystore` class that handles cryptographic key stores. It provides methods to create or initialize a `Keystore` object from various inputs, including mnemonic phrases, encrypted secret keys, and seeds. The class also offers properties and methods for signing data and validating checksums."}
{"code": "  /// The address of this.\n  String get address => crypto.catchUnhandledErrors(() {\n    if (signer != null) {\n      return signer?.address as String;\n    }\n\n    final publicKeyBytes = crypto.decodeWithoutPrefix(publicKey);\n    final hash = crypto.hashWithDigestSize(\n      size: 160,\n      bytes: publicKeyBytes,\n    );\n\n    return crypto.encodeWithPrefix(\n      prefix: _addressPrefix,\n      bytes: hash,\n    );\n\n  });\n\n  /// The seed of this.\n  String get seed => crypto.catchUnhandledErrors(() {\n        return crypto.secretKeyToSeed(secretKey);\n      });\n\n  /// Returns [tezart.Signature] of [bytes] signed by this.\n  Signature signBytes(Uint8List bytes) => crypto.catchUnhandledErrors(() {\n        return Signature.fromBytes(bytes: bytes, keystore: this);\n      });\n\n  /// Returns [tezart.Signature] of [data] signed by this.\n  Signature signHex(String data) => crypto.catchUnhandledErrors(() {\n        return Signature.fromHex(data: data, keystore: this);\n      });\n\n  @override\n  List<Object> get props => [secretKey];\n", "explanation": "Here is a concise summary:\n\nThis block provides properties and methods for an object that represents a cryptographic key store:\n\n* `address` and `seed`: returns the address and seed associated with this key store.\n* `signBytes` and `signHex`: signs data using this key store, returning a digital signature.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/keystore/impl/keystore.dart", "chunk_number": 6, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary of the file 'lib/src/keystore/impl/keystore.dart':\n\nThis Dart code defines a `Keystore` class that handles cryptographic key stores. It provides methods to create or initialize a `Keystore` object from various inputs, including mnemonic phrases, encrypted secret keys, and seeds. The class also offers properties and methods for signing data and validating checksums."}
{"code": "  // TODO: refactor : ChecksumValidator\n  static void _validateChecksum(String string) {\n    if (!crypto.isChecksumValid(string)) {\n      throw crypto.CryptoError(type: crypto.CryptoErrorTypes.invalidChecksum);\n    }\n  }\n}\n", "explanation": "**Purpose:** Validates a checksum for a given string.\n\n**Functionality:** Throws an error if the checksum is invalid, otherwise does nothing.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/keystore/impl/keystore.dart", "chunk_number": 7, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary of the file 'lib/src/keystore/impl/keystore.dart':\n\nThis Dart code defines a `Keystore` class that handles cryptographic key stores. It provides methods to create or initialize a `Keystore` object from various inputs, including mnemonic phrases, encrypted secret keys, and seeds. The class also offers properties and methods for signing data and validating checksums."}
{"code": "/// A library that allows key stores generation and secret key, public key, address computation\n///\n/// It exposes:\n/// - [Keystore]\n/// - [CryptoError]\nlibrary keystore;\n\nexport 'impl/keystore.dart';\nexport 'package:tezart/src/crypto/impl/crypto_error.dart';\n", "explanation": "Here is a concise summary:\n\nThis library generates key stores, computes secret keys, public keys, and addresses, exposing Keystore and CryptoError functionality.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/keystore/keystore.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise holistic summary of the file 'lib/src/keystore/keystore.dart':\n\n\"This library provides key management functionality, enabling the generation of key stores, computation of secret keys, public keys, and addresses.\""}
{"code": "import 'dart:typed_data';\n\nimport 'package:convert/convert.dart';\nimport 'package:tezart/src/crypto/crypto.dart';\n\nimport 'micheline_decoder.dart';\n\nclass AddressDecoder implements MichelineDecoder {\n  @override\n  final type = {};\n  @override\n  final Map<String, dynamic> data;\n\n  AddressDecoder(this.data);\n\n  @override\n  String decode() {\n    if (data.containsKey('bytes')) {\n      final String stringBytes = data['bytes'];\n      final bytes = Uint8List.fromList(hex.decode(stringBytes.substring(4)));\n      Prefixes? prefix;\n\n      if (stringBytes.startsWith('0000')) {\n        prefix = Prefixes.tz1;\n      } else if (stringBytes.startsWith('0001')) {\n        prefix = Prefixes.tz2;\n      } else if (stringBytes.startsWith('0002')) {\n        prefix = Prefixes.tz3;\n      } else if (stringBytes.startsWith('01')) {\n        prefix = Prefixes.KT;\n      }\n\n      return prefix == null ? data['bytes'] : encodeWithPrefix(prefix: prefix, bytes: bytes);\n    }\n\n    return data['string'];\n  }\n}\n", "explanation": "Here is a concise summary:\n\nThis block of code implements an `AddressDecoder` class that decodes Tezos addresses from Micheline format to human-readable string format. It takes a map of data as input, extracts the address bytes, determines the prefix (e.g., Tz1, Tz2), and returns the decoded address with prefix if applicable.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_decoder/impl/address_decoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and to-the-point summary:\n\nThe `address_decoder.dart` file implements an `AddressDecoder` class that decodes Tezos addresses from Micheline format into human-readable strings, including prefix determination (e.g., Tz1, Tz2)."}
{"code": "import 'package:tezart/src/contracts/contract.dart';\n\nimport 'micheline_decoder.dart';\n\nclass BigMapDecoder implements MichelineDecoder {\n  @override\n  final Map<String, dynamic> type;\n  @override\n  final Map<String, dynamic> data;\n  final String? annot;\n\n  BigMapDecoder({required this.annot, required this.type, required this.data});\n\n  @override\n  BigMap decode() {\n    return BigMap(\n      name: annot,\n      id: data['int'],\n      keyType: type['args'].first,\n      valueType: type['args'][1],\n    );\n  }\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Decodes BigMap data from Micheline format.\n\n**Functionality:** Takes Micheline-encoded data as input and returns a `BigMap` object with decoded fields (name, id, keyType, valueType).", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_decoder/impl/big_map_decoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise holistic summary of the file 'lib/src/micheline_decoder/impl/big_map_decoder.dart':\n\n**Decodes Micheline-encoded BigMap data into a structured BigMap object.**"}
{"code": "import 'micheline_decoder.dart';\n\nclass BytesDecoder implements MichelineDecoder {\n  @override\n  final type = {};\n  @override\n  final Map<String, dynamic> data;\n\n  BytesDecoder(this.data);\n\n  @override\n  String decode() {\n    return data['bytes'] ?? data['string'];\n  }\n}\n", "explanation": "This block is a custom decoder class that decodes Micheline byte strings into human-readable format.\n\nFunctionality: \n\n* It takes a Map of data as input.\n* It returns either the 'bytes' or 'string' value from the map, if present.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_decoder/impl/bytes_decoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n`BytesDecoder`: A custom decoder class that converts Micheline byte strings into human-readable format by extracting and returning the 'bytes' or 'string' value from an input data Map, if present."}
{"code": "import 'micheline_decoder.dart';\n\nclass IntDecoder implements MichelineDecoder {\n  @override\n  final type = {};\n  @override\n  final Map<String, dynamic> data;\n\n  IntDecoder(this.data);\n\n  @override\n  int decode() {\n    return int.parse(data['int'] as String);\n  }\n}\n", "explanation": "**Summary**\n\nThis block defines a class `IntDecoder` that implements the `MichelineDecoder` interface. Its purpose is to decode an integer value from Micheline data, specifically by parsing the string value stored in a 'int' key of its internal data map.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_decoder/impl/int_decoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**lib/src/micheline_decoder/impl/int_decoder.dart**\n\nDecodes an integer value from Micheline data using the 'int' key."}
{"code": "import 'dart:typed_data';\n\nimport 'package:convert/convert.dart';\nimport 'package:tezart/src/crypto/crypto.dart';\n\nimport 'micheline_decoder.dart';\n\nclass KeyDecoder implements MichelineDecoder {\n  @override\n  final type = {};\n  @override\n  final Map<String, dynamic> data;\n\n  KeyDecoder(this.data);\n\n  @override\n  String decode() {\n    if (data.containsKey('bytes')) {\n      final String stringBytes = data['bytes'];\n      final bytes = Uint8List.fromList(hex.decode(stringBytes.substring(2)));\n      Prefixes? prefix;\n\n      if (stringBytes.startsWith('00')) {\n        prefix = Prefixes.edpk;\n      } else if (stringBytes.startsWith('01')) {\n        prefix = Prefixes.sppk;\n      } else if (stringBytes.startsWith('02')) {\n        prefix = Prefixes.p2pk;\n      }\n\n      return prefix != null ? encodeWithPrefix(prefix: prefix, bytes: bytes) : data['bytes'];\n    }\n\n    return data['string'];\n  }\n}\n", "explanation": "Here is a concise summary of the block's purpose and functionality:\n\n**Purpose:** Decodes a \"Key\" object from Micheline format.\n\n**Functionality:** Takes a Map `data` as input, extracts key information (bytes or string), and applies a prefix if applicable, returning the decoded key.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_decoder/impl/key_decoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'lib/src/micheline_decoder/impl/key_decoder.dart':\n\n**Decodes Micheline \"Key\" objects**\n\nExtracts key info from input Map `data`, applies prefix if necessary, and returns the decoded key."}
{"code": "import 'micheline_decoder.dart';\n\nclass ListDecoder implements MichelineDecoder {\n  @override\n  final Map<String, dynamic> type;\n  @override\n  final List<dynamic> data;\n\n  ListDecoder({required this.type, required this.data});\n\n  @override\n  List<dynamic> decode() {\n    return data.map((e) {\n      return MichelineDecoder(type: type['args'].first, data: e).decode();\n    }).toList();\n  }\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Decodes a list of Micheline values.\n\n**Functionality:** Uses another `MichelineDecoder` instance to recursively decode each item in the input list, based on the provided type definition.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_decoder/impl/list_decoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/micheline_decoder/impl/list_decoder.dart':\n\n**Decodes Micheline List**\n \nDecodes a list of Micheline values using another `MichelineDecoder` instance to recursively decode each item, based on the provided type definition."}
{"code": "import 'micheline_decoder.dart';\n\nclass MapDecoder implements MichelineDecoder {\n  @override\n  final List data;\n  @override\n  final Map<String, dynamic> type;\n\n  MapDecoder({required this.data, required this.type});\n\n  @override\n  Map<String, dynamic> decode() {\n    return data.fold({}, (previousValue, element) {\n      final key = MichelineDecoder(\n        type: type['args'].first,\n        data: element['args'].first,\n      ).decode();\n      final value = MichelineDecoder(\n        type: type['args'][1],\n        data: element['args'][1],\n      ).decode();\n\n      return {...previousValue, key: value};\n    });\n  }\n}\n", "explanation": "**Summary**\n\nThis block is a class called `MapDecoder` that implements a Micheline decoder. Its purpose is to decode a list of elements into a Map, with keys and values generated from specific types in the input data.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_decoder/impl/map_decoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary:\n\n`MapDecoder`: A Micheline decoder that maps a list of elements to a `Map`, generating keys and values based on input type specifications."}
{"code": "import 'micheline_decoder_factory.dart';\n\n/// A class that converts Micheline to Dart types\n///\n/// [type] is a Map defining the type of the data we want to convert\n/// [data] the Micheline data we want to convert\nclass MichelineDecoder {\n  final Map<String, dynamic> type;\n  final dynamic data;\n\n  MichelineDecoder({required this.type, required this.data});\n\n  dynamic decode() {\n    final prim = type['prim'];\n    final decodedValue = MichelineDecoderFactory.decoderFor(\n      prim: prim,\n      type: type,\n      data: data,\n      annot: _annot,\n    ).decode();\n\n    return _isAnonymous ? decodedValue : {_annot: decodedValue};\n  }\n\n  // TODO: duplicated code, refactor this\n  bool get _isAnonymous {\n    return !(type.containsKey('annots') && type['annots'] != null);\n  }\n\n  String? get _annot {\n    return (type['annots']?.first as String?)?.substring(1);\n  }\n}\n", "explanation": "**Purpose:** Converts Micheline data to Dart types.\n\n**Functionality:** Takes a type definition and Micheline data as input, using an external factory to decode the data into a dynamic value, with optional annotation handling.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_decoder/impl/micheline_decoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\nThe `micheline_decoder.dart` file converts Micheline data to Dart types by decoding it with an external factory, taking into account type definitions and optional annotations."}
{"code": "import 'address_decoder.dart';\nimport 'big_map_decoder.dart';\nimport 'bytes_decoder.dart';\nimport 'int_decoder.dart';\nimport 'key_decoder.dart';\nimport 'list_decoder.dart';\nimport 'map_decoder.dart';\nimport 'micheline_decoder.dart';\nimport 'option_decoder.dart';\nimport 'pair_decoder.dart';\nimport 'signature_decoder.dart';\nimport 'string_decoder.dart';\nimport 'timestamp_decoder.dart';\nimport 'unit_decoder.dart';\n\nclass MichelineDecoderFactory {\n  static MichelineDecoder decoderFor({\n    required String prim,\n    required Map<String, dynamic> type,\n    required dynamic data,\n    required String? annot,\n  }) {\n    switch (prim) {\n      case 'pair':\n        return PairDecoder(type: type, data: data);\n      case 'string':\n        // cast to fix : _TypeError (type '_InternalLinkedHashMap<String, dynamic>' is not a subtype of type 'Map<String, String>')\n        return StringDecoder(Map<String, String>.from(data));\n      case 'list':\n        return ListDecoder(type: type, data: data);\n      case 'map':", "explanation": "**Purpose:** \nThis block creates a factory for Micheline decoder classes.\n\n**Functionality:** \n\n* It imports various decoder classes for different Micheline primitives.\n* The `MichelineDecoderFactory` class generates instances of these decoders based on input parameters (`prim`, `type`, `data`, and `annot`).", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_decoder/impl/micheline_decoder_factory.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary:\n\n**MichelineDecoderFactory**\n\nA factory class that generates instances of Micheline decoders based on input parameters (`prim`, `type`, `data`, `annot`), returning specific decoder types through a switch statement, or throwing an error if no match is found."}
{"code": "        return MapDecoder(data: data, type: type);\n      case 'big_map':\n        return BigMapDecoder(annot: annot, type: type, data: data);\n      case 'bytes':\n        return BytesDecoder(data);\n      case 'int':\n      case 'nat':\n        return IntDecoder(data);\n      case 'key':\n        return KeyDecoder(data);\n      case 'timestamp':\n        return TimestampDecoder(data);\n      case 'address':\n        return AddressDecoder(data);\n      case 'option':\n        return OptionDecoder(data: data, type: type);\n      case 'signature':\n        return SignatureDecoder(data);\n      case 'unit':\n        return UnitDecoder();\n      default:\n        throw UnimplementedError('Unknwon type: $prim');\n    }\n  }\n}\n", "explanation": "**Summary**\n\nThis block is a `switch` statement that returns different types of decoders based on the provided input parameters (`data`, `type`, etc.). It matches specific values and returns an instance of the corresponding decoder class, or throws an error if no match is found.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_decoder/impl/micheline_decoder_factory.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary:\n\n**MichelineDecoderFactory**\n\nA factory class that generates instances of Micheline decoders based on input parameters (`prim`, `type`, `data`, `annot`), returning specific decoder types through a switch statement, or throwing an error if no match is found."}
{"code": "import 'micheline_decoder.dart';\n\nclass OptionDecoder implements MichelineDecoder {\n  @override\n  final dynamic data;\n  @override\n  final Map<String, dynamic> type;\n\n  OptionDecoder({required this.data, required this.type});\n\n  @override\n  dynamic decode() {\n    if (data['prim'] == 'None') return null;\n\n    return MichelineDecoder(type: type['args'].first, data: data['args'].first).decode();\n  }\n}\n", "explanation": "**Purpose:** Decodes Micheline option values.\n\n**Functionality:** Checks if value is \"None\" and returns null or recursively decodes nested values.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_decoder/impl/option_decoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary of the file 'lib/src/micheline_decoder/impl/option_decoder.dart':\n\nDecodes Micheline option values, returning `null` for \"None\" and recursively decoding nested values."}
{"code": "import 'package:quiver/iterables.dart';\n\nimport 'micheline_decoder.dart';\n\nclass PairDecoder implements MichelineDecoder {\n  @override\n  final Map<String, dynamic> type;\n  @override\n  final dynamic data;\n\n  PairDecoder({required this.type, required this.data});\n\n  @override\n  Map<String, dynamic> decode() {\n    return zip<dynamic>(\n      [data['args'].toList(), type['args'].toList()],\n    ).map((zippedElement) {\n      final currentData = zippedElement.first;\n      final currentType = zippedElement[1];\n\n      return MichelineDecoder(data: currentData, type: currentType).decode();\n    }).fold<Map<String, dynamic>>({}, (previousValue, element) => {...previousValue, ...element});\n  }\n}\n", "explanation": "**Summary**\n\nThis block defines a `PairDecoder` class that implements a Micheline decoder. It decodes data into a map structure by zipping pairs of arguments with their corresponding types. The `decode()` method returns a map where each key-value pair is decoded recursively using another instance of the Micheline decoder.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_decoder/impl/pair_decoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary:\n\n`PairDecoder`: A Micheline decoder that decodes data into a map structure by pairing typed arguments, recursively decoding with another instance as needed."}
{"code": "import 'package:tezart/src/crypto/crypto.dart';\n\nimport 'micheline_decoder.dart';\n\nclass SignatureDecoder implements MichelineDecoder {\n  @override\n  final type = {};\n  @override\n  final Map<String, dynamic> data;\n\n  SignatureDecoder(this.data);\n\n  @override\n  String decode() {\n    if (data.containsKey('bytes')) return encodeWithPrefix(prefix: Prefixes.edsig, bytes: data['bytes']);\n\n    return data['string'];\n  }\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Decodes Micheline signatures.\n**Functionality:** Extracts signature value from input data, either as a byte array or string.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_decoder/impl/signature_decoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and to-the-point holistic summary of the file 'lib/src/micheline_decoder/impl/signature_decoder.dart':\n\n**Decodes Micheline Signatures:**\nExtracts signature values from input data (byte array or string)."}
{"code": "import 'micheline_decoder.dart';\n\nclass StringDecoder implements MichelineDecoder {\n  @override\n  final Map<String, String> data;\n  @override\n  final Map<String, dynamic> type = {};\n\n  StringDecoder(this.data);\n\n  @override\n  String decode() {\n    if (data['string'] == null) throw ArgumentError.notNull(\"data['string']\");\n\n    return data['string']!;\n  }\n}\n", "explanation": "Here is a concise summary:\n\nThis block defines a `StringDecoder` class that implements Micheline decoding functionality, specifically extracting and returning a string value from a map.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_decoder/impl/string_decoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and to-the-point holistic summary of the file 'lib/src/micheline_decoder/impl/string_decoder.dart':\n\n\"This Dart file defines a `StringDecoder` class that extracts and returns a string value from Micheline-formatted data.\""}
{"code": "import 'micheline_decoder.dart';\n\nclass TimestampDecoder implements MichelineDecoder {\n  @override\n  final Map<String, dynamic> data;\n  @override\n  final type = {};\n\n  TimestampDecoder(this.data);\n\n  @override\n  DateTime decode() {\n    dynamic timestamp = data['int'] ?? data['string'];\n\n    if (timestamp is String && RegExp(r'^\\d+$').hasMatch(timestamp)) timestamp = int.parse(timestamp);\n    if (timestamp is int) {\n      return DateTime.fromMillisecondsSinceEpoch(timestamp * 1000);\n    }\n\n    return DateTime.parse(timestamp);\n  }\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Decodes timestamps from Micheline data.\n\n**Functionality:** Converts timestamp data (int or string) to a DateTime object, using either milliseconds since epoch or a human-readable date string format.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_decoder/impl/timestamp_decoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary of the file 'lib/src/micheline_decoder/impl/timestamp_decoder.dart':\n\n**Decodes Micheline Timestamps:** Converts timestamp data (int or string) to a DateTime object, using epoch milliseconds or human-readable formats."}
{"code": "import 'micheline_decoder.dart';\n\nclass UnitDecoder implements MichelineDecoder {\n  @override\n  final data = null;\n  @override\n  final type = {};\n\n  @override\n  Null decode() {\n    return null;\n  }\n}\n", "explanation": "Here is a concise summary:\n\nThis block defines a `UnitDecoder` class that implements the `MichelineDecoder` interface, which appears to be responsible for decoding Micheline data. The class has no data to process, always returning null from its `decode()` method.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_decoder/impl/unit_decoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and to-the-point summary:\n\n**UnitDecoder**: A trivial Micheline decoder implementation that always returns null, serving as a placeholder or example in the context of Micheline decoding."}
{"code": "/// A library that converts Micheline data tot Dart basic objects\n///\n/// It exposes:\n/// - [MichelineDecoder]\nlibrary micheline_decoder;\n\nexport 'impl/micheline_decoder.dart';\n", "explanation": "A library for converting Micheline data into basic Dart objects, specifically exposing a `MichelineDecoder`.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_decoder/micheline_decoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and to-the-point holistic summary of the file 'lib/src/micheline_decoder/micheline_decoder.dart':\n\n\"A library providing a `MichelineDecoder` for converting Micheline data into basic Dart objects.\""}
{"code": "import 'micheline_encoder.dart';\n\nclass BytesEncoder implements MichelineEncoder {\n  @override\n  final String params;\n  @override\n  final type = {};\n\n  BytesEncoder(this.params);\n\n  @override\n  Map<String, dynamic> encode() {\n    return {'bytes': params};\n  }\n}\n", "explanation": "**Purpose:** Encodes a string as bytes.\n\n**Functionality:** Converts a string input into a JSON-like object with a single key-value pair containing the encoded bytes.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_encoder/impl/bytes_encoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary of the file 'lib/src/micheline_encoder/impl/bytes_encoder.dart':\n\n\"Encodes a string as bytes, returning a JSON-like object with a single key-value pair containing the encoded bytes.\""}
{"code": "import 'micheline_encoder.dart';\n\nclass IntEncoder implements MichelineEncoder {\n  @override\n  final int params;\n  @override\n  final type = {};\n\n  IntEncoder(this.params);\n\n  @override\n  Map<String, dynamic> encode() {\n    return {'int': params.toString()};\n  }\n}\n", "explanation": "Here is a concise summary:\n\nThis block defines an `IntEncoder` class that implements the `MichelineEncoder` interface, encoding integers into a specific format using Micheline serialization rules.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_encoder/impl/int_encoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'lib/src/micheline_encoder/impl/int_encoder.dart':\n\nThis Dart file defines an `IntEncoder` class that implements Micheline integer encoding rules, serializing integers into a specific format as per Micheline serialization conventions."}
{"code": "import 'micheline_encoder.dart';\n\nclass ListEncoder implements MichelineEncoder {\n  @override\n  final List params;\n  @override\n  final Map<String, dynamic> type;\n\n  ListEncoder({required this.params, required this.type});\n\n  @override\n  List encode() {\n    return params.map((element) => MichelineEncoder(type: type['args'].first, params: element).encode()).toList();\n  }\n}\n", "explanation": "This block is a class named `ListEncoder` that implements the `MichelineEncoder` interface. Its purpose is to encode lists of elements into Micheline format, using the provided type and parameters.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_encoder/impl/list_encoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/micheline_encoder/impl/list_encoder.dart':\n\n**Summary:** `ListEncoder` class encodes lists of elements into Micheline format."}
{"code": "import 'micheline_encoder.dart';\n\nclass MapEncoder implements MichelineEncoder {\n  @override\n  final Map<String, dynamic> params;\n  @override\n  final Map<String, dynamic> type;\n\n  MapEncoder({required this.params, required this.type});\n\n  @override\n  List<Map<String, dynamic>> encode() {\n    return params.keys\n        .map((key) => {\n              'prim': 'Elt',\n              'args': [\n                MichelineEncoder(type: _keyType, params: key).encode(),\n                MichelineEncoder(type: _valueType, params: params[key]).encode(),\n              ],\n            })\n        .toList();\n  }\n\n  Map<String, dynamic> get _keyType => type['args'].first;\n  Map<String, dynamic> get _valueType => type['args'][1];\n}\n", "explanation": "Here is a summary of the purpose and functionality of this block:\n\n**Purpose:** Encodes a map (hash table) into Micheline format.\n\n**Functionality:** Takes a `params` map and an associated `type` map as input, and returns a list of encoded elements in Micheline format. Each element represents a key-value pair from the original map.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_encoder/impl/map_encoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**lib/src/micheline_encoder/impl/map_encoder.dart**: Encodes a hash table (map) into Micheline format by iterating through key-value pairs, generating corresponding elements in Micheline syntax."}
{"code": "import 'bytes_encoder.dart';\nimport 'int_encoder.dart';\nimport 'list_encoder.dart';\nimport 'map_encoder.dart';\nimport 'option_encoder.dart';\nimport 'pair_encoder.dart';\nimport 'string_encoder.dart';\nimport 'timestamp_encoder.dart';\nimport 'unit_encoder.dart';\n\n/// A class that converts Dart type object to Micheline\n///\n/// [type] is a Map defining the type of the data we want to convert\n/// [params] the data we want to convert\nclass MichelineEncoder {\n  final Map<String, dynamic> type;\n  final dynamic params;\n\n  MichelineEncoder({required this.type, required this.params});\n\n  // might be Map<String,dynamic> in the general case but also List in the case of prim == 'list'\n  dynamic encode() {\n    final prim = type['prim'];\n    MichelineEncoder encoder;\n\n    switch (prim) {\n      case 'pair':\n        encoder = PairEncoder(params: _params, type: type);\n        break;\n      case 'timestamp':\n        encoder = TimestampEncoder(_params);\n        break;\n      case 'string':\n      // TODO: implement validators of these types", "explanation": "Here is a concise summary:\n\n**Purpose:** The `MichelineEncoder` class converts Dart type objects to Micheline format.\n\n**Functionality:** It takes in a Map (`type`) defining the data type and parameters (`params`) to be converted, then uses different encoder classes (e.g., `PairEncoder`, `TimestampEncoder`) based on the `prim` value in the `type` map to perform the conversion.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_encoder/impl/micheline_encoder.dart", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the `MichelineEncoder` class:\n\n**Summary:** The `MichelineEncoder` class encodes Dart type objects into Micheline format by selecting and using specialized encoder classes based on the data type, converting parameters, and generating encoded output."}
{"code": "      case 'address':\n      case 'contract':\n      case 'key':\n      case 'signature':\n        encoder = StringEncoder(_params);\n        break;\n      case 'bytes':\n        encoder = BytesEncoder(_params);\n        break;\n      case 'nat':\n      case 'int':\n        encoder = IntEncoder(_params);\n        break;\n      case 'option':\n        encoder = OptionEncoder(params: _params, type: type);\n        break;\n      case 'list':\n        encoder = ListEncoder(params: _params, type: type);\n        break;\n      case 'map':\n      case 'big_map':\n        encoder = MapEncoder(params: _params, type: type);\n        break;\n      case 'unit':\n        encoder = UnitEncoder();\n        break;\n      default:\n        throw UnimplementedError('Unknown type : $prim');\n    }\n\n    return encoder.encode();\n  }\n\n  bool get _isAnonymous {\n    return !(type.containsKey('annots') && type['annots'] != null);\n  }\n\n  dynamic get _params {\n    return _isAnonymous ? params : (params as Map<String, dynamic>)[_annot];\n  }\n\n  String? get _annot {", "explanation": "Here is a concise summary:\n\n**Purpose:** This block determines the type of data to encode based on a given string (`prim`) and creates an encoder instance accordingly.\n\n**Functionality:** It uses a switch statement to select an encoder class based on the `prim` value, then calls the selected encoder's `encode()` method to generate encoded data.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_encoder/impl/micheline_encoder.dart", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the `MichelineEncoder` class:\n\n**Summary:** The `MichelineEncoder` class encodes Dart type objects into Micheline format by selecting and using specialized encoder classes based on the data type, converting parameters, and generating encoded output."}
{"code": "    if (_isAnonymous) return null;\n\n    return (type['annots'].first as String).substring(1);\n  }\n}\n", "explanation": "**Functionality Summary**\n\nThis block returns a substring of the first annotation in the 'annots' property, starting from index 1. If the instance is anonymous (_isAnonymous), it returns null.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_encoder/impl/micheline_encoder.dart", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the `MichelineEncoder` class:\n\n**Summary:** The `MichelineEncoder` class encodes Dart type objects into Micheline format by selecting and using specialized encoder classes based on the data type, converting parameters, and generating encoded output."}
{"code": "import 'micheline_encoder.dart';\n\nclass OptionEncoder implements MichelineEncoder {\n  @override\n  final dynamic params;\n  @override\n  final Map<String, dynamic> type;\n\n  OptionEncoder({required this.params, required this.type});\n\n  @override\n  Map<String, dynamic> encode() {\n    if (params == null) return {'prim': 'None'};\n\n    return {\n      'prim': 'Some',\n      'args': [\n        MichelineEncoder(type: type['args'].first, params: params).encode(),\n      ]\n    };\n  }\n}\n", "explanation": "**Summary**\n\nThis block is a class named `OptionEncoder` that implements the `MichelineEncoder` interface. It encodes an option value (e.g., \"Some\" or \"None\") into Micheline format, using provided parameters (`params`) and type information (`type`).", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_encoder/impl/option_encoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**lib/src/micheline_encoder/impl/option_encoder.dart**\n\nClass `OptionEncoder` implements `MichelineEncoder`, encoding option values (\"Some\" or \"None\") into Micheline format based on provided parameters and type information."}
{"code": "import 'micheline_encoder.dart';\n\nclass PairEncoder implements MichelineEncoder {\n  @override\n  // Might be a Map<String, dynamic> or List<dynamic>\n  final dynamic params;\n  @override\n  final Map<String, dynamic> type;\n\n  PairEncoder({required this.params, required this.type});\n\n  @override\n  Map<String, dynamic> encode() {\n    return {'prim': 'Pair', 'args': _args};\n  }\n\n  List<dynamic> get _args {\n    List type_args = type['args'];\n    final args_iterator = type_args.asMap().entries.map((entry) {\n      var idx = entry.key;\n      dynamic type_arg = entry.value;\n\n      return (MichelineEncoder(\n        type: type_arg,\n        params: _paramN(idx),\n      ).encode());\n    });\n    return args_iterator.toList();\n  }\n\n  int get _argsCount {\n    return (type['args'].length);\n  }\n\n  dynamic _paramN(int n) {\n    if (params is Map) return params;\n    if (params is List) {\n      var isLastArg = (n == type['args'].length - 1);\n      // Handle the case when last arg is i Pair, which arguments are the last elements of the data", "explanation": "Here is a concise summary:\n\n**Purpose:** Encode Micheline objects as JSON.\n\n**Functionality:**\n\n* Encodes a pair object with a specified type and parameters.\n* Iterates over the arguments of the type, encoding each one recursively using `MichelineEncoder`.\n* Returns a map representing the encoded pair object.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_encoder/impl/pair_encoder.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary of the file 'lib/src/micheline_encoder/impl/pair_encoder.dart':\n\n**Summary:**\nThe `pair_encoder` encodes Micheline pair objects as JSON, recursively handling arguments with `MichelineEncoder`, and selectively returning parameters based on conditions."}
{"code": "      if (isLastArg && params.length > _argsCount) {\n        return params.skip(_argsCount - 1).toList();\n      } else {\n        return params[n];\n      }\n    }\n    throw TypeError();\n  }\n}\n", "explanation": "Here is a concise summary:\n\n**Functionality:** Returns a subset of parameters, either by skipping unnecessary arguments or retrieving a specific parameter.\n\n**Purpose:** Handles parameters in a dynamic way based on conditions (isLastArg and params length).", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_encoder/impl/pair_encoder.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary of the file 'lib/src/micheline_encoder/impl/pair_encoder.dart':\n\n**Summary:**\nThe `pair_encoder` encodes Micheline pair objects as JSON, recursively handling arguments with `MichelineEncoder`, and selectively returning parameters based on conditions."}
{"code": "import 'micheline_encoder.dart';\n\nclass StringEncoder implements MichelineEncoder {\n  @override\n  final String params;\n  @override\n  final type = {};\n\n  StringEncoder(this.params);\n\n  @override\n  Map<String, dynamic> encode() {\n    return {'string': params};\n  }\n}\n", "explanation": "**Purpose:** Encodes a string value into Micheline format.\n\n**Functionality:** A class that implements Micheline encoding for strings, taking a string parameter and returning it as a Map in Micheline format.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_encoder/impl/string_encoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/micheline_encoder/impl/string_encoder.dart':\n\n**Encodes a string value into Micheline format**: A class implementation that converts a string input into a Micheline-formatted output as a Map."}
{"code": "import 'micheline_encoder.dart';\n\nclass TimestampEncoder implements MichelineEncoder {\n  @override\n  final DateTime params;\n  @override\n  final type = {};\n\n  TimestampEncoder(this.params);\n\n  @override\n  Map<String, dynamic> encode() {\n    return {'int': (params.millisecondsSinceEpoch ~/ 1000).toString()};\n  }\n}\n", "explanation": "This block is a class named `TimestampEncoder` that encodes a DateTime object into a Micheline-compatible format as a 32-bit integer.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_encoder/impl/timestamp_encoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/micheline_encoder/impl/timestamp_encoder.dart':\n\n**Class Summary:**\n\nThe `TimestampEncoder` class encodes a `DateTime` object into a 32-bit Micheline-compatible integer, facilitating timestamp data conversion within the Micheline framework."}
{"code": "import 'package:tezart/src/micheline_encoder/impl/micheline_encoder.dart';\n\nclass UnitEncoder implements MichelineEncoder {\n  @override\n  final params = {};\n  @override\n  final type = {};\n\n  @override\n  Map<String, String> encode() {\n    return {'prim': 'Unit'};\n  }\n}\n", "explanation": "This block defines a class `UnitEncoder` that implements `MichelineEncoder`. Its purpose is to encode a \"Unit\" value in Micheline format. The `encode()` method returns a map with the key-value pair `'prim' = 'Unit'`, which represents the encoded data.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_encoder/impl/unit_encoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'lib/src/micheline_encoder/impl/unit_encoder.dart':\n\n**Summary:**\n\nThis file contains a single class, `UnitEncoder`, that implements Micheline encoding for \"Unit\" values. It provides an `encode()` method to convert Unit data into Micheline format as a map with key-value pair `'prim' = 'Unit'`."}
{"code": "/// A library that converts Dart basic objects to Micheline\n///\n/// It exposes:\n/// - [MichelineEncoder]\nlibrary micheline_encoder;\n\nexport 'impl/micheline_encoder.dart';\n", "explanation": "This block defines a library called `micheline_encoder` that converts Dart's basic objects to Micheline, exposing a single class named `MichelineEncoder`.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/micheline_encoder/micheline_encoder.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary:\n\n**lib/src/micheline_encoder/micheline_encoder.dart**: \nA Dart library that provides a single class, `MichelineEncoder`, for converting basic Dart objects into Micheline format."}
{"code": "import 'package:logging/logging.dart';\nimport 'package:json_annotation/json_annotation.dart';\nimport 'package:tezart/src/common/utils/enum_util.dart';\nimport 'package:tezart/src/common/validators/simulation_result_validator.dart';\nimport 'package:tezart/src/models/operation/impl/operation_visitor.dart';\nimport 'package:tezart/tezart.dart';\n\npart 'operation.g.dart';\n\nenum Kinds {\n  generic,\n  transaction,\n  delegation,\n  origination,\n  transfer,\n  reveal,\n}\n\n/// A class representing a single tezos operation\n@JsonSerializable(includeIfNull: false, createFactory: false)\nclass Operation {\n  @JsonKey(ignore: true)\n  Map<String, dynamic>? _simulationResult;\n  @JsonKey(ignore: true)\n  OperationsList? operationsList;\n  @JsonKey(ignore: true)\n  final log = Logger('Operation');\n\n  @JsonKey(toJson: _kindToString)\n  final Kinds kind;\n\n  @JsonKey()\n  final String? destination;\n\n  @JsonKey(toJson: _toString)\n  final int? amount;\n\n  @JsonKey(toJson: _toString)\n  final int? balance;\n\n  @JsonKey(toJson: _toString)\n  int? counter;\n", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Define a class `Operation` that represents a single Tezos operation.\n\n**Functionality:** Encapsulates Tezos operation data, including kind, destination, amount, balance, and counter, with additional utilities for simulation result handling and logging.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operation/impl/operation.dart", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary of the file 'lib/src/models/operation/impl/operation.dart':\n\n**Summary:** This Dart class represents a single Tezos operation, encapsulating its data (kind, destination, amount, balance) with utilities for simulation result handling and logging."}
{"code": "  @JsonKey(ignore: true)\n  Map<String, dynamic>? params;\n\n  @JsonKey(ignore: true)\n  String? entrypoint;\n\n  @JsonKey()\n  Map<String, dynamic>? script;\n\n  @JsonKey(name: 'gas_limit', toJson: _toString)\n  int? gasLimit;\n  @JsonKey(toJson: _toString)\n  int fee;\n  @JsonKey(ignore: true)\n  final int? customFee;\n  @JsonKey(name: 'storage_limit', toJson: _toString)\n  int? storageLimit;\n  @JsonKey(ignore: true)\n  int? customGasLimit;\n  @JsonKey(ignore: true)\n  int? customStorageLimit;\n\n  Operation({\n    required this.kind,\n    this.amount,\n    this.balance,\n    this.destination,\n    this.params,\n    this.script,\n    this.customFee,\n    this.entrypoint,\n    this.customGasLimit,\n    this.customStorageLimit,\n  }) : fee = 0;\n\n  @JsonKey(toJson: _keystoreToAddress)\n  Keystore get source {\n    if (operationsList == null) throw ArgumentError.notNull('operationsList');\n\n    return operationsList!.source;\n  }\n\n  @JsonKey()\n  Map<String, dynamic>? get parameters {\n    var result = <String, dynamic>{};", "explanation": "Here is a concise summary:\n\nThis block defines a class `Operation` with various properties (e.g., `params`, `entrypoint`, `script`) that are used to represent an operation or transaction. The purpose of this code is to serialize these properties into JSON format using the `JsonKey` annotation, and provide getter methods for accessing certain properties (e.g., `source`).", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operation/impl/operation.dart", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary of the file 'lib/src/models/operation/impl/operation.dart':\n\n**Summary:** This Dart class represents a single Tezos operation, encapsulating its data (kind, destination, amount, balance) with utilities for simulation result handling and logging."}
{"code": "    if (entrypoint != null) result['entrypoint'] = entrypoint;\n    if (params != null) result['value'] = params;\n\n    return result.keys.isEmpty ? null : result;\n  }\n\n  @JsonKey(name: 'public_key')\n  String? get publicKey => kind == Kinds.reveal ? source.publicKey : null;\n\n  Map<String, dynamic> toJson() => _$OperationToJson(this);\n\n  static String? _toString(int? integer) => integer?.toString();\n  static String _kindToString(Kinds kind) => EnumUtil.enumToString(kind);\n  static String _keystoreToAddress(Keystore keystore) => keystore.address;\n\n  set simulationResult(Map<String, dynamic>? value) {\n    if (value == null) throw ArgumentError.notNull('simulationResult');\n\n    _simulationResult = value;\n    SimulationResultValidator(_simulationResult!).validate();\n  }\n\n  @JsonKey(ignore: true)\n  Map<String, dynamic>? get simulationResult => _simulationResult;\n\n  Future<void> setLimits(OperationVisitor visitor) async {\n    await visitor.visit(this);\n  }\n}\n", "explanation": "Here is a concise summary of the block:\n\n**Summary:** This Dart class appears to represent an operation in a blockchain or cryptocurrency context. It has properties for entrypoint, params, public key, simulation result, and allows setting limits via visitor pattern.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operation/impl/operation.dart", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary of the file 'lib/src/models/operation/impl/operation.dart':\n\n**Summary:** This Dart class represents a single Tezos operation, encapsulating its data (kind, destination, amount, balance) with utilities for simulation result handling and logging."}
{"code": "// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'operation.dart';\n\n// **************************************************************************\n// JsonSerializableGenerator\n// **************************************************************************\n\nMap<String, dynamic> _$OperationToJson(Operation instance) {\n  final val = <String, dynamic>{};\n\n  void writeNotNull(String key, dynamic value) {\n    if (value != null) {\n      val[key] = value;\n    }\n  }\n\n  writeNotNull('kind', Operation._kindToString(instance.kind));\n  writeNotNull('destination', instance.destination);\n  writeNotNull('amount', Operation._toString(instance.amount));\n  writeNotNull('balance', Operation._toString(instance.balance));\n  writeNotNull('counter', Operation._toString(instance.counter));\n  writeNotNull('script', instance.script);\n  writeNotNull('gas_limit', Operation._toString(instance.gasLimit));\n  writeNotNull('fee', Operation._toString(instance.fee));\n  writeNotNull('storage_limit', Operation._toString(instance.storageLimit));", "explanation": "**Purpose:** Convert an `Operation` object to a JSON map.\n\n**Functionality:** Serializes the `Operation` instance's properties (kind, destination, amount, etc.) into a JSON-formatted map using the `_kindToString()` method for specific type conversions.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operation/impl/operation.g.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary:\n\n**operation.g.dart**\n\nSerializes an Operation object into a JSON map, converting specific properties (kind, source) and omitting null values."}
{"code": "  writeNotNull('source', Operation._keystoreToAddress(instance.source));\n  writeNotNull('parameters', instance.parameters);\n  writeNotNull('public_key', instance.publicKey);\n  return val;\n}\n", "explanation": "**Functionality Summary**\n\nThis block writes not null values to an object, specifically:\n\n* `source` with the result of converting an instance's `source` property to an address\n* `parameters` with the instance's `parameters`\n* `public_key` with the instance's `publicKey`\n\nIt then returns the result (`val`).", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operation/impl/operation.g.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary:\n\n**operation.g.dart**\n\nSerializes an Operation object into a JSON map, converting specific properties (kind, source) and omitting null values."}
{"code": "import 'package:tezart/src/models/operation/impl/operation_visitor.dart';\n\nimport 'operation.dart';\n\nclass OperationFeesSetterVisitor implements OperationVisitor {\n  static const _baseOperationMinimalFee = 100;\n  static const _minimalFeePerByte = 1;\n  static const _minimalFeePerGas = 0.1;\n  static const _signatureSize = 64;\n\n  @override\n  Future<void> visit(Operation operation) async {\n    operation.fee = operation.customFee ?? await _totalCost(operation);\n  }\n\n  Future<int> _burnFee(Operation operation) async {\n    if (operation.storageLimit == null) throw ArgumentError.notNull('operation.storageLimit');\n\n    return (operation.storageLimit! * await _costPerBytes(operation)).ceil();\n  }\n\n  Future<int> _costPerBytes(Operation operation) async {\n    if (operation.operationsList == null) throw ArgumentError.notNull('operation.operationsList');\n\n    return int.parse((await operation.operationsList!.rpcInterface.constants())['cost_per_byte']);\n  }\n\n  int _minimalFee(Operation operation) {", "explanation": "Here is a concise summary:\n\n**Purpose:** Calculates fees for an Operation object.\n\n**Functionality:** The `OperationFeesSetterVisitor` class implements a visitor pattern to set the fee of an Operation object, either using a custom fee or calculating it based on storage limit, gas cost, and minimum fees per byte and gas.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operation/impl/operation_fees_setter_visitor.dart", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'lib/src/models/operation/impl/operation_fees_setter_visitor.dart':\n\n**Calculates total cost for an operation**, consisting of a burn fee and minimal fee, based on gas limit, storage size, and fees per unit."}
{"code": "    return (_baseOperationMinimalFee + _operationFee(operation)).ceil();\n  }\n\n  int _operationFee(Operation operation) {\n    if (operation.gasLimit == null) throw ArgumentError.notNull('operation.gasLimit');\n\n    final gasFee = operation.gasLimit! * _minimalFeePerGas;\n    final sizeFee = _operationSize(operation) * _minimalFeePerByte;\n\n    return (gasFee + sizeFee).ceil();\n  }\n\n  int _operationSize(Operation operation) {\n    return (_signedOperationListSize(operation) / operation.operationsList!.operations.length).ceil();\n  }\n\n  int _signedOperationListSize(Operation operation) {\n    return (_unsignedOperationListSize(operation) + _signatureSize);\n  }\n\n  int _unsignedOperationListSize(Operation operation) {\n    final operationsList = operation.operationsList;\n    if (operationsList == null) throw ArgumentError.notNull('operation.operationsList');\n\n    final operationsListResult = operationsList.result;\n    if (operationsListResult.forgedOperation == null) {", "explanation": "Here is a concise summary:\n\n**Purpose:** Calculate fees for an operation.\n\n**Functionality:**\n\n1. `_operationFee`: Calculates gas fee and size fee based on gas limit and minimal fees per unit.\n2. `_operationSize`: Estimates size of unsigned operation list.\n3. `_signedOperationListSize` and `_unsignedOperationListSize`: Calculate sizes with/without signatures.\n4. Returns total fee by adding calculated values and rounding up.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operation/impl/operation_fees_setter_visitor.dart", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'lib/src/models/operation/impl/operation_fees_setter_visitor.dart':\n\n**Calculates total cost for an operation**, consisting of a burn fee and minimal fee, based on gas limit, storage size, and fees per unit."}
{"code": "      throw ArgumentError.notNull('operation.operationsList.result.forgedOperation');\n    }\n    return (operationsList.result.forgedOperation!.length / 2).ceil();\n  }\n\n  Future<int> _totalCost(Operation operation) async {\n    final burnFee = await _burnFee(operation);\n    final minimalFee = _minimalFee(operation);\n\n    return (burnFee + minimalFee);\n  }\n}\n", "explanation": "Here is a concise summary:\n\nThis block calculates the total cost of an operation, consisting of two parts: a burn fee and a minimal fee, returning their sum as an integer.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operation/impl/operation_fees_setter_visitor.dart", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'lib/src/models/operation/impl/operation_fees_setter_visitor.dart':\n\n**Calculates total cost for an operation**, consisting of a burn fee and minimal fee, based on gas limit, storage size, and fees per unit."}
{"code": "import 'dart:math';\n\nimport 'package:tezart/src/core/rpc/impl/rpc_interface.dart';\nimport 'package:tezart/src/models/operation/impl/operation_visitor.dart';\n\nimport 'operation.dart';\n\nclass OperationHardLimitsSetterVisitor implements OperationVisitor {\n  @override\n  Future<void> visit(Operation operation) async {\n    operation.storageLimit = operation.customStorageLimit ?? await _storage(operation);\n    operation.gasLimit = operation.customGasLimit ?? await _gas(operation);\n  }\n\n  Future<int> _storage(Operation operation) async {\n    final hardStorageLimitPerOperation =\n        int.parse((await _rpcInterface(operation).constants())['hard_storage_limit_per_operation'] as String);\n    final sourceBalanceStorageLimitation = await _rpcInterface(operation).balance(operation.source.address);\n\n    return min(hardStorageLimitPerOperation, sourceBalanceStorageLimitation);\n  }\n\n  Future<int> _gas(Operation operation) async {", "explanation": "**Summary**\n\nThis block is a visitor class (`OperationHardLimitsSetterVisitor`) that sets hard limits for storage and gas usage on Tezos operations. It uses RPC interface calls to retrieve constants and balance information, then calculates minimum values between these data points and hardcoded limits.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operation/impl/operation_hard_limits_setter_visitor.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary:\n\nThis file (`operation_hard_limits_setter_visitor.dart`) contains a visitor class (`OperationHardLimitsSetterVisitor`) that sets hard limits for storage and gas usage on Tezos operations, using RPC interface calls and hardcoded values to calculate minimum limits."}
{"code": "    return int.parse((await _rpcInterface(operation).constants())['hard_gas_limit_per_operation'] as String);\n  }\n\n  RpcInterface _rpcInterface(Operation operation) {\n    final operationsList = operation.operationsList;\n    if (operationsList == null) throw ArgumentError.notNull('operationsList');\n\n    return operationsList.rpcInterface;\n  }\n}\n", "explanation": "**Summary:**\n\nThis block of code retrieves a constant value, `hard_gas_limit_per_operation`, from a remote interface using RPC calls, and returns it as an integer. The remote interface is accessed through a method that takes an `Operation` object as input.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operation/impl/operation_hard_limits_setter_visitor.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary:\n\nThis file (`operation_hard_limits_setter_visitor.dart`) contains a visitor class (`OperationHardLimitsSetterVisitor`) that sets hard limits for storage and gas usage on Tezos operations, using RPC interface calls and hardcoded values to calculate minimum limits."}
{"code": "import 'package:tezart/src/core/rpc/impl/rpc_interface.dart';\nimport 'package:tezart/src/models/operation/impl/operation_visitor.dart';\nimport 'package:tezart/src/models/operation/operation.dart';\n\nimport 'operation.dart';\n\nclass OperationLimitsSetterVisitor implements OperationVisitor {\n  static const _gasBuffer = 100;\n\n  @override\n  Future<void> visit(Operation operation) async {\n    operation.gasLimit = operation.customGasLimit ?? _gasLimitFromConsumed(operation);\n    operation.storageLimit = operation.customStorageLimit ?? _simulationStorageSize(operation);\n\n    if (operation.customStorageLimit != null) return;\n\n    if (operation.kind == Kinds.origination || _isDestinationContractAllocated(operation)) {\n      operation.storageLimit = operation.storageLimit! + await _originationDefaultSize(operation);\n    } else {\n      operation.storageLimit = _simulationStorageSize(operation);\n    }\n  }\n\n  // returns true if the operation is a transfer to an address unknown by the chain", "explanation": "Here is a concise summary:\n\n**Class: OperationLimitsSetterVisitor**\n\n**Purpose:** To set gas and storage limits for operations based on their type and custom limits.\n\n**Functionality:** It updates the `gasLimit` and `storageLimit` of an operation with values from its custom limits, or calculated values if no custom limits are provided.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operation/impl/operation_limits_setter_visitor.dart", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'lib/src/models/operation/impl/operation_limits_setter_visitor.dart':\n\n**Class: OperationLimitsSetterVisitor**\n\nSets gas and storage limits for operations based on type and custom limits, updating `gasLimit` and `storageLimit`. \n\nThis class extends the functionality to update operation limits."}
{"code": "  bool _isDestinationContractAllocated(Operation operation) {\n    return _simulationResult(operation)['metadata']['operation_result']['allocated_destination_contract'] == true;\n  }\n\n  int _simulationStorageSize(Operation operation) {\n    return int.parse(_simulationResult(operation)['metadata']['operation_result']['paid_storage_size_diff'] ?? '0');\n  }\n\n  int _gasLimitFromConsumed(Operation operation) {\n    return (_simulationConsumedGas(operation) + _gasBuffer);\n  }\n\n  int _simulationConsumedGas(Operation operation) {\n    return int.parse(_simulationResult(operation)['metadata']['operation_result']['consumed_gas'] as String);\n  }\n\n  Future<int> _originationDefaultSize(Operation operation) async {\n    return (await _rpcInterface(operation).constants())['origination_size'];\n  }\n\n  Map<String, dynamic> _simulationResult(Operation operation) {\n    if (operation.simulationResult == null) throw ArgumentError.notNull('operation.simulationResult');\n\n    return operation.simulationResult!;\n  }\n", "explanation": "Here is a concise summary:\n\nThis block of code contains five functions that retrieve and process data from a simulation result associated with an `Operation`. The functions calculate various metrics, such as gas consumption, storage size, and originations default size, making them useful for analyzing and executing smart contract operations.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operation/impl/operation_limits_setter_visitor.dart", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'lib/src/models/operation/impl/operation_limits_setter_visitor.dart':\n\n**Class: OperationLimitsSetterVisitor**\n\nSets gas and storage limits for operations based on type and custom limits, updating `gasLimit` and `storageLimit`. \n\nThis class extends the functionality to update operation limits."}
{"code": "  RpcInterface _rpcInterface(Operation operation) {\n    if (operation.operationsList == null) throw ArgumentError.notNull('operation.operationsList');\n\n    return operation.operationsList!.rpcInterface;\n  }\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Returns an RPC interface for a given operation.\n\n**Functionality:** Retrieves and returns the RPC interface associated with an operations list, throwing an error if the list is null or empty.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operation/impl/operation_limits_setter_visitor.dart", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'lib/src/models/operation/impl/operation_limits_setter_visitor.dart':\n\n**Class: OperationLimitsSetterVisitor**\n\nSets gas and storage limits for operations based on type and custom limits, updating `gasLimit` and `storageLimit`. \n\nThis class extends the functionality to update operation limits."}
{"code": "import 'operation.dart';\n\nabstract class OperationVisitor {\n  Future<void> visit(Operation operation);\n}\n", "explanation": "This block defines an abstract class `OperationVisitor` with a single method `visit`, which is intended to be used for visiting (processing) instances of the `Operation` class, returning a future indicating completion.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operation/impl/operation_visitor.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise holistic summary of the file 'lib/src/models/operation/impl/operation_visitor.dart':\n\n**Summary:** This file defines an abstract class `OperationVisitor` that enables visiting (processing) instances of the `Operation` class, returning a future upon completion."}
{"code": "import 'package:memoize/memoize.dart';\n\nimport 'operation.dart';\n\nclass OriginationOperation extends Operation {\n  OriginationOperation({\n    required int balance,\n    required List<Map<String, dynamic>> code,\n    required dynamic storage, // Micheline storage\n    int? customFee,\n    int? customGasLimit,\n    int? customStorageLimit,\n  }) : super(\n          kind: Kinds.origination,\n          balance: balance,\n          script: _script(code, storage),\n          customFee: customFee,\n          customGasLimit: customGasLimit,\n          customStorageLimit: customStorageLimit,\n        );\n\n  String get contractAddress {\n    return memo0<String>(() {\n      if (operationsList == null) throw ArgumentError.notNull('operation.operationsList');\n\n      // TODO: why does the node return a list of originated contracts ?\n      return operationsList!\n          .operations.first.simulationResult?['metadata']['operation_result']['originated_contracts'].first;\n    })();\n  }\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Represents an origination operation, which creates a new contract on a blockchain.\n\n**Functionality:** Extends the `Operation` class with properties and methods for origination operations, including generating a contract address from Micheline storage data.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operation/impl/origination_operation.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and to-the-point holistic summary of the file 'lib/src/models/operation/impl/origination_operation.dart':\n\nThis file represents an Origination Operation, which creates a new contract on a blockchain by extending the `Operation` class with properties and methods for origination operations. It generates a contract address from Micheline storage data and combines provided code and storage into a single map."}
{"code": "  static Map<String, dynamic> _script(List<Map<String, dynamic>> code, dynamic storage) {\n    return {'code': code, 'storage': storage};\n  }\n}\n", "explanation": "**Purpose:** Returns a map containing script data.\n\n**Functionality:** Combines provided code and storage into a single map.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operation/impl/origination_operation.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and to-the-point holistic summary of the file 'lib/src/models/operation/impl/origination_operation.dart':\n\nThis file represents an Origination Operation, which creates a new contract on a blockchain by extending the `Operation` class with properties and methods for origination operations. It generates a contract address from Micheline storage data and combines provided code and storage into a single map."}
{"code": "import 'package:tezart/tezart.dart';\n\nimport 'operation.dart';\n\nclass RevealOperation extends Operation {\n  RevealOperation({\n    int? customFee,\n    int? customGasLimit,\n    int? customStorageLimit,\n  }) : super(\n          kind: Kinds.reveal,\n          customFee: customFee,\n          customGasLimit: customGasLimit,\n          customStorageLimit: customStorageLimit,\n        );\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Defines a Reveal Operation class for Tezart.\n**Functionality:** Extends the Operation class with a specific kind (Reveal) and optional custom fees/gas/storage settings.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operation/impl/reveal_operation.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise holistic summary of the file 'lib/src/models/operation/impl/reveal_operation.dart':\n\n**Purpose:** RevealOperation class for Tezart, extending Operation with Reveal specifics and custom fee/settings options."}
{"code": "import 'operation.dart';\n\nclass TransactionOperation extends Operation {\n  TransactionOperation({\n    required int amount,\n    required String destination,\n    Map<String, dynamic>? params,\n    String? entrypoint,\n    int? customFee,\n    int? customGasLimit,\n    int? customStorageLimit,\n  }) : super(\n          kind: Kinds.transaction,\n          destination: destination,\n          params: params,\n          amount: amount,\n          entrypoint: entrypoint,\n          customFee: customFee,\n          customGasLimit: customGasLimit,\n          customStorageLimit: customStorageLimit,\n        );\n}\n", "explanation": "Here is a summary of the purpose and functionality of this block:\n\n**Purpose:** Define a transaction operation class.\n\n**Functionality:** Extends an \"Operation\" class with a transaction-specific implementation, allowing for creation of transactions with customizable parameters.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operation/impl/transaction_operation.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'lib/src/models/operation/impl/transaction_operation.dart':\n\nDefines a `TransactionOperation` class that extends the base `Operation` class, providing a transaction-specific implementation for creating customized transactions."}
{"code": "/// A library that handles single operation objects\n///\n/// It exposes:\n/// - [Operation]\n/// - [OriginationOperation]\n/// - [RevealOperation]\n/// - [TransactionOperation]\nlibrary operation;\n\nexport 'impl/operation.dart';\nexport 'impl/origination_operation.dart';\nexport 'impl/reveal_operation.dart';\nexport 'impl/transaction_operation.dart';\n", "explanation": "**Summary:**\n\nA library that provides a set of single-operation objects, including Operation, OriginationOperation, RevealOperation, and TransactionOperation, used for handling specific types of blockchain operations.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operation/operation.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n\"A Dart library providing models for various single blockchain operations.\""}
{"code": "import 'package:logging/logging.dart';\nimport 'package:retry/retry.dart';\nimport 'package:tezart/src/core/client/tezart_client.dart';\nimport 'package:tezart/src/core/rpc/rpc_interface.dart';\nimport 'package:tezart/src/keystore/keystore.dart';\nimport 'package:tezart/src/models/operation/impl/operation_fees_setter_visitor.dart';\nimport 'package:tezart/src/models/operation/impl/operation_hard_limits_setter_visitor.dart';\nimport 'package:tezart/src/models/operation/impl/operation_limits_setter_visitor.dart';\nimport 'package:tezart/src/models/operation/operation.dart';\nimport 'package:tezart/src/signature/signature.dart';\n\nimport 'operations_list_result.dart';\n\n/// A class that stores, simulates, estimates and broadcasts a list of [Operation]\n///\n/// - [operations] is the list of the operations of this\n/// - [result] is an object that stores the results of the different steps of this\n/// - [source] is the [Keystore] initiating the operations", "explanation": "Here is a concise summary:\n\n**Purpose:** This class manages a list of operations, storing, simulating, estimating, and broadcasting them.\n\n**Functionality:**\n\n* Stores a list of `Operation` objects\n* Simulates and estimates operation results\n* Broadcasts operations using the `Keystore` as source", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operations_list/impl/operations_list.dart", "chunk_number": 1, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/models/operations_list/impl/operations_list.dart':\n\n**Operations List Manager**\n\nThis class manages a list of operations, storing, simulating, estimating, and broadcasting them using the Tezos node via RPC interface.\n\n**Key Functions:**\n\n* Store and manage a list of `Operation` objects\n* Simulate and estimate operation results\n* Broadcast operations securely using the Keystore as source\n* Preapply, prepend/append, preapply with signature check, and forge operations\n* Compute optimal fees, monitor operations, and retry counter errors\n\n**Purpose:**\n\nManage a list of operations, interact with Tezos node via RPC interface, and perform various operations such as simulating, estimating, broadcasting, and computing fees."}
{"code": "/// - [rpcInterface] is the rpc interface that makes the calls to the tezos node\nclass OperationsList {\n  final log = Logger('Operation');\n  final List<Operation> operations = [];\n  final result = OperationsListResult();\n  final Keystore source;\n  final RpcInterface rpcInterface;\n\n  OperationsList({required this.source, required this.rpcInterface});\n\n  /// Prepends [op] to this\n  void prependOperation(Operation op) {\n    op.operationsList = this;\n    operations.insert(0, op);\n  }\n\n  /// Appends [op] to this\n  void appendOperation(Operation op) {\n    op.operationsList = this;\n    operations.add(op);\n  }\n\n  /// Preapplies this\n  ///\n  /// It must be run after [sign] because it needs result.signature to be set\n  /// It sets the simulationResult for all the elements of [operations]\n  Future<void> preapply() async {\n    await _catchHttpError<void>(() async {\n      if (result.signature == null) throw ArgumentError.notNull('result.signature');\n\n      final edsig = await result.signature!.edsig;\n", "explanation": "Here is a concise summary of the block:\n\n**Class: OperationsList**\n\n**Purpose:** Manage a list of operations, interact with Tezos node via RPC interface.\n\n**Functionality:** Prepend/append operations to the list, preapply operations (require result signature), and use Keystore for secure data storage.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operations_list/impl/operations_list.dart", "chunk_number": 2, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/models/operations_list/impl/operations_list.dart':\n\n**Operations List Manager**\n\nThis class manages a list of operations, storing, simulating, estimating, and broadcasting them using the Tezos node via RPC interface.\n\n**Key Functions:**\n\n* Store and manage a list of `Operation` objects\n* Simulate and estimate operation results\n* Broadcast operations securely using the Keystore as source\n* Preapply, prepend/append, preapply with signature check, and forge operations\n* Compute optimal fees, monitor operations, and retry counter errors\n\n**Purpose:**\n\nManage a list of operations, interact with Tezos node via RPC interface, and perform various operations such as simulating, estimating, broadcasting, and computing fees."}
{"code": "      final simulationResults = await rpcInterface.preapplyOperations(\n        operationsList: this,\n        signature: edsig,\n      );\n\n      for (var i = 0; i < simulationResults.length; i++) {\n        operations[i].simulationResult = simulationResults[i];\n      }\n    });\n  }\n\n  /// Runs this\n  ///\n  /// Same as [preapply] but without signature check\n  Future<void> run() async {\n    await _catchHttpError<void>(() async {\n      final simulationResults = await rpcInterface.runOperations(this);\n\n      for (var i = 0; i < simulationResults.length; i++) {\n        operations[i].simulationResult = simulationResults[i];\n      }\n    });\n  }\n\n  /// Forges this\n  ///\n  /// It sets result.forgedOperation\n  Future<void> forge() async {\n    await _catchHttpError<void>(() async {\n      result.forgedOperation = await rpcInterface.forgeOperations(this);\n    });\n  }\n\n  /// Signs this\n  ///\n  /// It sets result.signature\\\n  /// It must be run after [forge], because it needs result.forgedOperation to be set\n  void sign() {", "explanation": "Here is a summary of the purpose and functionality of these blocks:\n\n**Summary**\n\nThese blocks appear to be methods for managing operations in a blockchain or cryptocurrency context.\n\n**Purpose:**\n\n1. `preapply`: Preapplies a list of operations without checking signatures.\n2. `run`: Runs a list of operations, similar to `preapply`, but without signature check.\n3. `forge`: Forges a set of operations, setting `result.forgedOperation`.\n4. `sign`: Signs a forged operation, requiring `result.forgedOperation` to be set.\n\n**Functionality:**\n\nEach method performs an asynchronous operation using the `rpcInterface` and updates the `operations` list with simulation results or sets `result.forgedOperation`.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operations_list/impl/operations_list.dart", "chunk_number": 3, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/models/operations_list/impl/operations_list.dart':\n\n**Operations List Manager**\n\nThis class manages a list of operations, storing, simulating, estimating, and broadcasting them using the Tezos node via RPC interface.\n\n**Key Functions:**\n\n* Store and manage a list of `Operation` objects\n* Simulate and estimate operation results\n* Broadcast operations securely using the Keystore as source\n* Preapply, prepend/append, preapply with signature check, and forge operations\n* Compute optimal fees, monitor operations, and retry counter errors\n\n**Purpose:**\n\nManage a list of operations, interact with Tezos node via RPC interface, and perform various operations such as simulating, estimating, broadcasting, and computing fees."}
{"code": "    if (result.forgedOperation == null) throw ArgumentError.notNull('result.forgedOperation');\n\n    result.signature = Signature.fromHex(\n      data: result.forgedOperation!,\n      keystore: source,\n      watermark: Watermarks.generic,\n    );\n  }\n\n  /// Injects this\n  ///\n  /// It must be run after [sign] because it needs result.signature to be set\n  Future<void> inject() async {\n    await _catchHttpError<void>(() async {\n      if (result.signature == null) throw ArgumentError.notNull('result.signature');\n\n      final signatureWithPayload = await result.signature!.hexIncludingPayload;\n\n      result.id = await rpcInterface.injectOperation(signatureWithPayload);\n    });\n  }\n\n  /// Waits for this to be executed and monitored\n  ///\n  /// It throws a [TezartNodeError] or a [TezartHttpError] if any error happens\n  Future<void> executeAndMonitor() async {\n    await execute();\n    await monitor();\n  }\n\n  /// Executes this\n  ///\n  /// It runs [estimate], [simulate] and [broadcast] respectively\n  Future<void> execute() async {", "explanation": "Here is a concise summary:\n\nThis block performs the following functions:\n\n1. **Initialization**: Checks if `result.forgedOperation` is not null, sets `result.signature`, and then throws errors if either check fails.\n2. **Injection**: Injects an operation into the blockchain using the previously set signature, throwing errors if any issues occur.\n3. **Execution and Monitoring**: Executes an operation by running estimate, simulate, and broadcast steps in sequence, and monitors its status, throwing errors if any issues occur during execution or monitoring.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operations_list/impl/operations_list.dart", "chunk_number": 4, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/models/operations_list/impl/operations_list.dart':\n\n**Operations List Manager**\n\nThis class manages a list of operations, storing, simulating, estimating, and broadcasting them using the Tezos node via RPC interface.\n\n**Key Functions:**\n\n* Store and manage a list of `Operation` objects\n* Simulate and estimate operation results\n* Broadcast operations securely using the Keystore as source\n* Preapply, prepend/append, preapply with signature check, and forge operations\n* Compute optimal fees, monitor operations, and retry counter errors\n\n**Purpose:**\n\nManage a list of operations, interact with Tezos node via RPC interface, and perform various operations such as simulating, estimating, broadcasting, and computing fees."}
{"code": "    await _retryOnCounterError<void>(() async {\n      await estimate();\n      await simulate();\n      await broadcast();\n    });\n  }\n\n  /// Broadcasts this\n  ///\n  /// It runs [forge], [sign] and [inject] respectively\n  Future<void> broadcast() async {\n    await forge();\n    sign();\n    await inject();\n  }\n\n  /// Estimates this\n  ///\n  /// It sets the counters of the different operations, and computes the limits and the fees of this\n  Future<void> estimate() async {\n    await computeCounters();\n    await computeLimits();\n    await computeFees();\n  }\n\n  /// Sets the limits of this\n  Future<void> computeLimits() async {\n    await setHardLimits();\n    await simulate();\n    await setLimits();\n  }\n\n  /// Simulates the execution of this using a preapply\n  ///\n  /// It throws an error if anything wrong happens\n  Future<void> simulate() async {\n    await forge();\n    sign();\n    await preapply();\n  }\n\n  /// Computes and sets the counters of [operations]\n  Future<void> computeCounters() async {", "explanation": "**Summary:**\n\nThis block is a retry mechanism that calls a series of asynchronous functions (estimate, simulate, and broadcast) if an error occurs during counter operation computation.\n\n* `broadcast`: Runs three functions (forge, sign, and inject) in sequence.\n* `estimate`: Computes counters, limits, and fees by calling other functions.\n* `computeLimits`: Sets hard limits and calls simulation to compute actual limits.\n* `simulate`: Simulates execution using a preapply method, throwing an error if anything goes wrong.\n* `_retryOnCounterError`: A retry mechanism that calls the above functions if counter operation computation fails.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operations_list/impl/operations_list.dart", "chunk_number": 5, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/models/operations_list/impl/operations_list.dart':\n\n**Operations List Manager**\n\nThis class manages a list of operations, storing, simulating, estimating, and broadcasting them using the Tezos node via RPC interface.\n\n**Key Functions:**\n\n* Store and manage a list of `Operation` objects\n* Simulate and estimate operation results\n* Broadcast operations securely using the Keystore as source\n* Preapply, prepend/append, preapply with signature check, and forge operations\n* Compute optimal fees, monitor operations, and retry counter errors\n\n**Purpose:**\n\nManage a list of operations, interact with Tezos node via RPC interface, and perform various operations such as simulating, estimating, broadcasting, and computing fees."}
{"code": "    // TODO: use expirable cache based on time between blocks so that we can\n    // call this method before forge, sign, preapply and run\n    await _catchHttpError<void>(() async {\n      final firstOperation = operations.first;\n      firstOperation.counter = await rpcInterface.counter(source.address) + 1;\n\n      for (var i = 1; i < operations.length; i++) {\n        operations[i].counter = operations[i - 1].counter! + 1;\n      }\n    });\n  }\n\n  /// It sets the limits of [operations] to the hard limits of the chain\n  Future<void> setHardLimits() async {\n    await Future.wait(operations.map((operation) async {\n      await operation.setLimits(OperationHardLimitsSetterVisitor());\n    }));\n  }\n\n  /// It sets the optimal limits of [operations]\n  Future<void> setLimits() async {\n    await Future.wait(operations.map((operation) async {\n      await operation.setLimits(OperationLimitsSetterVisitor());\n    }));\n\n    // resimulate to check that limit computation is valid. Remove this in a stable version ??", "explanation": "Here is a concise summary:\n\nThis block of code sets the counters and limits for a list of operations, using RPC interface calls to get the counter values from the chain. It has two methods: `setHardLimits` to set hard limits based on chain rules, and `setLimits` to set optimal limits, with optional resimulation validation.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operations_list/impl/operations_list.dart", "chunk_number": 6, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/models/operations_list/impl/operations_list.dart':\n\n**Operations List Manager**\n\nThis class manages a list of operations, storing, simulating, estimating, and broadcasting them using the Tezos node via RPC interface.\n\n**Key Functions:**\n\n* Store and manage a list of `Operation` objects\n* Simulate and estimate operation results\n* Broadcast operations securely using the Keystore as source\n* Preapply, prepend/append, preapply with signature check, and forge operations\n* Compute optimal fees, monitor operations, and retry counter errors\n\n**Purpose:**\n\nManage a list of operations, interact with Tezos node via RPC interface, and perform various operations such as simulating, estimating, broadcasting, and computing fees."}
{"code": "    await simulate();\n  }\n\n  /// It sets the optimal fees of [operations]\n  ///\n  /// The computation is based on the bakers default config.\n  Future<void> computeFees() async {\n    await Future.wait(operations.map((operation) async {\n      await operation.setLimits(OperationFeesSetterVisitor());\n    }));\n  }\n\n  /// Monitors this\n  Future<void> monitor() async {\n    if (result.id == null) throw ArgumentError.notNull('result.id');\n\n    log.info('request to monitorOperation ${result.id}');\n    final blockHash = await rpcInterface.monitorOperation(operationId: result.id!);\n    result.blockHash = blockHash;\n  }\n\n  Future<T> _catchHttpError<T>(Future<T> Function() func) {\n    return catchHttpError<T>(func, onError: (TezartHttpError e) {\n      log.severe('Http Error', e);\n    });\n  }\n\n  Future<T> _retryOnCounterError<T>(func) {\n    final r = RetryOptions(maxAttempts: 5);\n    return r.retry<T>(\n      func,\n      retryIf: (e) => e is TezartNodeError && e.type == TezartNodeErrorTypes.counterError,\n    );\n  }\n}\n", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Summary:** This block provides methods for computing optimal fees, monitoring operations, and retrying counter errors.\n\n**Methods:**\n\n* `computeFees`: Sets optimal fees for operations based on baker's default config.\n* `monitor`: Monitors an operation and logs its block hash.\n* `_catchHttpError` and `_retryOnCounterError`: Helper functions to catch HTTP errors and retry counter errors.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operations_list/impl/operations_list.dart", "chunk_number": 7, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'lib/src/models/operations_list/impl/operations_list.dart':\n\n**Operations List Manager**\n\nThis class manages a list of operations, storing, simulating, estimating, and broadcasting them using the Tezos node via RPC interface.\n\n**Key Functions:**\n\n* Store and manage a list of `Operation` objects\n* Simulate and estimate operation results\n* Broadcast operations securely using the Keystore as source\n* Preapply, prepend/append, preapply with signature check, and forge operations\n* Compute optimal fees, monitor operations, and retry counter errors\n\n**Purpose:**\n\nManage a list of operations, interact with Tezos node via RPC interface, and perform various operations such as simulating, estimating, broadcasting, and computing fees."}
{"code": "import 'package:tezart/src/signature/signature.dart';\n\n/// A class that stores the result of an [OperationsList] object\n///\n/// - [forgedOperation] is the forge of the operations list\n/// - [signature] is the signature of the operations list\n/// - [id] is the operation group id. It is computed after the monitoring of the operations list\n/// - [blockHash] is the hash of the block that included the operation. It is computer after the monitoring of the operations list\nclass OperationsListResult {\n  String? forgedOperation;\n  Signature? signature;\n  String? id;\n  String? blockHash;\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Stores result of an `OperationsList` object.\n\n**Functionality:** Contains key data from the operations list, including forge operation, signature, ID, and block hash.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operations_list/impl/operations_list_result.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'lib/src/models/operations_list/impl/operations_list_result.dart':\n\n**Summary:** The `OperationsListResult` model stores key data from an operations list, including forge operation details."}
{"code": "/// A library that handles a group of operations\n///\n/// It exposes:\n/// - [OperationsList]\n/// - [OperationsListResult]\nlibrary operations_list;\n\nexport 'impl/operations_list.dart';\nexport 'impl/operations_list_result.dart';\n", "explanation": "This block defines a library called \"operations_list\" that provides functionality for handling a group of operations, exposing classes and results related to them.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/models/operations_list/operations_list.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary of the file 'lib/src/models/operations_list/operations_list.dart':\n\n**File Summary:**\n`operations_list.dart`: A library providing functionality for handling a collection of operations, offering related classes and result data."}
{"code": "import 'package:blockchain_signer/signer/response/signed_result.dart';\nimport 'package:convert/convert.dart';\nimport 'package:equatable/equatable.dart';\nimport 'package:meta/meta.dart';\nimport 'package:pinenacl/ed25519.dart';\nimport 'package:tezart/src/common/validators/hex_validator.dart';\nimport 'package:tezart/src/keystore/keystore.dart';\n\nimport 'package:tezart/src/crypto/crypto.dart' as crypto;\n\nenum Watermarks {\n  block,\n  endorsement,\n  generic,\n}\n\n/// A class that takes data of different types and signs it using a [Keystore] object.\\\n///\n/// It can sign bytes and hexadecimal data.\\\n/// The signature is computed in different formats:\n/// - [signedBytes]: signed bytes\n/// - [edsig]: base 58 encoded using 'edsig' prefix\n/// - [hexIncludingPayload]: hexadecimal signature prefixed by data to sign\n@immutable\nclass Signature extends Equatable {\n  final Uint8List bytes;\n  final Keystore keystore;\n  final Watermarks? watermark;\n\n  static final watermarkToHex = {\n    Watermarks.block: '01',", "explanation": "**Summary**\n\nThis block defines a `Signature` class that signs data of various types using a `Keystore` object, producing signatures in different formats (bytes, base58-encoded, or hexadecimal with payload).", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/signature/impl/signature.dart", "chunk_number": 1, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a holistic summary of the file 'lib/src/signature/impl/signature.dart':\n\n**Summary**\n\nThis module defines the `Signature` class, which generates digital signatures from various data types using a `Keystore`. It provides methods for computing signatures from bytes or hexadecimal data, with validation and error handling. The class returns signatures in different formats (bytes, base58-encoded, or hexadecimal with payload)."}
{"code": "    Watermarks.endorsement: '02',\n    Watermarks.generic: '03',\n  };\n\n  Signature._({required this.bytes, required this.keystore, this.watermark});\n\n  /// A factory that computes the signature of [bytes] (prefixed by [watermark]) using [keystore].\n  ///\n  /// [watermark] is optional and will be ignored if missing.\n  factory Signature.fromBytes({required Uint8List bytes, required Keystore keystore, Watermarks? watermark}) {\n    return Signature._(bytes: bytes, watermark: watermark, keystore: keystore);\n  }\n\n  /// A factory that computes the signature of hexadecimal [data] (prefixed by [watermark]) using [keystore].\\\n  ///\n  /// [watermark] is optional and will be ignored if missing.\\\n  /// Throws a [CryptoError] if :\n  /// - [data] is not hexadecimal\n  /// - [data] length is odd (because it must be the hexadecimal of a list of bytes (a single byte represent two hexadecimal digits))\n  factory Signature.fromHex({required String data, required Keystore keystore, Watermarks? watermark}) {", "explanation": "Here is a concise summary:\n\nThis block defines a class `Signature` that generates digital signatures using a `Keystore`. It provides factories to compute signatures from bytes or hexadecimal data, optionally prefixed with a watermark, and throws an error if invalid input is provided.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/signature/impl/signature.dart", "chunk_number": 2, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a holistic summary of the file 'lib/src/signature/impl/signature.dart':\n\n**Summary**\n\nThis module defines the `Signature` class, which generates digital signatures from various data types using a `Keystore`. It provides methods for computing signatures from bytes or hexadecimal data, with validation and error handling. The class returns signatures in different formats (bytes, base58-encoded, or hexadecimal with payload)."}
{"code": "    return crypto.catchUnhandledErrors(() {\n      HexValidator(data).validate();\n      // Because two hexadecimal digits correspond to a single byte, this will throw an error if the length of the data is odd\n      if (data.length.isOdd) {\n        throw crypto.CryptoError(type: crypto.CryptoErrorTypes.invalidHexDataLength);\n      }\n      var bytes = crypto.hexDecode(data);\n\n      return Signature.fromBytes(bytes: bytes, keystore: keystore, watermark: watermark);\n    });\n  }\n\n  /// Signed bytes of this.\n  Future<ByteList> get signedBytes async {\n    return crypto.catchUnhandledErrors(() async {\n      final watermarkedBytes =\n          watermark == null ? bytes : Uint8List.fromList(crypto.hexDecode(watermarkToHex[watermark]!) + bytes);\n\n      if (keystore.signer != null) {\n        SignedResult res = await keystore.signer?.sign(hex.encode(bytes), Uint8List.fromList(crypto.hexDecode(watermarkToHex[watermark]!))) as SignedResult;\n\n        /// sbytes from Taquito remoteSign is in the format of bytes+signature,", "explanation": "Here is a concise summary:\n\n**Purpose:** Validates hexadecimal data and returns a signature.\n\n**Functionality:**\n\n* Validates hexadecimal data using `HexValidator`.\n* Checks if the data length is odd and throws an error if so.\n* Decodes the hexadecimal data to bytes.\n* Signs the bytes with a keystore (if available) and returns the signed bytes.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/signature/impl/signature.dart", "chunk_number": 3, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a holistic summary of the file 'lib/src/signature/impl/signature.dart':\n\n**Summary**\n\nThis module defines the `Signature` class, which generates digital signatures from various data types using a `Keystore`. It provides methods for computing signatures from bytes or hexadecimal data, with validation and error handling. The class returns signatures in different formats (bytes, base58-encoded, or hexadecimal with payload)."}
{"code": "        /// extract the signature out and return\n        String signedBytesHex = res.sbytes.replaceAll(res.bytes, '');\n        final signedBytesInList = hex.decode(signedBytesHex);\n        final signed = SignedMessage.fromList(signedMessage: Uint8List.fromList(signedBytesInList));\n        return signed;\n      }\n\n      var hashedBytes = crypto.hashWithDigestSize(size: 256, bytes: watermarkedBytes);\n      var secretKey = keystore.secretKey;\n      var secretKeyBytes = crypto.decodeWithoutPrefix(secretKey);\n      var signed = crypto.signDetached(\n          bytes: hashedBytes, secretKey: secretKeyBytes);\n      return signed;\n    });\n  }\n\n  /// Base 58 encoding of this using 'edsig' prefix.\n  Future<String> get edsig {\n    return crypto.catchUnhandledErrors(() async {\n      return crypto.encodeWithPrefix(prefix: crypto.Prefixes.edsig, bytes: Uint8List.fromList((await signedBytes).toList()));\n    });\n  }\n\n  /// Hexadecimal signature of this prefixed with hexadecimal payload to sign.", "explanation": "Here is a concise summary:\n\nThis block extracts a digital signature from a message, hashes it, signs it with a secret key, and returns the signed result in two formats: \n\n1. A hex-encoded string (`edsig`) \n2. A hexadecimal signature of the hashed bytes, prefixed with the hexadecimal payload to sign.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/signature/impl/signature.dart", "chunk_number": 4, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a holistic summary of the file 'lib/src/signature/impl/signature.dart':\n\n**Summary**\n\nThis module defines the `Signature` class, which generates digital signatures from various data types using a `Keystore`. It provides methods for computing signatures from bytes or hexadecimal data, with validation and error handling. The class returns signatures in different formats (bytes, base58-encoded, or hexadecimal with payload)."}
{"code": "  Future<String> get hexIncludingPayload {\n    return crypto.catchUnhandledErrors(() async {\n      return crypto.hexEncode(Uint8List.fromList(bytes + (await signedBytes)));\n    });\n  }\n\n  @override\n  List<Object> get props => [signedBytes];\n}\n", "explanation": "Here is a summary of the purpose and functionality:\n\n**Summary**\n\nThis block generates a hexadecimal string representation of data, including payload bytes that are dynamically loaded. It also returns a future (promised value) that can be used for asynchronous operations. The generated hex string is encoded using the `crypto.hexEncode` function.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/signature/impl/signature.dart", "chunk_number": 5, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a holistic summary of the file 'lib/src/signature/impl/signature.dart':\n\n**Summary**\n\nThis module defines the `Signature` class, which generates digital signatures from various data types using a `Keystore`. It provides methods for computing signatures from bytes or hexadecimal data, with validation and error handling. The class returns signatures in different formats (bytes, base58-encoded, or hexadecimal with payload)."}
{"code": "/// A library that export the classes related to signatures\nlibrary signature;\n\nexport 'impl/signature.dart';\n", "explanation": "This block is a Dart library declaration that exports a class related to signatures from a file named \"signature.dart\".", "metadata": {"repo": "magiclabs/tezart", "file": "lib/src/signature/signature.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and to-the-point summary:\n\n**Signature Library**\n\nExports the `Signature` class from `lib/src/signature/signature.dart`."}
{"code": "/// Top level library, exposes all the public classes and methods.\n///\n/// Exposes:\n/// - [Keystore]\n/// - [CryptoError]\n/// - [Signature]\n/// - [TezartClient]\n/// - [TezartNodeError]\n/// - [enableTezartLogger]\n/// - [enableTezartDevLogs]\n/// - [Contract]\n/// - [MichelineDecoder]\n/// - [MichelineEncoder]\n/// - [RpcInterface]\n/// - [TezartHttpError]\n\nlibrary tezart;\n\nexport 'src/models/operation/operation.dart';\nexport 'src/models/operations_list/operations_list.dart';\nexport 'src/keystore/keystore.dart';\nexport 'src/signature/signature.dart';\nexport 'src/core/client/tezart_client.dart';\nexport 'src/common/logger/common_logger.dart';\nexport 'src/contracts/contract.dart';\nexport 'src/micheline_decoder/micheline_decoder.dart';\nexport 'src/micheline_encoder/micheline_encoder.dart';\nexport 'src/core/rpc/rpc_interface.dart';\n", "explanation": "Here is a concise summary:\n\nThis block is a Dart library that exposes various classes and methods for working with Tezart, including keystore, crypto, signatures, clients, contract management, and logging. It serves as a top-level API for accessing all public functionality of the Tezart library.", "metadata": {"repo": "magiclabs/tezart", "file": "lib/tezart.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\nThe `lib/tezart.dart` file provides a comprehensive Dart library for interacting with Tezart, offering classes and methods for key management, cryptography, signatures, clients, contract management, and logging."}
{"code": "name: tezart\ndescription: A Dart library to connect to Tezos clients. Send transactions and interact with smart contracts!\nversion: 2.0.5\nhomepage: https://moneytrackio.github.io/tezart/\nrepository: https://github.com/moneytrackio/tezart\nissue_tracker: https://github.com/moneytrackio/tezart/issues\n\nenvironment:\n  sdk: \">=2.12.0 <3.0.0\"\n\ndependencies:\n  bs58check: ^1.0.2 # implementation of base58check\n  bip39: ^1.0.6 # Mnemonic code for generating deterministic keys\n  pointycastle: ^3.0.1 # a library that implements popular crypto algorithms\n  convert: ^3.0.0 # Encoders and decoders for converting between different data representations\n  dio: ^4.0.0 # http client\n  equatable: ^2.0.0\n  pinenacl: ^0.5.1 # Dart implementation of TweetNacl\n  json_serializable: ^6.1.4 # code generation for toJson and fromJson methods\n  json_annotation: ^4.4.0 # Classes and helper functions that support JSON code generation via the `json_serializable` package.\n  retry: ^3.1.0 # retry a function if an error happens", "explanation": "**Tezart Library Summary**\n\nPurpose: A Dart library for interacting with Tezos clients, enabling transaction sending and smart contract interaction.\n\nFunctionality: Provides functionality for:\n\n* Connecting to Tezos clients\n* Sending transactions\n* Interacting with smart contracts\n* Utilizing various cryptographic algorithms and data conversion utilities.", "metadata": {"repo": "magiclabs/tezart", "file": "pubspec.yaml", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'pubspec.yaml':\n\n**Summary**\n\nThis `pubspec.yaml` file specifies dependencies for a Dart project utilizing the Tezart library for interacting with Tezos clients, as well as various development tools and utilities for building, testing, and debugging the project."}
{"code": "  memoize: ^3.0.0 # memoize method calls\n  logging: ^1.0.1 # official dart team : Provides APIs for debugging and error logging.\n  ansicolor: ^2.0.1 # Use AnsiPen to add ANSI color codes to your log messages.\n  collection: ^1.15.0 # Collections and utilities functions and classes related to collections\n  quiver: ^3.0.1 # used to zip two lists\n  meta: ^1.3.0\n  pretty_dio_logger: ^1.1.1\n  blockchain_signer: 0.1.0 # Remote Signer\n\ndev_dependencies:\n  lints: ^1.0.1 # linter\n  build_runner: ^2.0.0\n  mockito: ^5.1.0 # mocks\n  test: ^1.20.1\n  envify: ^2.0.0 # .env files management\n  envify_generator: ^2.0.0 # code generation for envify\n", "explanation": "**Development Dependencies Summary**\n\nThis block lists development dependencies for a project, including:\n\n* Linting tools (linter)\n* Build and test utilities (build_runner, mockito, test)\n* Environmental variables management (envify, envify_generator)\n* Debugging and logging libraries (logging, ansicolor, pretty_dio_logger)\n* Memoization and utility functions (memoize, collection, quiver)", "metadata": {"repo": "magiclabs/tezart", "file": "pubspec.yaml", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a holistic summary of the file 'pubspec.yaml':\n\n**Summary**\n\nThis `pubspec.yaml` file specifies dependencies for a Dart project utilizing the Tezart library for interacting with Tezos clients, as well as various development tools and utilities for building, testing, and debugging the project."}
{"code": "import 'package:logging/logging.dart';\nimport 'package:test/test.dart';\nimport 'package:tezart/src/common/logger/common_logger.dart';\n\nvoid main() {\n  test('gets recorded to LogRecord', () {\n    enableTezartLogger(level: Level.FINE);\n    var records = <LogRecord>[];\n    var sub = Logger.root.onRecord.listen(records.add);\n\n    Logger.root.log(Level.INFO, 'info');\n    Logger.root.log(Level.WARNING, 'warning');\n    Logger.root.log(Level.SEVERE, 'severe');\n    Logger.root.log(Level.SHOUT, 'default');\n    sub.cancel();\n    expect(records, hasLength(4));\n  });\n}\n", "explanation": "This block is a test suite that verifies the functionality of a logger in a Tezart application, specifically checking if log messages are correctly recorded at different levels (INFO, WARNING, SEVERE, DEFAULT).", "metadata": {"repo": "magiclabs/tezart", "file": "test/common/logger/common_logger_test.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n`test/common/logger/common_logger_test.dart`: A test suite that verifies the correct recording of log messages across various levels (INFO, WARNING, SEVERE, DEFAULT) in a Tezart application's logger."}
{"code": "import 'package:test/test.dart';\nimport 'package:tezart/src/common/utils/enum_util.dart';\n\nenum MonEnum {\n  generic,\n  transaction,\n}\n\nvoid main() {\n  group('.stringToEnum', () {\n    group('when the value exists', () {\n      test('it returns the enum', () {\n        final value = EnumUtil.stringToEnum(MonEnum.values, 'generic');\n        expect(value, MonEnum.generic);\n      });\n    });\n\n    group('when the value doesnt exist', () {\n      test('it raises a StateError', () {\n        expect(\n          () => EnumUtil.stringToEnum(MonEnum.values, 'pouet'),\n          throwsA(predicate((e) => e is StateError)),\n        );\n      });\n    });\n  });\n\n  test('.enumToString', () {\n    final value = EnumUtil.enumToString(MonEnum.transaction);\n    expect(value, 'transaction');\n  });\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Test utility functions for working with enums.\n\n**Functionality:**\n\n* `stringToEnum`: Converts a string to an enum value (or throws an error if not found).\n* `enumToString`: Converts an enum value to a string.\n* Tests these functions with the `MonEnum` enum.", "metadata": {"repo": "magiclabs/tezart", "file": "test/common/utils/enumutil_test.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**Purpose:** Test utility functions for enum conversions in `test/common/utils/enumutil_test.dart`.\n\nIt contains tests for `stringToEnum` and `enumToString` functions using the `MonEnum` enum, ensuring correct conversion between string and enum values."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nimport 'package:test/test.dart';\nimport 'package:tezart/src/common/utils/list_extension.dart';\n\nvoid main() {\n  group('.flatten', () {\n    final subject = (List arr) => arr.flatten<int>();\n\n    group('when the array is already flattened', () {\n      final arr = [1, 2, 3];\n\n      test('it returns the same array', () {\n        expect(subject(arr), equals(arr));\n      });\n    });\n\n    group('when the array is not flattened', () {\n      final arr = [\n        1,\n        [\n          2,\n          [3, 4],\n          5\n        ],\n        [6, 7]\n      ];\n\n      test('it returns a flattened array', () {\n        expect(subject(arr), equals([1, 2, 3, 4, 5, 6, 7]));\n      });\n\n      test('it casts the type', () {\n        expect(subject(arr), isA<List<int>>());\n      });\n    });\n  });\n}\n", "explanation": "This block defines a unit test for a function called `flatten` that takes a nested list of integers and returns a flattened list of integers, maintaining its original type.", "metadata": {"repo": "magiclabs/tezart", "file": "test/common/utils/list_extension_test.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'test/common/utils/list_extension_test.dart':\n\n\"This unit test suite verifies the correctness of the `flatten` function, which extends lists with a method to recursively flatten nested lists into a single list.\""}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nimport 'package:test/test.dart';\nimport 'package:tezart/src/common/utils/map_extension.dart';\n\nvoid main() {\n  group('.fetch', () {\n    final subject = (Map map, String key) => map.fetch<String>(key);\n\n    group('when the key exists', () {\n      final map = {'toto': 'tata'};\n      final key = 'toto';\n\n      test('it returns the value', () {\n        expect(subject(map, key), equals(map[key]));\n      });\n    });\n\n    group('when the key doesnt exist', () {\n      final map = {'404': 'tata'};\n      final key = 'toto';\n\n      test('it throws an error', () {\n        expect(() => subject(map, key),\n            throwsA(predicate((e) => e is ArgumentError && e.toString() == 'Invalid argument: \"$key\"')));\n      });\n    });\n  });\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Test the `.fetch` method of `MapExtension`.\n\n**Functionality:** Verifies that the method returns the value when key exists, and throws an error when key doesn't exist.", "metadata": {"repo": "magiclabs/tezart", "file": "test/common/utils/map_extension_test.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise and to-the-point holistic summary of the file 'test/common/utils/map_extension_test.dart':\n\n**Summary:** This test file validates the `.fetch` method of `MapExtension`, ensuring it correctly returns values for existing keys and throws errors for non-existent ones."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\n@Tags([\"unstable\"])\n\nimport 'package:test/test.dart';\nimport 'package:tezart/tezart.dart';\n\nimport '../env/env.dart';\nimport '../test_utils/test_contract_script.dart';\nimport '../test_utils/test_client.dart';\n\nvoid main() {\n  final tezart = testClient();\n  final rpcInterface = tezart.rpcInterface;\n  final source = Keystore.fromSecretKey(Env.originatorSk);\n  const balance = 10;\n  late String contractAddress;\n\n  final originateContract = (List<Map<String, dynamic>> code, dynamic storage) async {\n    final operationsList = await tezart.originateContractOperation(\n      source: source,\n      code: code,\n      storage: storage,\n      balance: balance,\n    );\n    await operationsList.executeAndMonitor();\n    final originationOperation = operationsList.operations.last as OriginationOperation;\n    contractAddress = originationOperation.contractAddress;\n  };\n\n  group('#fetch', () {\n    late Contract contract;\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Unit test suite for a Tezos contract using the Tezart library.\n\n**Functionality:** Tests the `#fetch` functionality of a contract by originating it, executing an operation, and monitoring its execution, with various variables and functions imported from other files.", "metadata": {"repo": "magiclabs/tezart", "file": "test/contracts/big_map_test.dart", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and to-the-point holistic summary:\n\n**test/contracts/big_map_test.dart:** Unit test suite for Tezos contract functionality, specifically testing `BigMap` retrieval by verifying correct value return and error handling when key exists or not."}
{"code": "    group('when the contract storage is a big map', () {\n      setUp(() async {\n        await originateContract(bigMapContract, []);\n        contract = Contract(contractAddress: contractAddress, rpcInterface: rpcInterface);\n        final operationsList = await contract.callOperation(\n          source: source,\n          params: {'my_key': 'key', 'my_val': 'val'},\n        );\n        await operationsList.executeAndMonitor();\n      });\n\n      final subject = (String key) async {\n        final BigMap bigMap = (await contract.storage);\n        return bigMap.fetch(key: key, rpcInterface: rpcInterface);\n      };\n\n      group('when the key exists', () {\n        test('it returns the value', () async {\n          expect(await subject('key'), 'val');\n        });\n      });\n\n      group('when the key doesnt exist', () {\n        test('it throws an error', () async {\n          expect(subject('unexistant'), throwsA(predicate((e) => e is TezartHttpError && e.message == 'Not Found')));\n        });\n      });\n    });\n", "explanation": "**Purpose:** Test BigMap contract functionality.\n\n**Functionality:**\n\n* Originates a contract with a big map storage.\n* Verifies that:\n\t+ When a key exists, it returns the associated value.\n\t+ When a key does not exist, it throws an error.", "metadata": {"repo": "magiclabs/tezart", "file": "test/contracts/big_map_test.dart", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and to-the-point holistic summary:\n\n**test/contracts/big_map_test.dart:** Unit test suite for Tezos contract functionality, specifically testing `BigMap` retrieval by verifying correct value return and error handling when key exists or not."}
{"code": "    group('when the contract storage contains multiple structures', () {\n      setUp(() async {\n        await originateContract(multipleStructuresContract, {\n          'prim': 'Pair',\n          'args': [\n            [],\n            {\n              'prim': 'Pair',\n              'args': [[], []]\n            }\n          ]\n        });\n        contract = Contract(contractAddress: contractAddress, rpcInterface: rpcInterface);\n        final operationsList = await contract.callOperation(\n          source: source,\n          params: {'my_key': 'key', 'my_val': 'val'},\n        );\n        await operationsList.executeAndMonitor();\n      });\n\n      final subject = (String key) async {\n        final BigMap bigMap = (await contract.storage)['my_big_map'];\n        return bigMap.fetch(key: key, rpcInterface: rpcInterface);\n      };\n\n      test('it returns the value', () async {\n        expect(await subject('key'), 'val');\n      });\n    });\n  });\n}\n", "explanation": "**Summary**\n\nThis block tests a contract function that retrieves a value from a BigMap (a type of smart contract storage) using a specific key, verifying it returns the expected result.", "metadata": {"repo": "magiclabs/tezart", "file": "test/contracts/big_map_test.dart", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and to-the-point holistic summary:\n\n**test/contracts/big_map_test.dart:** Unit test suite for Tezos contract functionality, specifically testing `BigMap` retrieval by verifying correct value return and error handling when key exists or not."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n@Tags([\"unstable\"])\n\nimport 'package:test/test.dart';\nimport 'package:tezart/tezart.dart';\n\nimport '../env/env.dart';\nimport '../test_utils/test_contract_script.dart';\nimport '../test_utils/test_client.dart';\n\nvoid main() {\n  final tezart = testClient();\n  final rpcInterface = tezart.rpcInterface;\n  final source = Keystore.fromSecretKey(Env.originatorSk);\n  const balance = 10;\n  late String contractAddress;\n\n  final originateContractSetUp = (List<Map<String, dynamic>> code, dynamic storage) async {\n    final operationsList = await tezart.originateContractOperation(\n      source: source,\n      code: code,\n      storage: storage,\n      balance: balance,\n    );\n    await operationsList.executeAndMonitor();\n    final originationOperation = operationsList.operations.last as OriginationOperation;\n    contractAddress = originationOperation.contractAddress;\n  };\n\n  group('#balance', () {\n    final subject = () => Contract(", "explanation": "Here is a concise summary:\n\n**Purpose:** This block contains test code for a Tezos-based contract.\n\n**Functionality:** It sets up a test client, originates a contract with a specified balance, and provides a group of tests related to balance verification.", "metadata": {"repo": "magiclabs/tezart", "file": "test/contracts/contract_test.dart", "chunk_number": 1, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise and holistic summary of the file 'test/contracts/contract_test.dart':\n\n**Purpose:** This test file validates the functionality of various contract-related methods, including balance verification, storage retrieval, entrypoints, and smart contract operations.\n\n**Key Features:**\n\n* Tests the `balance` method to ensure correct balance retrieval\n* Verifies the `storage` method's behavior for existing and non-existent contracts\n* Validates the `entrypoints` method to ensure correct entrypoint retrieval and error handling\n* Tests a smart contract's operation execution, including data fetching from a BigMap and storage updates"}
{"code": "          contractAddress: contractAddress,\n          rpcInterface: rpcInterface,\n        ).balance;\n\n    group('when the contract exists', () {\n      setUp(() async {\n        await originateContractSetUp(storeValueContract, {'int': '12'});\n      });\n\n      test('it returns the balance of the contract', () async {\n        expect(await subject(), balance);\n      });\n    });\n\n    group('when the contract address doesnt exist', () {\n      setUp(() {\n        contractAddress = 'KT1MkEVtQRWU6Lz5buqsZc5sdXbwprc1ep9b';\n      });\n\n      test('it throws an error', () {\n        // TODO: throw TezartNodeError or ContractError ?\n        expect(() => subject(), throwsA(predicate((e) => e is TezartHttpError && e.message == 'Not Found')));\n      });\n    });\n  });\n\n  group('#storage', () {\n    final subject = () => Contract(\n          contractAddress: contractAddress,\n          rpcInterface: rpcInterface,\n        ).storage;\n\n    group('when the contract address exists', () {\n      group('when the contract has a storage', () {", "explanation": "Here is a concise summary of the purpose and functionality:\n\n**Purpose:** Test the `balance` and `storage` methods of the `Contract` class.\n\n**Functionality:**\n\n* `balance`: Returns the balance of a contract when it exists, otherwise throws an error.\n* `storage`: Returns the storage of a contract when its address exists and has a storage, otherwise (not specified in this code snippet).", "metadata": {"repo": "magiclabs/tezart", "file": "test/contracts/contract_test.dart", "chunk_number": 2, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise and holistic summary of the file 'test/contracts/contract_test.dart':\n\n**Purpose:** This test file validates the functionality of various contract-related methods, including balance verification, storage retrieval, entrypoints, and smart contract operations.\n\n**Key Features:**\n\n* Tests the `balance` method to ensure correct balance retrieval\n* Verifies the `storage` method's behavior for existing and non-existent contracts\n* Validates the `entrypoints` method to ensure correct entrypoint retrieval and error handling\n* Tests a smart contract's operation execution, including data fetching from a BigMap and storage updates"}
{"code": "        setUp(() async {\n          await originateContractSetUp(storeValueContract, {'int': '12'});\n        });\n\n        test('it returns the storage of the contract', () async {\n          expect(await subject(), 12);\n        });\n      });\n\n      group('when the contrat has no storage', () {\n        setUp(() async {\n          await originateContractSetUp(noStorageContract, {'prim': 'Unit'});\n        });\n\n        test('it returns null', () async {\n          expect(await subject(), null);\n        });\n      });\n    });\n\n    group('when the contract address doesnt exist', () {\n      setUp(() {\n        contractAddress = 'KT1MkEVtQRWU6Lz5buqsZc5sdXbwprc1ep9b';\n      });\n\n      test('it throws an error', () {\n        // TODO: throw TezartNodeError or ContractError ?\n        expect(() => subject(), throwsA(predicate((e) => e is TezartHttpError)));\n      });\n    });\n  });\n\n  group('#entrypoints', () {\n    final subject = () => Contract(\n          contractAddress: contractAddress,\n          rpcInterface: rpcInterface,", "explanation": "Here is a concise summary of the block:\n\n**Purpose:** Test a contract's storage functionality.\n\n**Functionality:**\n\n1. Tests that the contract returns its stored value (12) when set.\n2. Tests that the contract returns null when no storage is set.\n3. Tests that an error is thrown when the contract address does not exist.", "metadata": {"repo": "magiclabs/tezart", "file": "test/contracts/contract_test.dart", "chunk_number": 3, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise and holistic summary of the file 'test/contracts/contract_test.dart':\n\n**Purpose:** This test file validates the functionality of various contract-related methods, including balance verification, storage retrieval, entrypoints, and smart contract operations.\n\n**Key Features:**\n\n* Tests the `balance` method to ensure correct balance retrieval\n* Verifies the `storage` method's behavior for existing and non-existent contracts\n* Validates the `entrypoints` method to ensure correct entrypoint retrieval and error handling\n* Tests a smart contract's operation execution, including data fetching from a BigMap and storage updates"}
{"code": "        ).entrypoints;\n\n    group('when the contract address exists', () {\n      setUp(() async {\n        await originateContractSetUp(storeValueContract, {'int': '12'});\n      });\n\n      test('it returns the entrypoints of the contract', () async {\n        expect(await subject(), ['replace', 'double', 'divide']);\n      });\n    });\n\n    group('when the contract address doesnt exist', () {\n      setUp(() {\n        contractAddress = 'KT1MkEVtQRWU6Lz5buqsZc5sdXbwprc1ep9b';\n      });\n\n      test('it throws an error', () {\n        // TODO: throw TezartNodeError or ContractError ?\n        expect(() => subject(), throwsA(predicate((e) => e is TezartHttpError)));\n      });\n    });\n  });\n\n  group('#multiparams_entrypoints', () {\n    final subject = () => Contract(\n          contractAddress: contractAddress,\n          rpcInterface: rpcInterface,\n        ).entrypoints;\n\n    group('when the contract address exists', () {\n      late Contract contract;\n\n      setUp(() async {\n        await originateContractSetUp(demoContract, {", "explanation": "Here is a concise summary:\n\n**Purpose:** Test the `entrypoints` functionality of a contract.\n\n**Functionality:**\n\n* When the contract address exists:\n\t+ Returns the entry points of the contract.\n* When the contract address does not exist:\n\t+ Throws an error (specifically, a `TezartHttpError`).", "metadata": {"repo": "magiclabs/tezart", "file": "test/contracts/contract_test.dart", "chunk_number": 4, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise and holistic summary of the file 'test/contracts/contract_test.dart':\n\n**Purpose:** This test file validates the functionality of various contract-related methods, including balance verification, storage retrieval, entrypoints, and smart contract operations.\n\n**Key Features:**\n\n* Tests the `balance` method to ensure correct balance retrieval\n* Verifies the `storage` method's behavior for existing and non-existent contracts\n* Validates the `entrypoints` method to ensure correct entrypoint retrieval and error handling\n* Tests a smart contract's operation execution, including data fetching from a BigMap and storage updates"}
{"code": "          'prim': 'Pair',\n          'args': [[], []]\n        });\n        contract = Contract(contractAddress: contractAddress, rpcInterface: rpcInterface);\n      });\n\n      test('it returns the entrypoints of the contract', () async {\n        expect(await subject(), ['always_fail', 'add_third', 'add_second', 'add_first']);\n      });\n      group('#callOperation', () {\n        final subject = (dynamic params, String entrypoint) async {\n          final operationsList = await contract.callOperation(source: source, entrypoint: entrypoint, params: params);\n          await operationsList.executeAndMonitor();\n        };\n\n        group('when the params are valid', () {\n          final params = {'first': '1', 'second': '2', 'third': '3', 'key': 'key'};\n          final entrypoint = 'add_third';\n\n          test('it updates the storage value correctly', () async {\n            await subject(params, entrypoint);\n            final storage = (await contract.storage);", "explanation": "**Purpose:** This block is a unit test that verifies the functionality of a smart contract's entrypoints.\n\n**Functionality:**\n\n1. It creates a contract instance with a given address and RPC interface.\n2. It tests if the contract returns the correct entrypoints (functions) when called.\n3. It then calls a specific operation on the contract (e.g., 'add_third') with valid parameters, verifying that it updates the storage value correctly.", "metadata": {"repo": "magiclabs/tezart", "file": "test/contracts/contract_test.dart", "chunk_number": 5, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise and holistic summary of the file 'test/contracts/contract_test.dart':\n\n**Purpose:** This test file validates the functionality of various contract-related methods, including balance verification, storage retrieval, entrypoints, and smart contract operations.\n\n**Key Features:**\n\n* Tests the `balance` method to ensure correct balance retrieval\n* Verifies the `storage` method's behavior for existing and non-existent contracts\n* Validates the `entrypoints` method to ensure correct entrypoint retrieval and error handling\n* Tests a smart contract's operation execution, including data fetching from a BigMap and storage updates"}
{"code": "            final BigMap bigMap = storage['big_map_second'];\n            final value = await bigMap.fetch(key: 'key', rpcInterface: rpcInterface);\n\n            expect(value, '123');\n          });\n        });\n      });\n    });\n  });\n\n  group('#callOperation', () {\n    late Contract contract;\n\n    setUp(() async {\n      await originateContractSetUp(storeValueContract, {'int': '12'});\n      contract = Contract(contractAddress: contractAddress, rpcInterface: rpcInterface);\n    });\n\n    final subject = (dynamic params, String entrypoint) async {\n      final operationsList = await contract.callOperation(source: source, entrypoint: entrypoint, params: params);\n      await operationsList.executeAndMonitor();\n    };\n\n    group('when the params are valid', () {\n      final params = 15;\n      final entrypoint = 'replace';\n\n      test('it updates the storage value correctly', () async {\n        await subject(params, entrypoint);\n\n        expect(await contract.storage, 15);\n      });\n    });\n", "explanation": "**Purpose:** Test the functionality of a smart contract and its operations.\n\n**Functionality:**\n\n* Tests fetching data from a BigMap using a key.\n* Calls an operation on a contract with valid parameters.\n* Verifies that the contract's storage is updated correctly after the operation is executed.", "metadata": {"repo": "magiclabs/tezart", "file": "test/contracts/contract_test.dart", "chunk_number": 6, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise and holistic summary of the file 'test/contracts/contract_test.dart':\n\n**Purpose:** This test file validates the functionality of various contract-related methods, including balance verification, storage retrieval, entrypoints, and smart contract operations.\n\n**Key Features:**\n\n* Tests the `balance` method to ensure correct balance retrieval\n* Verifies the `storage` method's behavior for existing and non-existent contracts\n* Validates the `entrypoints` method to ensure correct entrypoint retrieval and error handling\n* Tests a smart contract's operation execution, including data fetching from a BigMap and storage updates"}
{"code": "    group('when the entrypoint doesnt exist', () {\n      final params = 15;\n      final entrypoint = 'not_found';\n\n      test('it throws a simulationFailed error', () async {\n        expect(() => subject(params, entrypoint),\n            throwsA(predicate((e) => e is TezartHttpError && e.message == 'Not Found')));\n      });\n    });\n\n    group('when the params are invalid', () {\n      group('when the params are incompatible with the entrypoint signature', () {\n        final entrypoint = 'replace';\n        final params = {'string': 'value'};\n\n        test('it throws a simulationFailed error', () async {\n          // TODO: throw custom error instead ?\n          expect(() => subject(params, entrypoint), throwsA(predicate((e) => e is TypeError)));\n        });\n      });\n\n      group('when the params cause a runtime error', () {\n        final entrypoint = 'divide';\n        final params = 2;\n\n        test('it throws a simulationFailed error', () async {", "explanation": "**Summary**\n\nThis code block uses the `group` and `test` functions from a testing framework (likely Dart's `unittest` package) to validate the behavior of a function called `subject`. It tests two scenarios:\n\n1. When the entrypoint doesn't exist, it expects a `TezartHttpError` with message \"Not Found\".\n2. When the input parameters are invalid (either incompatible with the entrypoint or cause a runtime error), it expects a `TypeError` to be thrown.\n\nIn both cases, the tests verify that the function `subject` behaves as expected and throws an error when given incorrect inputs.", "metadata": {"repo": "magiclabs/tezart", "file": "test/contracts/contract_test.dart", "chunk_number": 7, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise and holistic summary of the file 'test/contracts/contract_test.dart':\n\n**Purpose:** This test file validates the functionality of various contract-related methods, including balance verification, storage retrieval, entrypoints, and smart contract operations.\n\n**Key Features:**\n\n* Tests the `balance` method to ensure correct balance retrieval\n* Verifies the `storage` method's behavior for existing and non-existent contracts\n* Validates the `entrypoints` method to ensure correct entrypoint retrieval and error handling\n* Tests a smart contract's operation execution, including data fetching from a BigMap and storage updates"}
{"code": "          // the error is caused because params.divisor < 5 (c.f contract)\n          expect(() => subject(params, entrypoint),\n              throwsA(predicate((e) => e is TezartNodeError && e.type == TezartNodeErrorTypes.simulationFailed)));\n        });\n      });\n    });\n  });\n}\n", "explanation": "Here is a concise summary:\n\nThis block expects a function call (`subject(params, entrypoint)`) to throw an error of type `TezartNodeError` due to invalid division (`params.divisor < 5`).", "metadata": {"repo": "magiclabs/tezart", "file": "test/contracts/contract_test.dart", "chunk_number": 8, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise and holistic summary of the file 'test/contracts/contract_test.dart':\n\n**Purpose:** This test file validates the functionality of various contract-related methods, including balance verification, storage retrieval, entrypoints, and smart contract operations.\n\n**Key Features:**\n\n* Tests the `balance` method to ensure correct balance retrieval\n* Verifies the `storage` method's behavior for existing and non-existent contracts\n* Validates the `entrypoints` method to ensure correct entrypoint retrieval and error handling\n* Tests a smart contract's operation execution, including data fetching from a BigMap and storage updates"}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\n@Tags([\"unstable\"])\n@Timeout(Duration(seconds: 60))\n\nimport 'package:test/test.dart';\nimport 'package:tezart/tezart.dart';\n\nimport '../../env/env.dart';\nimport '../../test_utils/test_contract_script.dart';\nimport '../../test_utils/test_client.dart';\n\nvoid main() {\n  final tezart = testClient();\n  final originatorKeystore = Keystore.fromSecretKey(Env.originatorSk);\n\n  group('#transferOperation', () {\n    final subject = (Keystore source, String destination, int amount) =>\n        tezart.transferOperation(source: source, destination: destination, amount: amount);\n    final destination = Keystore.random().address;\n    final amount = 1;\n\n    group('when the key is revealed', () {\n      final source = originatorKeystore;\n\n      test('it doesnt prepend the reveal operation', () async {\n        final operationsList = await subject(source, destination, amount);\n        expect(operationsList.operations.whereType<RevealOperation>(), isEmpty);\n      });\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Test the `transferOperation` function in Tezart library.\n\n**Functionality:** Verifies that the `transferOperation` function does not prepend a reveal operation when using the originator's key.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/client/tezart_client_test.dart", "chunk_number": 1, "total_chunks": 6}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**Summary**\n\nThis code block contains unit tests for various functions in the Tezart library, specifically testing the behavior of `transferOperation`, `subject` function, and related methods. The tests verify correct functionality under different scenarios, including key revelation and operation monitoring."}
{"code": "      test('it contains a valid transaction operation', () async {\n        final operationsList = await subject(source, destination, amount);\n        expect(operationsList.operations.length, 1);\n        expect(operationsList.operations.first, isA<TransactionOperation>());\n      });\n    });\n\n    group('when the key is not revealed', () {\n      late Keystore source;\n\n      setUp(() async {\n        source = Keystore.random();\n      });\n\n      test('it prepends the reveal operation', () async {\n        final operationsList = await subject(source, destination, amount);\n        expect(operationsList.operations.first, isA<RevealOperation>());\n      });\n\n      test('it contains a valid transaction operation', () async {\n        final operationsList = await subject(source, destination, amount);\n        expect(operationsList.operations.length, 2);\n        expect(operationsList.operations[1], isA<TransactionOperation>());\n      });\n    });\n  });\n\n  group('#isKeyRevealed', () {", "explanation": "Here is a concise summary:\n\n**Purpose:** Test the functionality of an unknown \"subject\" that generates operations lists.\n\n**Functionality:**\n\n* Verifies the existence of a valid transaction operation.\n* When the key is not revealed:\n\t+ Prepends a reveal operation to the list.\n\t+ Includes a valid transaction operation in the list.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/client/tezart_client_test.dart", "chunk_number": 2, "total_chunks": 6}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**Summary**\n\nThis code block contains unit tests for various functions in the Tezart library, specifically testing the behavior of `transferOperation`, `subject` function, and related methods. The tests verify correct functionality under different scenarios, including key revelation and operation monitoring."}
{"code": "    final subject = (String address) => tezart.isKeyRevealed(address);\n\n    group('when the key is not revealed', () {\n      final address = Keystore.random().address;\n\n      test('it returns false', () async {\n        final result = await subject(address);\n\n        expect(result, isFalse);\n      });\n    });\n\n    group('when the key is revealed', () {\n      final address = originatorKeystore.address;\n\n      test('it returns true', () async {\n        final result = await subject(address);\n\n        expect(result, isTrue);\n      });\n    });\n  });\n\n  group('#revealKey', () {\n    final subject = (Keystore keystore) => tezart.revealKeyOperation(keystore);\n\n    final keystore = Keystore.random();\n\n    test('the operations list contains a reveal operation only', () {\n      final operationsList = subject(keystore);\n\n      expect(operationsList.operations.length, 1);\n      expect(operationsList.operations.first, isA<RevealOperation>());\n    });\n  });\n\n  group('#monitorOperation', () {", "explanation": "Here is a concise summary:\n\nThis block defines three test groups for a Tezos-related function.\n\n* The first group tests `isKeyRevealed` with a randomly generated address, ensuring it returns false when the key is not revealed.\n* The second group tests `isKeyRevealed` with a specific revealed key, ensuring it returns true.\n* The third group tests `revealKeyOperation`, verifying that it generates an operations list containing only a reveal operation.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/client/tezart_client_test.dart", "chunk_number": 3, "total_chunks": 6}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**Summary**\n\nThis code block contains unit tests for various functions in the Tezart library, specifically testing the behavior of `transferOperation`, `subject` function, and related methods. The tests verify correct functionality under different scenarios, including key revelation and operation monitoring."}
{"code": "    final subject = (String operationId) async => tezart.monitorOperation(operationId);\n\n    group('when the operationId exists', () {\n      test('it monitors the operation', () async {\n        final getBalance = () => tezart.getBalance(address: originatorKeystore.address);\n        final destination = Keystore.random();\n        final amount = 1;\n        final balanceBeforeTransfer = await getBalance();\n        final operationsList = await tezart.transferOperation(\n          source: originatorKeystore,\n          destination: destination.address,\n          amount: amount,\n        );\n        await operationsList.execute();\n        await subject(operationsList.result.id!);\n        final balanceAfterMonitoring = await getBalance();\n\n        expect(balanceAfterMonitoring, lessThan(balanceBeforeTransfer));\n      });\n    });\n\n    group('when the operationId doesnt exist', () {\n      test('it throws an error', () async {\n        final operationId = 'toto';\n        expect(\n            () => subject(operationId),", "explanation": "**Summary:**\n\nThis code block is a unit test for a `tezart.monitorOperation` function. It checks that when a valid `operationId` is provided, it successfully monitors the operation, and when an invalid `operationId` is given, it throws an error.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/client/tezart_client_test.dart", "chunk_number": 4, "total_chunks": 6}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**Summary**\n\nThis code block contains unit tests for various functions in the Tezart library, specifically testing the behavior of `transferOperation`, `subject` function, and related methods. The tests verify correct functionality under different scenarios, including key revelation and operation monitoring."}
{"code": "            throwsA(predicate(\n                (e) => e is TezartNodeError && e.message == 'Monitoring the operation $operationId timed out')));\n      });\n    });\n  });\n\n  group('#originateContract', () {\n    final balanceAmount = 1;\n    final subject = (Keystore source) => tezart.originateContractOperation(\n          source: source,\n          balance: balanceAmount,\n          code: testContractScript,\n          storage: {'int': '12'},\n        );\n\n    group('when the source key is already revealed', () {\n      test('it returns an operations list containing an OriginationOperation only', () async {\n        final operationsList = await subject(originatorKeystore);\n        expect(operationsList.operations.length, 1);\n        expect(operationsList.operations.first, isA<OriginationOperation>());\n      });\n    });\n\n    group('when the source key is not revealed', () {\n      test('it prepends the operations list with a reveal operation', () async {\n        final operationsList = await subject(Keystore.random());", "explanation": "**Summary**\n\nThis block defines a set of tests for the `tezart` library, specifically for the `originateContractOperation` function. The tests check its behavior under different scenarios, such as when the source key is already revealed or not. The tests verify the expected output in terms of operations lists and their contents.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/client/tezart_client_test.dart", "chunk_number": 5, "total_chunks": 6}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**Summary**\n\nThis code block contains unit tests for various functions in the Tezart library, specifically testing the behavior of `transferOperation`, `subject` function, and related methods. The tests verify correct functionality under different scenarios, including key revelation and operation monitoring."}
{"code": "        expect(operationsList.operations.first, isA<RevealOperation>());\n      });\n\n      test('it returns an operations list containing an origination operation in the second place', () async {\n        final operationsList = await subject(Keystore.random());\n        expect(operationsList.operations.length, 2);\n        expect(operationsList.operations[1], isA<OriginationOperation>());\n      });\n    });\n  });\n}\n", "explanation": "Here's a concise summary:\n\nThis block contains two test cases that verify the functionality of an operations list returned by the `subject` function. The tests check for the presence of specific types of operations (RevealOperation and OriginationOperation) at specified positions in the operations list.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/client/tezart_client_test.dart", "chunk_number": 6, "total_chunks": 6}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**Summary**\n\nThis code block contains unit tests for various functions in the Tezart library, specifically testing the behavior of `transferOperation`, `subject` function, and related methods. The tests verify correct functionality under different scenarios, including key revelation and operation monitoring."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nimport 'package:dio/dio.dart';\nimport 'package:test/test.dart';\nimport 'package:tezart/src/core/rpc/impl/tezart_http_error.dart';\n\nimport '../../env/env.dart';\n\nvoid main() {\n  const data = 'test';\n  const statusCode = 500;\n  final originalException = DioError(\n    response: Response(\n      data: data,\n      statusCode: statusCode,\n      requestOptions: RequestOptions(path: Env.tezosNodeUrl),\n    ),\n    type: DioErrorType.cancel,\n    requestOptions: RequestOptions(path: Env.tezosNodeUrl),\n  );\n  final instance = TezartHttpError(originalException);\n\n  group('#responseBody', () {\n    final subject = () => instance.responseBody;\n\n    test('it returns response body', () {\n      expect(subject(), equals(data));\n    });\n  });\n\n  group('#statusCode', () {\n    final subject = () => instance.statusCode;\n\n    test('it returns status code', () {\n      expect(subject(), equals(statusCode));\n    });\n  });\n\n  group('#type', () {\n    final subject = () => instance.type;\n", "explanation": "**Summary:**\n\nThis block is a unit test suite written in Dart, using the `test` package. It tests the functionality of the `TezartHttpError` class by creating an instance with a mock Dio error and verifying that its methods (`responseBody`, `statusCode`, and `type`) return the expected values.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/client/tezart_node_error_test.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and to-the-point summary of the file `test/core/client/tezart_node_error_test.dart`:\n\n**Summary:** This unit test suite in Dart verifies the functionality of the `TezartHttpError` class, testing error type, message, and exception handling."}
{"code": "    test('it returns valid error type', () {\n      expect(subject(), equals(TezartHttpErrorTypes.cancel));\n    });\n  });\n\n  group('#key', () {\n    final subject = () => instance.key;\n\n    test('it returns a string representation of type', () {\n      expect(subject(), equals('cancel'));\n    });\n  });\n\n  group('#message', () {\n    final subject = () => instance.message;\n\n    test('it returns a valid error message', () {\n      expect(subject(), equals('The request has been cancelled'));\n    });\n  });\n\n  group('#originalException', () {\n    final subject = () => instance.originalException;\n\n    test('it returns the original exception object', () {\n      expect(subject(), equals(originalException));\n    });\n  });\n}\n", "explanation": "This block appears to be a set of tests for an error handling system, specifically testing the functionality of a `TezartHttpErrorTypes` instance. The tests verify that it returns:\n\n* A valid error type\n* A string representation of the error type (in this case, 'cancel')\n* A valid error message\n* The original exception object", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/client/tezart_node_error_test.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and to-the-point summary of the file `test/core/client/tezart_node_error_test.dart`:\n\n**Summary:** This unit test suite in Dart verifies the functionality of the `TezartHttpError` class, testing error type, message, and exception handling."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nimport 'dart:convert';\nimport 'dart:typed_data';\nimport 'package:collection/collection.dart';\nimport 'package:dio/dio.dart';\nimport 'package:mockito/annotations.dart';\nimport 'package:mockito/mockito.dart';\nimport 'package:test/test.dart';\nimport 'package:tezart/src/core/rpc/impl/operations_monitor.dart';\nimport 'package:tezart/src/core/rpc/impl/rpc_interface_paths.dart' as paths;\nimport 'package:tezart/src/core/rpc/impl/tezart_http_client.dart';\n\nimport 'package:tezart/tezart.dart';\n\nimport '../../../env/env.dart';\nimport 'operations_monitor_test.mocks.dart';\n\n@GenerateMocks([RpcInterface, TezartHttpClient])\nvoid main() {\n  final rpcInterface = MockRpcInterface();\n  const chain = 'main';\n  const level = 'head';\n  const operationId = 'opId';\n  final subject = () => OperationsMonitor(rpcInterface).monitor(chain: chain, level: level, operationId: operationId);\n\n  // Default mocks setup\n  const predHash = 'predecessorHash';", "explanation": "**Purpose:** Unit testing of `OperationsMonitor` class.\n\n**Functionality:** This code sets up a test environment for `OperationsMonitor`, creating a mock instance of `RpcInterface` and calling its `monitor` method with various parameters. The test setup includes mocking dependencies and importing necessary packages from the Tezart library.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/rpc/impl/operations_monitor_test.dart", "chunk_number": 1, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary of the file 'test/core/rpc/impl/operations_monitor_test.dart':\n\nThis code defines unit tests for the `OperationsMonitor` class, verifying its behavior when interacting with a mock RPC interface. The tests check for expected results, correct sequence of method calls, and handle edge cases where operation IDs are not found or monitoring times out."}
{"code": "  const blockHash = 'blockHash';\n  final httpClient = MockTezartHttpClient();\n\n  setUp(() {\n    when(rpcInterface.httpClient).thenReturn(httpClient);\n\n    when(rpcInterface.block(chain: chain, level: level)).thenAnswer((_) async {\n      return {\n        'header': {'predecessor': predHash}\n      };\n    });\n\n    when(httpClient.getStream(paths.monitor(chain))).thenAnswer((_) async {\n      return Response(\n        data: ResponseBody(\n          Stream.fromIterable(\n            [\n              Uint8List.fromList(json.encode({'hash': blockHash}).codeUnits),\n            ],\n          ),\n          200,\n        ),\n        requestOptions: RequestOptions(path: Env.tezosNodeUrl),\n      );\n    });\n  });\n\n  tearDown(() {\n    reset(httpClient);\n    reset(rpcInterface);\n  });\n\n  group('when the operation is included in the first block', () {\n    setUp(() {\n      when(rpcInterface.transactionsOperationHashes(level: predHash)).thenAnswer((_) async {\n        return ['wrongOperationId'];\n      });\n", "explanation": "Here is a concise summary of the purpose and functionality of this code block:\n\n**Purpose:** Test setup for a Tezos-related test suite.\n\n**Functionality:** Mocks an HTTP client and RPC interface, setting up mock responses to simulate expected behavior when testing a Tezos application.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/rpc/impl/operations_monitor_test.dart", "chunk_number": 2, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary of the file 'test/core/rpc/impl/operations_monitor_test.dart':\n\nThis code defines unit tests for the `OperationsMonitor` class, verifying its behavior when interacting with a mock RPC interface. The tests check for expected results, correct sequence of method calls, and handle edge cases where operation IDs are not found or monitoring times out."}
{"code": "      when(rpcInterface.transactionsOperationHashes(level: blockHash)).thenAnswer((_) async {\n        return [operationId];\n      });\n    });\n\n    test('it returns the head block hash', () async {\n      final result = await subject();\n\n      expect(result, blockHash);\n    });\n\n    test('it calls rpc interface methods in order', () async {\n      await subject();\n\n      verifyInOrder([\n        rpcInterface.block(chain: chain, level: level),\n        rpcInterface.transactionsOperationHashes(level: predHash),\n        rpcInterface.httpClient,\n        httpClient.getStream(paths.monitor(chain)),\n        rpcInterface.transactionsOperationHashes(level: blockHash),\n      ]);\n      verifyNoMoreInteractions(httpClient);\n      verifyNoMoreInteractions(rpcInterface);\n    });\n  });\n\n  group('when the operation id is included in the predecessor block', () {\n    setUp(() {\n      when(rpcInterface.transactionsOperationHashes(level: predHash)).thenAnswer((_) async {\n        return [operationId];\n      });\n    });\n", "explanation": "Here's a concise summary:\n\nThis code defines a set of tests for an object called `subject()`. The tests verify that it returns the expected results when:\n\n1. Calling rpc interface methods in order\n2. Returning the head block hash\n3. When an operation ID is included in the predecessor block.\n\nIt uses mocking and verification to ensure the correct behavior.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/rpc/impl/operations_monitor_test.dart", "chunk_number": 3, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary of the file 'test/core/rpc/impl/operations_monitor_test.dart':\n\nThis code defines unit tests for the `OperationsMonitor` class, verifying its behavior when interacting with a mock RPC interface. The tests check for expected results, correct sequence of method calls, and handle edge cases where operation IDs are not found or monitoring times out."}
{"code": "    test('it returns the predecessor block hash', () async {\n      final result = await subject();\n\n      expect(result, predHash);\n    });\n\n    test('it calls rpc interface methods in order', () async {\n      await subject();\n\n      verifyInOrder([\n        rpcInterface.block(chain: chain, level: level),\n        rpcInterface.transactionsOperationHashes(level: predHash),\n      ]);\n      verifyNoMoreInteractions(httpClient);\n      verifyNoMoreInteractions(rpcInterface);\n    });\n  });\n\n  group('when the operation id is not found', () {\n    setUp(() {\n      when(rpcInterface.transactionsOperationHashes(level: predHash)).thenAnswer((_) async {\n        return ['wrongOperationId'];\n      });\n\n      when(rpcInterface.transactionsOperationHashes(level: blockHash)).thenAnswer((_) async {\n        return ['wrongOperationId'];\n      });\n    });\n\n    test('it throws a TezartNodeError', () async {\n      expect(\n        () => subject(),\n        throwsA(\n          predicate(\n            (e) =>\n                e is TezartNodeError &&", "explanation": "Here is a concise summary of the block's purpose and functionality:\n\n**Purpose:** Test the behavior of a function (`subject()`) that interacts with an RPC interface.\n\n**Functionality:**\n\n* Tests return expected results (e.g., predecessor block hash).\n* Verifies correct sequence of RPC method calls.\n* Handles edge case where operation ID is not found, throwing a `TezartNodeError`.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/rpc/impl/operations_monitor_test.dart", "chunk_number": 4, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary of the file 'test/core/rpc/impl/operations_monitor_test.dart':\n\nThis code defines unit tests for the `OperationsMonitor` class, verifying its behavior when interacting with a mock RPC interface. The tests check for expected results, correct sequence of method calls, and handle edge cases where operation IDs are not found or monitoring times out."}
{"code": "                e.type == TezartNodeErrorTypes.monitoringTimedOut &&\n                MapEquality().equals(\n                  e.metadata,\n                  {'operationId': operationId},\n                ),\n          ),\n        ),\n      );\n    });\n  });\n}\n", "explanation": "Here is a concise summary:\n\nThis block checks for a specific type of error (`monitoringTimedOut`) with metadata matching an `operationId`.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/rpc/impl/operations_monitor_test.dart", "chunk_number": 5, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary of the file 'test/core/rpc/impl/operations_monitor_test.dart':\n\nThis code defines unit tests for the `OperationsMonitor` class, verifying its behavior when interacting with a mock RPC interface. The tests check for expected results, correct sequence of method calls, and handle edge cases where operation IDs are not found or monitoring times out."}
{"code": "import 'package:test/test.dart';\nimport 'package:tezart/src/core/rpc/impl/rpc_interface_paths.dart';\n\nvoid testPath(String method, String actual, String expected) {\n  test('#$method returns valid value', () {\n    expect(expected, equals(actual));\n  });\n}\n\nvoid main() {\n  const chain = 'main';\n  const level = 'head';\n  const source = 'edsk4NH16aVF7JHNJ3xHpcsyKSPHdG5U5ZqxksK6APmRVwpAfJzDgV';\n  const address = 'tz1MjmdTVSr4T4deDSsb4MXv3tLtKccd9Z1q';\n\n  testPath(\n    'pendingOperations',\n    pendingOperations(chain),\n    'chains/$chain/mempool/pending_operations',\n  );\n  testPath(\n    'branch',\n    branch(chain: chain, level: level),\n    'chains/$chain/blocks/$level/hash',\n  );\n  testPath(\n    'chainId',\n    chainId(chain),\n    'chains/$chain/chain_id',\n  );\n\n  testPath('counter', counter(chain: chain, level: level, source: source),\n      'chains/$chain/blocks/$level/context/contracts/$source/counter');\n\n  testPath(\n    'injectOperation',\n    injectOperation(chain),\n    'injection/operation?chain=$chain',\n  );\n", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Test RPC interface paths using unit tests.\n\n**Functionality:** The code defines a test function `testPath` that checks if a given RPC method returns the expected path. It then uses this function to test several specific RPC methods with different inputs.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/rpc/impl/rpc_interface_paths_test.dart", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'test/core/rpc/impl/rpc_interface_paths_test.dart':\n\n**Summary:** Unit tests verify API endpoints for retrieving various data points, such as balance data and blockchain information, at specified chain URLs."}
{"code": "  testPath('managerKey', managerKey(chain: chain, level: level, address: address),\n      'chains/$chain/blocks/$level/context/contracts/$address/manager_key');\n\n  testPath(\n    'operationHashes',\n    operationHashes(\n      chain: chain,\n      level: level,\n    ),\n    'chains/$chain/blocks/$level/operation_hashes/',\n  );\n\n  testPath(\n    'constants',\n    constants(chain: chain, level: level),\n    'chains/$chain/blocks/$level/context/constants',\n  );\n\n  testPath(\n    'block',\n    block(chain: chain, level: level),\n    'chains/$chain/blocks/$level',\n  );\n  testPath(\n    'protocol',\n    protocol(chain: chain, level: level),\n    'chains/$chain/blocks/$level/metadata',\n  );\n\n  testPath(\n    'forgeOperations',\n    forgeOperations(chain: chain, level: level),\n    'chains/$chain/blocks/$level/helpers/forge/operations',\n  );\n\n  testPath(\n    'runOperations',\n    runOperations(chain: chain, level: level),\n    'chains/$chain/blocks/$level/helpers/scripts/run_operation',\n  );\n\n  testPath(\n    'balance',", "explanation": "Here is a concise summary of the block's purpose and functionality:\n\n**Purpose:** A series of tests that verify API endpoints for retrieving specific data.\n\n**Functionality:** Tests the availability of various data points, such as manager keys, operation hashes, constants, blocks, protocol information, forge operations, run operations, and balance data, at specified chain and level URLs.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/rpc/impl/rpc_interface_paths_test.dart", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'test/core/rpc/impl/rpc_interface_paths_test.dart':\n\n**Summary:** Unit tests verify API endpoints for retrieving various data points, such as balance data and blockchain information, at specified chain URLs."}
{"code": "    balance(chain: chain, level: level, address: address),\n    'chains/$chain/blocks/$level/context/contracts/$address',\n  );\n\n  testPath(\n    'monitor',\n    monitor(chain),\n    'monitor/heads/$chain',\n  );\n}\n", "explanation": "This block defines two tests:\n\n1. A path for retrieving balance data from a blockchain.\n2. A path for monitoring a specific chain's head block.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/rpc/impl/rpc_interface_paths_test.dart", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'test/core/rpc/impl/rpc_interface_paths_test.dart':\n\n**Summary:** Unit tests verify API endpoints for retrieving various data points, such as balance data and blockchain information, at specified chain URLs."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nimport 'dart:convert';\nimport 'dart:typed_data';\nimport 'package:dio/dio.dart';\nimport 'package:mockito/annotations.dart';\nimport 'package:mockito/mockito.dart';\nimport 'package:test/test.dart';\nimport 'package:tezart/src/core/rpc/impl/tezart_http_client.dart';\n\nimport 'package:tezart/src/core/rpc/rpc_interface.dart';\n\nimport 'tezart_http_client_test.mocks.dart';\n\n@GenerateMocks([Dio])\nvoid main() {\n  final client = MockDio();\n  final options = BaseOptions();\n  const url = 'http://localhost:20000/';\n  late TezartHttpClient instance;\n\n  void testFailingRequest(Function subject, Function callback) {\n    setUp(() {\n      when(callback()).thenAnswer((_) async {\n        throw DioError(requestOptions: RequestOptions(path: url));\n      });\n    });\n\n    test('it throws a TezartHttpError', () {\n      expect(\n        subject,\n        throwsA(\n          predicate((e) => e is TezartHttpError),\n        ),\n      );\n    });\n  }\n\n  setUp(() {", "explanation": "**Summary**\n\nThis block is a unit test suite for a `TezartHttpClient` class, written in Dart using the `test` package and Mockito library. It tests error handling by simulating a failing HTTP request and verifying that the correct exception is thrown.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/rpc/impl/tezart_http_client_test.dart", "chunk_number": 1, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary of the file 'test/core/rpc/impl/tezart_http_client_test.dart':\n\nThis test suite validates the behavior of the TezartHttpClient class, ensuring its post, get methods handle successful and failed requests correctly, and verifies error handling through mocked scenarios."}
{"code": "    when(client.options).thenReturn(options);\n    instance = TezartHttpClient(url, client: client);\n  });\n\n  tearDown(() {\n    reset(client);\n  });\n\n  group('#post', () {\n    const path = '/mempool';\n    const data = {'test': 'test'};\n    final subject = () => instance.post(path, data: data);\n\n    group('when the request succeeds', () {\n      setUp(() {\n        when(client.post(path, data: data)).thenAnswer((_) async {\n          return Response(\n            data: 'ok',\n            statusCode: 201,\n            requestOptions: RequestOptions(path: url),\n          );\n        });\n      });\n\n      test(\"calls client's post\", () async {\n        await subject();\n\n        verifyInOrder([\n          client.options,\n          client.post(path, data: data),\n        ]);\n\n        verifyNoMoreInteractions(client);\n      });\n    });\n\n    group('when the request fails', () {\n      testFailingRequest(subject, () => client.post(path, data: data));\n    });\n  });\n\n  group('#get', () {\n    const path = '/mempool';", "explanation": "**Summary**\n\nThis block of code is a unit test suite for an HTTP client class called `TezartHttpClient`. It tests the `post` and `get` methods, verifying that they correctly interact with an underlying client object (`client`). The tests cover both successful and failed requests, ensuring the client behaves as expected.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/rpc/impl/tezart_http_client_test.dart", "chunk_number": 2, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary of the file 'test/core/rpc/impl/tezart_http_client_test.dart':\n\nThis test suite validates the behavior of the TezartHttpClient class, ensuring its post, get methods handle successful and failed requests correctly, and verifies error handling through mocked scenarios."}
{"code": "    const params = {'test': 'test'};\n    final subject = () => instance.get(path, params: params);\n\n    group('when the request succeeds', () {\n      setUp(() {\n        when(client.get(path, queryParameters: params)).thenAnswer((_) async {\n          return Response(\n            data: 'ok',\n            statusCode: 200,\n            requestOptions: RequestOptions(path: url),\n          );\n        });\n      });\n\n      test(\"calls client's get\", () async {\n        await subject();\n\n        verifyInOrder([\n          client.options,\n          client.get(path, queryParameters: params),\n        ]);\n\n        verifyNoMoreInteractions(client);\n      });\n    });\n\n    group('when the request fails', () {\n      testFailingRequest(subject, () => client.get(path, queryParameters: params));\n    });\n  });\n\n  group('#getStream', () {\n    const path = '/mempool';\n    const params = {'test': 'test'};\n    final subject = () => instance.getStream(path, params: params);\n\n    group('when the request succeeds', () {\n      setUp(() {\n        when(", "explanation": "Here is a concise summary:\n\n**Block Purpose:** Test the functionality of a client's `get` method.\n\n**Functionality:**\n\n* Verifies that the client's `get` method is called with the correct parameters.\n* Tests two scenarios:\n\t1. When the request succeeds, verifies that the client's `get` method returns a successful response.\n\t2. When the request fails, calls the `testFailingRequest` function to test error handling.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/rpc/impl/tezart_http_client_test.dart", "chunk_number": 3, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary of the file 'test/core/rpc/impl/tezart_http_client_test.dart':\n\nThis test suite validates the behavior of the TezartHttpClient class, ensuring its post, get methods handle successful and failed requests correctly, and verifies error handling through mocked scenarios."}
{"code": "          client.get<ResponseBody>(\n            path,\n            queryParameters: params,\n            options: anyNamed('options'),\n          ),\n        ).thenAnswer((_) async {\n          return Response(\n            data: ResponseBody(\n              Stream.fromIterable(\n                [\n                  Uint8List.fromList(json.encode(params).codeUnits),\n                ],\n              ),\n              200,\n            ),\n            requestOptions: RequestOptions(path: url),\n          );\n        });\n      });\n\n      test(\"calls client's get\", () async {\n        await subject();\n\n        verify(client.options);\n        expect(\n          verify(client.get(path, queryParameters: params, options: captureAnyNamed('options')))\n              .captured\n              .single\n              .responseType,\n          ResponseType.stream,\n        );\n        verifyNoMoreInteractions(client);\n      });\n    });\n\n    group('when the request fails', () {\n      testFailingRequest(\n        subject,\n        () => client.get(\n          path,", "explanation": "**Purpose:** Mocks a `client.get` call with a successful response for testing.\n\n**Functionality:**\n\n* Calls `client.get` with specified parameters.\n* Returns a mocked `Response` object with a successful status code (200).\n* Verifies that `client.options` was called and the `get` method was called with correct parameters.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/rpc/impl/tezart_http_client_test.dart", "chunk_number": 4, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary of the file 'test/core/rpc/impl/tezart_http_client_test.dart':\n\nThis test suite validates the behavior of the TezartHttpClient class, ensuring its post, get methods handle successful and failed requests correctly, and verifies error handling through mocked scenarios."}
{"code": "          queryParameters: params,\n          options: anyNamed('options'),\n        ),\n      );\n    });\n  });\n}\n", "explanation": "This block defines a closure that generates an object with two properties:\n\n* `queryParameters`: set to a given `params` value\n* `options`: set to an object with all key-value pairs where the key is 'options' using the `anyNamed()` function.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/rpc/impl/tezart_http_client_test.dart", "chunk_number": 5, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here's a concise summary of the file 'test/core/rpc/impl/tezart_http_client_test.dart':\n\nThis test suite validates the behavior of the TezartHttpClient class, ensuring its post, get methods handle successful and failed requests correctly, and verifies error handling through mocked scenarios."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nimport 'package:dio/dio.dart';\nimport 'package:test/test.dart';\nimport 'package:tezart/src/core/rpc/impl/tezart_http_error.dart';\n\nimport '../../../env/env.dart';\n\nvoid main() {\n  const data = 'test';\n  const statusCode = 500;\n  final originalException = DioError(\n    response: Response(\n      data: data,\n      statusCode: statusCode,\n      requestOptions: RequestOptions(path: Env.tezosNodeUrl),\n    ),\n    type: DioErrorType.cancel,\n    requestOptions: RequestOptions(path: Env.tezosNodeUrl),\n  );\n  final instance = TezartHttpError(originalException);\n\n  group('#responseBody', () {\n    final subject = () => instance.responseBody;\n\n    test('it returns response body', () {\n      expect(subject(), equals(data));\n    });\n  });\n\n  group('#statusCode', () {\n    final subject = () => instance.statusCode;\n\n    test('it returns status code', () {\n      expect(subject(), equals(statusCode));\n    });\n  });\n\n  group('#type', () {\n    final subject = () => instance.type;\n", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Test class `TezartHttpError` from package `tezart/src/core/rpc/impl`.\n\n**Functionality:** Verify that instances of `TezartHttpError` have proper properties (response body, status code, type) set based on a given `DioError`.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/rpc/impl/tezart_http_error_test.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\nThis file (`tezart_http_error_test.dart`) contains a test suite for the `TezartHttpError` class, verifying that it properly sets properties (response body, status code, type) from a given `DioError`."}
{"code": "    test('it returns valid error type', () {\n      expect(subject(), equals(TezartHttpErrorTypes.cancel));\n    });\n  });\n\n  group('#key', () {\n    final subject = () => instance.key;\n\n    test('it returns a string representation of type', () {\n      expect(subject(), equals('cancel'));\n    });\n  });\n\n  group('#message', () {\n    final subject = () => instance.message;\n\n    test('it returns a valid error message', () {\n      expect(subject(), equals('The request has been cancelled'));\n    });\n  });\n\n  group('#originalException', () {\n    final subject = () => instance.originalException;\n\n    test('it returns the original exception object', () {\n      expect(subject(), equals(originalException));\n    });\n  });\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Test suite for verifying functionality of an error type class.\n\n**Functionality:**\n\n* Returns valid error types\n* Returns string representation of type (e.g., \"cancel\")\n* Returns error message (\"The request has been cancelled\")\n* Returns original exception object", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/rpc/impl/tezart_http_error_test.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\nThis file (`tezart_http_error_test.dart`) contains a test suite for the `TezartHttpError` class, verifying that it properly sets properties (response body, status code, type) from a given `DioError`."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nimport 'package:test/test.dart';\n\nimport 'package:tezart/src/core/rpc/rpc_interface.dart';\nimport 'package:tezart/src/keystore/keystore.dart';\n\nimport '../../env/env.dart';\n\nvoid main() {\n  final rpcInterface = RpcInterface(Env.tezosNodeUrl);\n  final originator = Keystore.fromSecretKey(Env.originatorSk);\n\n  group('#pendingOperations()', () {\n    final subject = () => rpcInterface.pendingOperations();\n\n    test('it returns pending operations', () async {\n      final result = await subject();\n\n      expect(\n          result.keys, equals(['applied', 'refused', 'outdated', 'branch_refused', 'branch_delayed', 'unprocessed']));\n    });\n  });\n\n  group('#branch()', () {\n    final subject = () => rpcInterface.branch();\n\n    test('it returns the branch hash', () async {\n      final result = await subject();\n\n      expect(RegExp(r'^B\\w+$').hasMatch(result), true);\n    });\n  });\n\n  group('#chainId()', () {\n    final subject = () => rpcInterface.chainId();\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Unit test suite for Tezos RPC interface functionality.\n\n**Functionality:** Tests `RpcInterface` methods (`pendingOperations`, `branch`, `chainId`) against expected outputs, verifying their correctness.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/rpc/rpc_interface_test.dart", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and to-the-point holistic summary of the file 'test/core/rpc/rpc_interface_test.dart':\n\n**Unit Test Suite:** Tests the correctness of `RpcInterface` methods in a Tezos RPC interface, verifying expected outputs against actual results."}
{"code": "    test('it returns the chain id', () async {\n      final result = await subject();\n\n      expect(RegExp(r'^Net\\w+$').hasMatch(result), true);\n    });\n  });\n\n  group('#protocol()', () {\n    final subject = () => rpcInterface.protocol();\n\n    test('it returns the current protocol', () async {\n      final result = await subject();\n\n      expect(RegExp(r'^P\\w+$').hasMatch(result), true);\n    });\n  });\n\n  group('#counter()', () {\n    final address = 'tz1edmE1ZtizUW2qRj5XA2BLuiR8pRDnoBRg';\n    final subject = () => rpcInterface.counter(address);\n\n    test('it returns an int', () async {\n      final result = await subject();\n\n      expect(result, isA<int>());\n    });\n  });\n\n  group('#balance()', () {\n    final address = originator.address;\n    final subject = () => rpcInterface.balance(address);\n\n    test('it returns a positive number', () async {\n      final result = await subject();\n\n      expect(result, greaterThan(0));\n    });\n  });\n\n  group('#managerKey()', () {", "explanation": "Here is a concise summary:\n\nThis block appears to be a set of unit tests written in Dart, using the \"test\" library. It tests the functionality of an RPC (Remote Procedure Call) interface by calling various methods (chain id, protocol, counter, balance, and managerKey) and verifying that they return expected results or types.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/rpc/rpc_interface_test.dart", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and to-the-point holistic summary of the file 'test/core/rpc/rpc_interface_test.dart':\n\n**Unit Test Suite:** Tests the correctness of `RpcInterface` methods in a Tezos RPC interface, verifying expected outputs against actual results."}
{"code": "    final subject = (String address) => rpcInterface.managerKey(address);\n    group('when the address is revealed', () {\n      final address = originator.address;\n\n      test('it returns the public key', () async {\n        final result = await subject(address);\n\n        expect(result, equals(originator.publicKey));\n      });\n    });\n\n    group('when the address is unrevealed', () {\n      final address = Keystore.random().address;\n\n      test('it returns null', () async {\n        final result = await subject(address);\n\n        expect(result, isNull);\n      });\n    });\n  });\n\n  group('#pack()', () {\n    final subject =\n        ({required dynamic data, required Map<String, dynamic> type}) => rpcInterface.pack(data: data, type: type);\n\n    test('it packs data correctly', () async {\n      final data = {'int': '42'};\n      final type = {'prim': 'int'};\n\n      expect(await subject(data: data, type: type), '05002a');\n    });\n  });\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Test the functionality of two blocks in a Dart/Flutter application.\n\n**Functionality:**\n\n1. **managerKey()**: A function that returns the public key associated with an address.\n2. **pack()**: A function that packs data correctly based on a provided type.", "metadata": {"repo": "magiclabs/tezart", "file": "test/core/rpc/rpc_interface_test.dart", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and to-the-point holistic summary of the file 'test/core/rpc/rpc_interface_test.dart':\n\n**Unit Test Suite:** Tests the correctness of `RpcInterface` methods in a Tezos RPC interface, verifying expected outputs against actual results."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nimport 'package:test/test.dart';\nimport 'package:tezart/src/crypto/crypto.dart';\n\nvoid main() {\n  final type = CryptoErrorTypes.prefixNotFound;\n\n  group('when message is set', () {\n    final message = 'parameter message';\n    final subject = () => CryptoError(type: type, message: message);\n\n    test('it sets type correctly', () {\n      expect(subject().type, equals(type));\n    });\n\n    test('it sets message using parameter message', () {\n      expect(subject().message, equals(message));\n    });\n  });\n\n  group('when message is not set', () {\n    final subject = () => CryptoError(type: type);\n\n    test('it sets type correctly', () {\n      expect(subject().type, equals(type));\n    });\n\n    test('it sets message using static error messages', () {\n      expect(subject().message, equals('Prefix not found'));\n    });\n\n    test('it sets key correctly', () {\n      expect(subject().key, equals('prefixNotFound'));\n    });\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Test the `CryptoError` class functionality.\n\n**Functionality:** Validates that `CryptoError` instances are created with correct properties (type, message, key) when message is set or not set.", "metadata": {"repo": "magiclabs/tezart", "file": "test/crypto/crypto_error_test.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'test/crypto/crypto_error_test.dart':\n\n**Purpose:** Test `CryptoError` class functionality.\n\n**Functionality:** Verifies correct property settings, string conversion, exception handling, and error message generation."}
{"code": "    test('it converts to string correctly', () {\n      expect(subject().toString(), equals('CryptoError: got code prefixNotFound with msg `Prefix not found.`'));\n    });\n\n    test('it sets originalException to null', () {\n      expect(subject().originalException, equals(null));\n    });\n  });\n\n  group('when the error type is unhandled', () {\n    test('the message is computed dynamically', () {\n      final subject = () => CryptoError(type: CryptoErrorTypes.unhandled);\n      expect(subject().message, equals('Unhandled error: null'));\n    });\n  });\n}\n", "explanation": "This code block appears to be a set of tests for a `CryptoError` class in Dart programming language.\n\n**Purpose:** To verify the functionality of the `CryptoError` class.\n\n**Functionality:**\n\n* Verifies that the error message is correctly generated when converting to string.\n* Tests that the original exception is properly set to null.\n* Checks that an \"Unhandled\" error type produces a dynamically computed message.", "metadata": {"repo": "magiclabs/tezart", "file": "test/crypto/crypto_error_test.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'test/crypto/crypto_error_test.dart':\n\n**Purpose:** Test `CryptoError` class functionality.\n\n**Functionality:** Verifies correct property settings, string conversion, exception handling, and error message generation."}
{"code": "import 'dart:typed_data';\n\nimport 'package:test/test.dart';\nimport 'package:tezart/src/crypto/crypto.dart' as crypto;\nimport 'utils/common.dart' as crypto_common;\nimport 'expected_results/encode_decode.dart' as expected_results;\n\nvoid main() {\n  final encodedAddress = 'tz1XpNacx7vQ9y8ugdAc8p99LVfjudKjagVq';\n\n  // Encode\n  group('.encodeWithPrefix', () {\n    test('encodes addresses correctly', () {\n      expect(\n          crypto.encodeWithPrefix(prefix: crypto.Prefixes.tz1, bytes: expected_results.decodedAddress), encodedAddress);\n    });\n  });\n\n  // Decode\n  group('.decodeWithoutPrefix', () {\n    test('decodes an address correctly', () {\n      expect(crypto.decodeWithoutPrefix(encodedAddress), expected_results.decodedAddress);\n    });\n  });\n\n  test('.ignorePrefix throw error', () {\n    expect(() => crypto.ignorePrefix(crypto_common.fakeUint8List()),\n        throwsA(predicate((e) => e is crypto.CryptoError && e.type == crypto.CryptoErrorTypes.prefixNotFound)));\n  });\n\n  test('.hexDecode', () {", "explanation": "Here is a concise summary of the block's purpose and functionality:\n\n**Purpose:** Unit tests for encoding and decoding Tezos addresses using the `tezart` library.\n\n**Functionality:**\n\n* Tests the `.encodeWithPrefix()` method, which encodes an address with a prefix (e.g. 'tz1').\n* Tests the `.decodeWithoutPrefix()` method, which decodes an encoded address without a prefix.\n* Verifies that the `.ignorePrefix()` method throws an error when given an invalid prefix.\n* Tests the `.hexDecode()` method is not explicitly tested in this block.", "metadata": {"repo": "magiclabs/tezart", "file": "test/crypto/encode_decode_test.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'test/crypto/encode_decode_test.dart':\n\nThis test suite validates the encoding and decoding functionality of the `tezart` library, specifically the `.encodeWithPrefix()` and `.decodeWithoutPrefix()` methods of the `crypto` class. It also checks that the `.ignorePrefix()` method correctly throws an error for invalid prefixes."}
{"code": "    final encodedString = '12346789abcdef';\n    final expectedResult = [18, 52, 103, 137, 171, 205, 239];\n    final result = crypto.hexDecode(encodedString);\n\n    expect(result, equals(expectedResult));\n  });\n\n  test('.hexEncode', () {\n    final decodedList = Uint8List.fromList([1, 200, 434, 292]);\n    final expectedResult = '01c8b224';\n    final result = crypto.hexEncode(decodedList);\n\n    expect(result, equals(expectedResult));\n  });\n}\n", "explanation": "Here is a concise summary:\n\nThis block tests the functionality of a `crypto` class with two methods: `.hexDecode` (decodes a hexadecimal string into an array) and `.hexEncode` (encodes an array into a hexadecimal string).", "metadata": {"repo": "magiclabs/tezart", "file": "test/crypto/encode_decode_test.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary of the file 'test/crypto/encode_decode_test.dart':\n\nThis test suite validates the encoding and decoding functionality of the `tezart` library, specifically the `.encodeWithPrefix()` and `.decodeWithoutPrefix()` methods of the `crypto` class. It also checks that the `.ignorePrefix()` method correctly throws an error for invalid prefixes."}
{"code": "import 'dart:typed_data';\n\nfinal decodedAddress = Uint8List.fromList(<int>[\n  133,\n  150,\n  69,\n  73,\n  131,\n  91,\n  131,\n  238,\n  27,\n  209,\n  60,\n  160,\n  78,\n  103,\n  17,\n  231,\n  140,\n  79,\n  21,\n  176,\n]);\n", "explanation": "This block of code creates a `Uint8List` from a list of integers, representing a binary encoded address.", "metadata": {"repo": "magiclabs/tezart", "file": "test/crypto/expected_results/encode_decode.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise summary:\n\n**Summary:** This Dart file (`encode_decode.dart`) generates a binary-encoded address by converting an integer list into a `Uint8List`, used for encoding/decoding cryptocurrency addresses."}
{"code": "final secretKeyFromMnemonic = [\n  98,\n  205,\n  166,\n  170,\n  210,\n  8,\n  237,\n  237,\n  195,\n  178,\n  37,\n  31,\n  210,\n  237,\n  240,\n  73,\n  87,\n  247,\n  165,\n  70,\n  0,\n  137,\n  133,\n  110,\n  21,\n  130,\n  35,\n  21,\n  173,\n  194,\n  215,\n  96\n];\n\nfinal secretKeyBytesFromSeed = [\n  1,\n  2,\n  3,\n  4,\n  5,\n  6,\n  7,\n  8,\n  9,\n  10,\n  11,\n  12,\n  13,\n  14,\n  15,\n  16,\n  17,\n  18,\n  19,\n  20,\n  21,\n  22,\n  23,\n  24,\n  25,\n  26,\n  27,\n  28,\n  29,\n  30,\n  31,\n  32,\n  121,\n  181,\n  86,\n  46,\n  143,\n  230,\n  84,\n  249,\n  64,\n  120,\n  177,\n  18,\n  232,\n  169,\n  139,\n  167,\n  144,\n  31,\n  133,\n  58,\n  230,\n  149,\n  190,\n  215,\n  224,\n  227,\n  145,\n  11,\n  173,\n  4,\n  150,\n  100\n];\n\nfinal signatureBytes = [\n  203,\n  80,\n  16,\n  44,\n  139,\n  213,\n  158,\n  96,\n  34,\n  53,\n  98,\n  245,\n  153,\n  40,\n  235,\n  186,\n  132,\n  236,\n  91,\n  72,\n  92,\n  234,\n  117,\n  11,\n  26,\n  127,\n  84,\n  185,\n  113,\n  237,\n  11,\n  80,\n  70,\n  113,\n  170,\n  221,\n  240,\n  162,\n  160,\n  165,\n  35,\n  196,\n  63,\n  172,\n  48,\n  180,\n  105,\n  36,\n  104,\n  15,\n  98,\n  90,\n  205,\n  35,\n  174,\n  179,\n  255,\n  23,\n  146,\n  83,\n  169,\n  227,\n  183,\n  7,\n];\n", "explanation": "This block contains three arrays of integers, representing:\n\n1. A secret key derived from a mnemonic phrase\n2. A secret key generated from a seed value\n3. Signature bytes ( likely for authentication or verification purposes)", "metadata": {"repo": "magiclabs/tezart", "file": "test/crypto/expected_results/external_crypto_wrapper.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and holistic summary of the file 'test/crypto/expected_results/external_crypto_wrapper.dart':\n\n**Expected crypto results**\n\nThis file contains pre-computed crypto values:\n\n1. A **derived secret key** from a mnemonic phrase\n2. A **generated secret key** from a seed value\n3. **Signature bytes** for authentication or verification purposes"}
{"code": "import 'package:test/test.dart';\nimport 'package:tezart/src/crypto/crypto.dart';\nimport 'utils/common.dart' as crypto_common;\nimport 'expected_results/external_crypto_wrapper.dart' as expected_results;\n\nvoid main() {\n  const mnemonic =\n      'brief hello carry loop squeeze unknown click abstract lounge figure logic oblige child ripple about vacant scheme magnet open enroll stuff valve hobby what';\n\n  group('.secretKeyBytesFromMnemonic', () {\n    test('returns valid SigningKey', () {\n      final secretKeyBytes = seedBytesFromMnemonic(mnemonic);\n      expect(secretKeyBytes, equals(expected_results.secretKeyFromMnemonic));\n    });\n  });\n\n  group('.secretKeyBytesFromSeed', () {\n    test('returns valid secret key', () {\n      final secretKeyBytes = secretKeyBytesFromSeedBytes(crypto_common.fakeUint8List());\n\n      expect(secretKeyBytes, equals(expected_results.secretKeyBytesFromSeed));\n    });\n  });\n\n  group('.signDetached', () {\n    final secretKey = seedBytesFromMnemonic(mnemonic);\n", "explanation": "This block is a test suite written in Dart, using the `test` package. It tests three functions:\n\n* `.secretKeyBytesFromMnemonic`: Verifies that a signing key can be generated from a mnemonic phrase.\n* `.secretKeyBytesFromSeed`: Tests that a secret key can be derived from a seed byte list.\n* `.signDetached`: (Not fully implemented) Intends to verify detached signing functionality, but is currently incomplete.", "metadata": {"repo": "magiclabs/tezart", "file": "test/crypto/external_crypto_wrapper_test.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and to-the-point summary of the `test/crypto/external_crypto_wrapper_test.dart` file:\n\n\"Test suite for external crypto wrapper, covering secret key generation from mnemonic phrases and seed bytes, as well as detached signing functionality (incomplete).\""}
{"code": "    test('returns valid signature bytes', () {\n      final bytes = crypto_common.fakeUint8List();\n      final sig = signDetached(bytes: bytes, secretKey: secretKey);\n\n      expect(sig, equals(expected_results.signatureBytes));\n    });\n  });\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Test detached signature functionality\n**Functionality:** Verifies that a signed Uint8List returns expected signature bytes.", "metadata": {"repo": "magiclabs/tezart", "file": "test/crypto/external_crypto_wrapper_test.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise and to-the-point summary of the `test/crypto/external_crypto_wrapper_test.dart` file:\n\n\"Test suite for external crypto wrapper, covering secret key generation from mnemonic phrases and seed bytes, as well as detached signing functionality (incomplete).\""}
{"code": "import 'dart:typed_data';\n\nUint8List fakeUint8List() {\n  final values = List<int>.generate(32, (index) => index + 1);\n  return Uint8List.fromList(values);\n}\n", "explanation": "This block of code defines a function `fakeUint8List` that creates a mock `Uint8List` with a length of 32, containing integers from 1 to 32.", "metadata": {"repo": "magiclabs/tezart", "file": "test/crypto/utils/common.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary of the file 'test/crypto/utils/common.dart':\n\n\"This Dart file contains a utility function `fakeUint8List` that generates a mock Uint8List with 32 elements, initialized with integers ranging from 1 to 32.\""}
{"code": "import 'package:envify/envify.dart';\npart 'env.g.dart';\n\n@Envify(path: '.env.test')\nabstract class Env {\n  static const tezosNodeUrl = _Env.tezosNodeUrl;\n  static const originatorSk = _Env.originatorSk;\n  static const logLevel = _Env.logLevel;\n}\n", "explanation": "**Summary**\n\nThis block imports a configuration file (`envify`) and generates an `env.g.dart` file. It defines an abstract class `Env` with static properties that load environment variables from the `.env.test` file, making them accessible throughout the application.", "metadata": {"repo": "magiclabs/tezart", "file": "test/env/env.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)", "file_summary": "Here is a concise holistic summary of the file 'test/env/env.dart':\n\n**Summary**\n\nThis Dart file imports configuration settings, generates an env.g.dart file, and defines an abstract Env class that loads environment variables from .env.test, making them accessible app-wide."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nimport 'dart:typed_data';\n\nimport 'package:test/test.dart';\nimport 'package:tezart/src/keystore/keystore.dart';\nimport 'package:tezart/src/signature/signature.dart';\n\nvoid main() {\n  const mnemonic =\n      'brief hello carry loop squeeze unknown click abstract lounge figure logic oblige child ripple about vacant scheme magnet open enroll stuff valve hobby what';\n\n  test('.random', () {\n    final keystore = Keystore.random();\n    expect(keystore.mnemonic, isNotNull);\n  });\n\n  group('.fromMnemonic', () {\n    group('when the mnemonic is valid', () {\n      group('when the mnemonic is not encrypted by email/password', () {\n        final subject = () => Keystore.fromMnemonic(mnemonic);\n\n        test('sets mnemonic correctly', () {\n          expect(subject().mnemonic, mnemonic);\n        });\n\n        test('computes secretKey correctly', () {\n          expect(subject().secretKey,", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** A set of unit tests for the `Keystore` class in the Tezart package.\n\n**Functionality:** Tests the generation of random keystores, as well as the creation of keystores from valid mnemonics.", "metadata": {"repo": "magiclabs/tezart", "file": "test/keystore/keystore_test.dart", "chunk_number": 1, "total_chunks": 10}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)"}
{"code": "              'edskRpwW3bAgx7GsbyTrbb5NUP7b1tz34AvfV2Vm4En5LgEzeUmg3Ys815UDYNNFG6JvrrGqA9CNU2h8hsLVVLfuEQPkZNtkap');\n        });\n      });\n\n      group('when the mnemonic is encrypted by email/password', () {\n        final subject = () => Keystore.fromMnemonic(mnemonic, password: 'password', email: 'email@example.com');\n\n        test('it sets mnemonic correctly', () {\n          expect(subject().mnemonic, mnemonic);\n        });\n\n        test('it sets secret key correctly', () {\n          const secretKey =\n              'edskS3jw3crpqkhuJZAuJMFLB4ZDvXGcm5nEWfgypk6gSyg17ZCnDbVLHupxNTUUrrQLiakgvcjsi4vNyduzyWaVUX5LHXE8Bf';\n          expect(subject().secretKey, secretKey);\n        });\n      });\n    });\n\n    group('when the mnemonic is invalid', () {\n      final subject = (String mnemonic) => Keystore.fromMnemonic(mnemonic);\n      group('when the mnemonic is short', () {\n        const mnemonic = 'brief hello';\n\n        test('it throws an error', () {\n          expect(() => subject(mnemonic),", "explanation": "**Summary**\n\nThis block of code tests the functionality of a `Keystore` class when creating it from a mnemonic phrase. It covers three scenarios:\n\n1. When the mnemonic is encrypted with email/password: Verifies that the mnemonic and secret key are set correctly.\n2. When the mnemonic is invalid (short): Ensures an error is thrown.\n\n**Purpose**\n\nTo test the correctness of the `Keystore` class when creating it from a mnemonic phrase under different conditions.", "metadata": {"repo": "magiclabs/tezart", "file": "test/keystore/keystore_test.dart", "chunk_number": 2, "total_chunks": 10}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)"}
{"code": "              throwsA(predicate((e) => e is CryptoError && e.type == CryptoErrorTypes.invalidMnemonic)));\n        });\n      });\n\n      group('when the mnemonic contains an unknown word', () {\n        const mnemonic =\n            'toto hello carry loop squeeze unknown click abstract lounge figure logic oblige child ripple about vacant scheme magnet open enroll stuff valve hobby what';\n\n        test('it throws an error', () {\n          expect(() => subject(mnemonic),\n              throwsA(predicate((e) => e is CryptoError && e.type == CryptoErrorTypes.invalidMnemonic)));\n        });\n      });\n    });\n  });\n\n  group('.fromSecretKey', () {\n    final subject = (String secretKey) => Keystore.fromSecretKey(secretKey);\n\n    group('when the secret key is valid', () {\n      final secretKey =\n          'edskRpwW3bAgx7GsbyTrbb5NUP7b1tz34AvfV2Vm4En5LgEzeUmg3Ys815UDYNNFG6JvrrGqA9CNU2h8hsLVVLfuEQPkZNtkap';\n\n      test('sets secretKey correctly', () {\n        expect(subject(secretKey).secretKey, secretKey);\n      });\n", "explanation": "Here is a summary of the purpose and functionality of this block:\n\n**Purpose:** Test cases for Keystore.fromMnemonic() and Keystore.fromSecretKey()\n\n**Functionality:**\n\n* Tests that incorrect mnemonic phrases throw an error\n* Tests that secret keys are validated correctly when creating a Keystore from a secret key", "metadata": {"repo": "magiclabs/tezart", "file": "test/keystore/keystore_test.dart", "chunk_number": 3, "total_chunks": 10}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)"}
{"code": "      test('sets mnemonic to null', () {\n        expect(subject(secretKey).mnemonic, null);\n      });\n\n      test('it computes the seed correctly', () {\n        expect(subject(secretKey).seed, 'edsk3RR5U7JsUJ8ctjsuymUPayxMm4LHXaB7VJSfeyMb8fAvbJUnsa');\n      });\n    });\n\n    group('when the secret key has invalid checksum', () {\n      final secretKey =\n          'edskRpwW3bAgx7GsbyTrbb5NUP7b1tz34AvfV2Vm4En5LgEzeUmg3Ys815UDYNNFG6JvrrGqA9CNU2h8hsLVVLfuEQPkZNtkaa';\n\n      test('it throws an error', () {\n        expect(() => subject(secretKey),\n            throwsA(predicate((e) => e is CryptoError && e.type == CryptoErrorTypes.invalidChecksum)));\n      });\n    });\n\n    group('when the input is a seed', () {\n      final secretKey = 'edsk3RR5U7JsUJ8ctjsuymUPayxMm4LHXaB7VJSfeyMb8fAvbJUnsa';\n\n      test('throws an error', () {\n        expect(() => subject(secretKey),\n            throwsA(predicate((e) => e is CryptoError && e.type == CryptoErrorTypes.secretKeyLengthError)));\n      });\n    });\n  });\n", "explanation": "This block of code is a set of test cases for a function called `subject`. The purpose is to verify the functionality of `subject` when given different inputs, specifically:\n\n* Verifying that it correctly sets mnemonic to null\n* Checking if it computes seed correctly\n* Testing error handling when input has invalid checksum or wrong length.", "metadata": {"repo": "magiclabs/tezart", "file": "test/keystore/keystore_test.dart", "chunk_number": 4, "total_chunks": 10}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)"}
{"code": "  group('.fromSeed', () {\n    final subject = (String seed) => Keystore.fromSeed(seed);\n\n    group('when the seed is valid', () {\n      final secretKey =\n          'edskRpwW3bAgx7GsbyTrbb5NUP7b1tz34AvfV2Vm4En5LgEzeUmg3Ys815UDYNNFG6JvrrGqA9CNU2h8hsLVVLfuEQPkZNtkap';\n      final seed = 'edsk3RR5U7JsUJ8ctjsuymUPayxMm4LHXaB7VJSfeyMb8fAvbJUnsa';\n\n      test('sets secretKey correctly', () {\n        expect(subject(seed).secretKey, secretKey);\n      });\n\n      test('sets mnemonic to null', () {\n        expect(subject(seed).mnemonic, null);\n      });\n\n      test('it computes the seed correctly', () {\n        expect(subject(seed).seed, seed);\n      });\n    });\n\n    group('when the input is a secret key', () {\n      final seed = 'edskRpwW3bAgx7GsbyTrbb5NUP7b1tz34AvfV2Vm4En5LgEzeUmg3Ys815UDYNNFG6JvrrGqA9CNU2h8hsLVVLfuEQPkZNtkap';\n\n      test('throws an error', () {\n        expect(() => subject(seed),\n            throwsA(predicate((e) => e is CryptoError && e.type == CryptoErrorTypes.seedLengthError)));\n      });\n    });\n", "explanation": "**Purpose:** This block tests a Keystore.fromSeed function.\n\n**Functionality:**\n\n1. Tests that the function correctly sets a secret key, mnemonic, and seed based on a valid input string.\n2. Tests that the function throws an error when given a secret key instead of a string.\n3. Uses unit tests to verify the correctness of the function's behavior in different scenarios.", "metadata": {"repo": "magiclabs/tezart", "file": "test/keystore/keystore_test.dart", "chunk_number": 5, "total_chunks": 10}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)"}
{"code": "    group('when the seed has invalid checksum', () {\n      final seed = 'edsk3RR5U7JsUJ8ctjsuymUPayxMm4LHXaB7VJSfeyMb8fAvbJUnsb';\n\n      test('it throws an error', () {\n        expect(() => subject(seed),\n            throwsA(predicate((e) => e is CryptoError && e.type == CryptoErrorTypes.invalidChecksum)));\n      });\n    });\n  });\n\n  group('.fromEncryptedSecretKey', () {\n    final encryptedSecretKey =\n        'edesk1RxJkKzwYCcSz4hFy7FiQTPFB6otnmedkjU5REc3bYcpJ3fK6QpaJ1q8Dc8WnWpRKdoaoUjSJ4D4Aa8kLCp';\n    final decryptedSecretKey =\n        'edskRczqu5WF9zZ2Pm1zAx7s5tfoBBW8t4S8BHRhixggUzSptxAaURSdiNmsE9UMEierbzSPSBshKc7XP4N8eHTaamPrPoq4dz';\n    final passphrase = 'passphrase';\n\n    group('when encryptedSecretKey and passphrase are valid', () {\n      test('sets secretKey correctly', () {\n        final subject = () => Keystore.fromEncryptedSecretKey(encryptedSecretKey, passphrase);\n\n        final keystore = subject();\n\n        expect(keystore.secretKey, decryptedSecretKey);\n      });\n    });\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Test cases for `Keystore` class functionality.\n\n**Functionality:**\n\n1. Verifies that an error is thrown when attempting to create a Keystore from a seed with invalid checksum.\n2. Tests that `.fromEncryptedSecretKey` method correctly decrypts and sets the secret key using valid encrypted key and passphrase.", "metadata": {"repo": "magiclabs/tezart", "file": "test/keystore/keystore_test.dart", "chunk_number": 6, "total_chunks": 10}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)"}
{"code": "    group('when encryptedSecretKey length is invalid', () {\n      test('throws encryptedSecretKeyLengthError error', () {\n        final truncatedEncryptedSecretKey = encryptedSecretKey.substring(0, encryptedSecretKey.length - 1);\n        final subject = () => Keystore.fromEncryptedSecretKey(truncatedEncryptedSecretKey, passphrase);\n\n        expect(() => subject(),\n            throwsA(predicate((e) => e is CryptoError && e.type == CryptoErrorTypes.encryptedSecretKeyLengthError)));\n      });\n    });\n\n    group('when passphrase is invalid', () {\n      test('throws CryptoError of type unhandled', () {\n        final truncatedPassphrase = passphrase.substring(0, passphrase.length - 1);\n        final subject = () => Keystore.fromEncryptedSecretKey(encryptedSecretKey, truncatedPassphrase);\n\n        expect(() => subject(), throwsA(predicate((e) => e is CryptoError && e.type == CryptoErrorTypes.unhandled)));\n      });\n\n      test('throws CryptoError with the correct errorMessage', () {", "explanation": "**Purpose:** This block tests error handling in the `Keystore.fromEncryptedSecretKey` method.\n\n**Functionality:**\n\n* Tests that an `encryptedSecretKeyLengthError` is thrown when an invalid encrypted secret key length is provided.\n* Tests that a `CryptoError` with type `unhandled` and correct error message is thrown when an invalid passphrase is provided.", "metadata": {"repo": "magiclabs/tezart", "file": "test/keystore/keystore_test.dart", "chunk_number": 7, "total_chunks": 10}, "repository_explanation": "This is a GitHub repository.\n\n**Repository Name:** magiclabs/tezart\n\n**Purpose:** TezArt\n\n**Content:** (Information not provided in your query)"}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nimport 'package:test/test.dart';\nimport 'package:tezart/src/contracts/contract.dart';\nimport 'package:tezart/src/micheline_decoder/micheline_decoder.dart';\n\nvoid main() {\n  final subject = (Map<String, dynamic> type, dynamic data) => MichelineDecoder(type: type, data: data).decode();\n\n  final data = {\n    'prim': 'Pair',\n    'args': [\n      {\n        'prim': 'Pair',\n        'args': [\n          {'int': '70'},\n          {'string': 'tz1ZWiiPXowuhN1UqNGVTrgNyf5tdxp4XUUq'}\n        ]\n      },\n      {'int': '71'}\n    ]\n  };\n\n  final type = {\n    'prim': 'pair',\n    'args': [\n      {\n        'prim': 'pair',\n        'args': [\n          {\n            'prim': 'big_map',\n            'args': [\n              {'prim': 'string'},\n              {\n                'prim': 'pair',\n                'args': [\n                  {\n                    'prim': 'address',\n                    'annots': ['%contract_address']\n                  },\n                  {", "explanation": "**Summary**\n\nThis block is a unit test written in Dart, using the `test` package. It tests the functionality of the `MichelineDecoder` class from the `tezart` package. The test decodes a Micheline-encoded data structure and verifies its correctness.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_decoder/big_map_decoder_test.dart", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "", "file_summary": "Here's a concise summary:\n\nThis unit test for MichelineDecoder decodes a predefined data structure (with contracts, owner, and spendings elements) from Micheline-encoded format and verifies its correctness."}
{"code": "                    'prim': 'key',\n                    'annots': ['%contract_owner']\n                  }\n                ]\n              }\n            ],\n            'annots': ['%contracts']\n          },\n          {\n            'prim': 'address',\n            'annots': ['%owner']\n          }\n        ]\n      },\n      {\n        'prim': 'big_map',\n        'args': [\n          {'prim': 'string'},\n          {'prim': 'address'}\n        ],\n        'annots': ['%spendings']\n      }\n    ]\n  };\n  test('it decodes data correctly', () {\n    final result = subject(type, data);\n    expect(result, {\n      'contracts': isA<BigMap>(),\n      'owner': 'tz1ZWiiPXowuhN1UqNGVTrgNyf5tdxp4XUUq',\n      'spendings': isA<BigMap>(),\n    });\n\n    expect(result['contracts'], isA<BigMap>());\n    final BigMap contractsBigMap = result['contracts'];\n    expect(contractsBigMap.id, '70');\n    expect(\n      contractsBigMap.valueType,\n      {\n        'prim': 'pair',\n        'args': [\n          {\n            'prim': 'address',", "explanation": "Here is a concise summary:\n\nThis block defines a data structure with three elements: `contracts`, `owner`, and `spendings`. Each element has specific characteristics, such as data type (e.g., `BigMap`) and annotated keys (e.g., `%contract_owner`). The purpose of this block is to define the format of some data for decoding purposes.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_decoder/big_map_decoder_test.dart", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "", "file_summary": "Here's a concise summary:\n\nThis unit test for MichelineDecoder decodes a predefined data structure (with contracts, owner, and spendings elements) from Micheline-encoded format and verifies its correctness."}
{"code": "            'annots': ['%contract_address']\n          },\n          {\n            'prim': 'key',\n            'annots': ['%contract_owner']\n          }\n        ]\n      },\n    );\n\n    expect(contractsBigMap.keyType, {'prim': 'string'});\n    expect(contractsBigMap.name, 'contracts');\n  });\n}\n", "explanation": "This block appears to be a test snippet in a programming language (likely JavaScript with Jest) that:\n\n* Defines two key-value pairs for an object\n* Asserts that the `keyType` property of a `BigMap` instance named \"contracts\" is 'string'\n* Also asserts that the `name` property of the same BigMap instance is \"contracts\".", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_decoder/big_map_decoder_test.dart", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "", "file_summary": "Here's a concise summary:\n\nThis unit test for MichelineDecoder decodes a predefined data structure (with contracts, owner, and spendings elements) from Micheline-encoded format and verifies its correctness."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nimport 'package:test/test.dart';\nimport 'package:tezart/src/micheline_decoder/impl/micheline_decoder.dart';\n\nvoid main() {\n  final subject = (Map<String, dynamic> type, dynamic data) => MichelineDecoder(type: type, data: data).decode();\n\n  final data = [\n    {\n      'prim': 'Pair',\n      'args': [\n        {'string': 'txrsh'},\n        {'string': '001'}\n      ]\n    },\n    {\n      'prim': 'Pair',\n      'args': [\n        {'string': '2'},\n        {'string': '002'}\n      ]\n    }\n  ];\n  final type = {\n    'prim': 'list',\n    'args': [\n      {\n        'prim': 'pair',\n        'args': [\n          {\n            'prim': 'string',\n            'annots': ['%reference']\n          },\n          {\n            'prim': 'string',\n            'annots': ['%id']\n          }\n        ]\n      }\n    ]\n  };\n\n  test('it returns the correct value', () {\n    final expectedResult = [\n      {'reference': 'txrsh', 'id': '001'},\n      {'reference': '2', 'id': '002'}\n    ];\n", "explanation": "**Purpose:** Unit testing a Micheline decoder implementation using the Test package.\n\n**Functionality:**\n\nThis code sets up test cases for decoding Micheline data with a specific type, verifying that the decoded values match expected results. It uses the `test` function from the `package:test/test.dart` library to run tests.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_decoder/list_decoder_test.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "", "file_summary": "Here's a concise summary:\n\n**Summary:** Unit test file for Micheline decoder implementation, verifying correct decoding of data with specific types using the Test package."}
{"code": "    expect(subject(type, data), expectedResult);\n  });\n}\n", "explanation": "This block is an expectation statement, used in testing to verify that a specific outcome matches an expected result.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_decoder/list_decoder_test.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "", "file_summary": "Here's a concise summary:\n\n**Summary:** Unit test file for Micheline decoder implementation, verifying correct decoding of data with specific types using the Test package."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nimport 'package:test/test.dart';\nimport 'package:tezart/src/micheline_decoder/impl/micheline_decoder.dart';\n\nvoid main() {\n  final subject = (Map<String, dynamic> type, dynamic data) => MichelineDecoder(type: type, data: data).decode();\n\n  final type = {\n    'prim': 'pair',\n    'args': [\n      {\n        'prim': 'key',\n        'annots': ['%pub_key']\n      },\n      {\n        'prim': 'map',\n        'args': [\n          {'prim': 'string'},\n          {\n            'prim': 'pair',\n            'args': [\n              {\n                'prim': 'pair',\n                'args': [\n                  {\n                    'prim': 'pair',\n                    'args': [\n                      {\n                        'prim': 'timestamp',\n                        'annots': ['%date']\n                      },\n                      {\n                        'prim': 'nat',\n                        'annots': ['%price']\n                      }\n                    ]", "explanation": "Here is a concise summary:\n\n**Purpose:** Test the MichelineDecoder functionality.\n\n**Functionality:** Decodes Micheline data using a custom decoder, with input types defined as a nested JSON-like structure.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_decoder/map_decoder_test.dart", "chunk_number": 1, "total_chunks": 4}, "repository_explanation": "", "file_summary": "Here is a concise summary of the file 'test/micheline_decoder/map_decoder_test.dart':\n\n**Purpose:** Test MichelineDecoder functionality by verifying correct decoding of complex data structures.\n\n**Functionality:** Decode nested maps with various types (strings, integers, dates, etc.) using custom decoder and test expected outputs for different scenarios."}
{"code": "                  },\n                  {\n                    'prim': 'string',\n                    'annots': ['%ref']\n                  }\n                ]\n              },\n              {\n                'prim': 'nat',\n                'annots': ['%amount']\n              }\n            ]\n          }\n        ],\n        'annots': ['%spendings']\n      }\n    ]\n  };\n\n  group('when the map contains elements', () {\n    final data = {\n      'prim': 'Pair',\n      'args': [\n        {'string': 'edpkvWLnfNsAKhWEDafxHaTmE8qtK19fSDJYAnLfg7J5Qf5jbkKgTW'},\n        [\n          {\n            'prim': 'Elt',\n            'args': [\n              {'string': '001'},\n              {\n                'prim': 'Pair',\n                'args': [\n                  {\n                    'prim': 'Pair',\n                    'args': [\n                      {\n                        'prim': 'Pair',\n                        'args': [\n                          {'string': '2020-04-27T13:48:28Z'},\n                          {'int': '6000'}\n                        ]", "explanation": "**Purpose:** Define a data structure with a list of key-value pairs.\n\n**Functionality:** The code defines a map (data structure) that contains multiple elements, including strings, integers, dates, and other nested maps. It uses a specific format with `prim` and `annots` fields to define the type and annotations for each element.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_decoder/map_decoder_test.dart", "chunk_number": 2, "total_chunks": 4}, "repository_explanation": "", "file_summary": "Here is a concise summary of the file 'test/micheline_decoder/map_decoder_test.dart':\n\n**Purpose:** Test MichelineDecoder functionality by verifying correct decoding of complex data structures.\n\n**Functionality:** Decode nested maps with various types (strings, integers, dates, etc.) using custom decoder and test expected outputs for different scenarios."}
{"code": "                      },\n                      {'string': 'HEALTH_PRACTITIONER_EG4WA'}\n                    ]\n                  },\n                  {'int': '1000'}\n                ]\n              }\n            ]\n          }\n        ]\n      ]\n    };\n\n    test('it returns a valid value', () {\n      final expectedResult = {\n        'pub_key': 'edpkvWLnfNsAKhWEDafxHaTmE8qtK19fSDJYAnLfg7J5Qf5jbkKgTW',\n        'spendings': {\n          '001': {\n            'date': DateTime.parse('2020-04-27T13:48:28Z'),\n            'price': 6000,\n            'ref': 'HEALTH_PRACTITIONER_EG4WA',\n            'amount': 1000\n          }\n        },\n      };\n\n      expect(subject(type, data), expectedResult);\n    });\n  });\n\n  group('when the map is empty', () {\n    final data = {\n      'prim': 'Pair',\n      'args': [\n        {'string': 'edpkvH2XCYHmU2cpJxzQxzaJ9iMfmvkvSixFsEE1KqEmXBQeFq78PT'},\n        []\n      ]\n    };\n\n    test('it returns a valid value', () {\n      final expectedResult = {", "explanation": "Here is a concise summary of the purpose and functionality:\n\n**Purpose:** This block appears to be testing the functionality of a function or method (`subject`) that processes input data.\n\n**Functionality:** The `subject` function takes two inputs, `type` and `data`, and returns an expected result. The test cases cover scenarios where the `data` is empty or non-empty, and verify that the returned value matches the expected output.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_decoder/map_decoder_test.dart", "chunk_number": 3, "total_chunks": 4}, "repository_explanation": "", "file_summary": "Here is a concise summary of the file 'test/micheline_decoder/map_decoder_test.dart':\n\n**Purpose:** Test MichelineDecoder functionality by verifying correct decoding of complex data structures.\n\n**Functionality:** Decode nested maps with various types (strings, integers, dates, etc.) using custom decoder and test expected outputs for different scenarios."}
{"code": "        'pub_key': 'edpkvH2XCYHmU2cpJxzQxzaJ9iMfmvkvSixFsEE1KqEmXBQeFq78PT',\n        'spendings': {},\n      };\n\n      expect(subject(type, data), expectedResult);\n    });\n  });\n}\n", "explanation": "This block appears to be a test case for a function `subject` with two parameters: `type` and `data`. The purpose is to test the function's behavior with specific input data, specifically a public key and an empty spending object.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_decoder/map_decoder_test.dart", "chunk_number": 4, "total_chunks": 4}, "repository_explanation": "", "file_summary": "Here is a concise summary of the file 'test/micheline_decoder/map_decoder_test.dart':\n\n**Purpose:** Test MichelineDecoder functionality by verifying correct decoding of complex data structures.\n\n**Functionality:** Decode nested maps with various types (strings, integers, dates, etc.) using custom decoder and test expected outputs for different scenarios."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nimport 'package:test/test.dart';\nimport 'package:tezart/src/micheline_decoder/micheline_decoder.dart';\n\nvoid main() {\n  final subject = (Map<String, dynamic> type, dynamic data) => MichelineDecoder(type: type, data: data).decode();\n\n  group('when the data is annotated', () {\n    final data = {\n      'prim': 'Pair',\n      'args': [\n        {'bytes': '00886860e486f58c10f8f01d2dac7853f0cc5266deab1e275b287ecae9e4dec586'},\n        [\n          {\n            'prim': 'Pair',\n            'args': [\n              {\n                'prim': 'Pair',\n                'args': [\n                  {\n                    'prim': 'Pair',\n                    'args': [\n                      {\n                        'prim': 'Pair',\n                        'args': [\n                          {'int': '9876543'},\n                          {'int': '60'}\n                        ]\n                      },\n                      {'string': 'txrsh'}\n                    ]", "explanation": "**Purpose:** Unit testing of MichelineDecoder functionality.\n\n**Functionality:** Tests the decoding of annotated data using the MichelineDecoder class, verifying correct parsing of various data types (e.g., integers, strings).", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_decoder/micheline_decoder_test.dart", "chunk_number": 1, "total_chunks": 4}, "repository_explanation": "", "file_summary": "Here is a concise summary of the file 'test/micheline_decoder/micheline_decoder_test.dart':\n\n**Summary:** Unit tests for MichelineDecoder, verifying correct decoding of annotated JSON data into various formats."}
{"code": "                  },\n                  {'int': '10'}\n                ]\n              },\n              {'string': '001'}\n            ]\n          }\n        ]\n      ]\n    };\n\n    final type = {\n      'prim': 'pair',\n      'args': [\n        {\n          'prim': 'key',\n          'annots': ['%pub_key']\n        },\n        {\n          'prim': 'list',\n          'args': [\n            {\n              'prim': 'pair',\n              'args': [\n                {\n                  'prim': 'pair',\n                  'args': [\n                    {\n                      'prim': 'pair',\n                      'args': [\n                        {\n                          'prim': 'pair',\n                          'args': [\n                            {\n                              'prim': 'timestamp',\n                              'annots': ['%date']\n                            },\n                            {\n                              'prim': 'int',\n                              'annots': ['%price']\n                            }", "explanation": "This appears to be a JSON data structure, containing a nested array of objects with various keys (\"string\", \"int\", \"pair\", etc.) and values. The purpose is unclear without more context, but it seems to represent some sort of structured data or configuration.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_decoder/micheline_decoder_test.dart", "chunk_number": 2, "total_chunks": 4}, "repository_explanation": "", "file_summary": "Here is a concise summary of the file 'test/micheline_decoder/micheline_decoder_test.dart':\n\n**Summary:** Unit tests for MichelineDecoder, verifying correct decoding of annotated JSON data into various formats."}
{"code": "                          ]\n                        },\n                        {\n                          'prim': 'string',\n                          'annots': ['%ref']\n                        }\n                      ]\n                    },\n                    {\n                      'prim': 'int',\n                      'annots': ['%amount']\n                    }\n                  ]\n                },\n                {\n                  'prim': 'string',\n                  'annots': ['%reference']\n                }\n              ]\n            }\n          ],\n          'annots': ['%spendings']\n        }\n      ]\n    };\n\n    test('it decodes data correctly', () {\n      final expectedResult = {\n        'pub_key': 'edpkugJHjEZLNyTuX3wW2dT4P7PY5crLqq3zeDFvXohAs3tnRAaZKR',\n        'spendings': [\n          {\n            'date': isA<DateTime>(),\n            'price': 60,\n            'ref': 'txrsh',\n            'amount': 10,\n            'reference': '001',\n          }\n        ]\n      };\n      final result = subject(type, data);\n", "explanation": "Here is a summary of the purpose and functionality of this block:\n\n**Decoding JSON Data**\n\nThis code snippet appears to be a test case for decoding JSON data into a specific format. It tests a function `subject` with a given type and data, verifying that it correctly decodes the data into an expected result object.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_decoder/micheline_decoder_test.dart", "chunk_number": 3, "total_chunks": 4}, "repository_explanation": "", "file_summary": "Here is a concise summary of the file 'test/micheline_decoder/micheline_decoder_test.dart':\n\n**Summary:** Unit tests for MichelineDecoder, verifying correct decoding of annotated JSON data into various formats."}
{"code": "      expect(result, expectedResult);\n      expect(result['spendings'].first['date'].toUtc(), DateTime.fromMillisecondsSinceEpoch(9876543 * 1000).toUtc());\n    });\n  });\n\n  group('when the data is anonymous', () {\n    final data = {'string': '001'};\n    final type = {'prim': 'string'};\n\n    test('it decodes the data correctly', () {\n      expect(subject(type, data), '001');\n    });\n  });\n}\n", "explanation": "Here is a concise summary:\n\nThis code block contains two sets of tests for a function called \"subject\". The tests verify that the function decodes data correctly under different conditions: \n\n1. When data has a specific structure.\n2. When data is anonymous (i.e., doesn't have a known structure).", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_decoder/micheline_decoder_test.dart", "chunk_number": 4, "total_chunks": 4}, "repository_explanation": "", "file_summary": "Here is a concise summary of the file 'test/micheline_decoder/micheline_decoder_test.dart':\n\n**Summary:** Unit tests for MichelineDecoder, verifying correct decoding of annotated JSON data into various formats."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nimport 'package:test/test.dart';\nimport 'package:tezart/src/micheline_decoder/micheline_decoder.dart';\n\nvoid main() {\n  final subject = (Map<String, dynamic> type, dynamic data) => MichelineDecoder(type: type, data: data).decode();\n\n  final type = {\n    'prim': 'pair',\n    'args': [\n      {\n        'prim': 'option',\n        'args': [\n          {'prim': 'signature'}\n        ],\n        'annots': ['%sig']\n      },\n      {\n        'prim': 'option',\n        'args': [\n          {'prim': 'timestamp'}\n        ],\n        'annots': ['%time']\n      }\n    ]\n  };\n\n  group('with None value', () {\n    final data = {\n      'prim': 'Pair',\n      'args': [\n        {'prim': 'None'},\n        {'prim': 'None'}\n      ]\n    };\n\n    test('it decodes data correctly', () {\n      expect(subject(type, data), {\n        'sig': null,\n        'time': null,\n      });\n    });\n  });\n\n  group('with some value', () {\n    final data = {\n      'prim': 'Pair',\n      'args': [\n        {\n          'prim': 'Some',", "explanation": "**Purpose:** Unit testing of MichelineDecoder functionality.\n\n**Functionality:**\n\n* Defines a test subject function `subject` that decodes Micheline data using MichelineDecoder.\n* Tests two scenarios:\n\t1. Decoding with None values in both \"sig\" and \"time\" fields.\n\t2. Decoding with Some values in both \"sig\" and \"time\" fields.\n* Verifies correct decoding of data in each scenario.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_decoder/option_decoder_test.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "", "file_summary": "Here's a concise summary:\n\n**test/micheline_decoder/option_decoder_test.dart**\n\nUnit test for MichelineDecoder functionality, verifying correct decoding of data in two scenarios: \n\n1. Decoding with None values.\n2. Decoding with Some values (encoded signature and timestamp 1620143003)."}
{"code": "          'args': [\n            {\n              'string':\n                  'edsigtp4wchrxPLWscwNQKyUssJixap4njeS3keCTwphwhx4MkQaFn8GfXkCJtk8vi5uV2ahrdS5YWc3qeC74awqWTGJfngKGrs'\n            }\n          ]\n        },\n        {\n          'prim': 'Some',\n          'args': [\n            {'int': 1620143003}\n          ]\n        }\n      ]\n    };\n\n    test('it decodes data correctly', () {\n      final expectedResult = {\n        'sig': 'edsigtp4wchrxPLWscwNQKyUssJixap4njeS3keCTwphwhx4MkQaFn8GfXkCJtk8vi5uV2ahrdS5YWc3qeC74awqWTGJfngKGrs',\n        'time': isA<DateTime>(),\n      };\n      final result = subject(type, data);\n\n      expect(result, expectedResult);\n      expect(result['time'].toUtc(), DateTime.fromMillisecondsSinceEpoch(1620143003 * 1000).toUtc());\n    });\n  });\n}\n", "explanation": "Here is a concise summary:\n\nThis block is a JSON data structure that represents an argument list for a function or method, containing two arguments: \n\n1. A string value with an encoded signature.\n2. An integer timestamp (1620143003) wrapped in a \"Some\" primitive.\n\nThe purpose of this block appears to be passing these values as input to a subject function, which is then tested for correctness.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_decoder/option_decoder_test.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "", "file_summary": "Here's a concise summary:\n\n**test/micheline_decoder/option_decoder_test.dart**\n\nUnit test for MichelineDecoder functionality, verifying correct decoding of data in two scenarios: \n\n1. Decoding with None values.\n2. Decoding with Some values (encoded signature and timestamp 1620143003)."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nimport 'package:test/test.dart';\nimport 'package:tezart/src/micheline_decoder/micheline_decoder.dart';\n\nvoid main() {\n  final subject = (Map<String, dynamic> type, dynamic data) => MichelineDecoder(type: type, data: data).decode();\n  final type = {'prim': 'timestamp'};\n\n  void _itDecodesDataCorrectly(data) {\n    test('it decodes data correctly', () {\n      final expectedResult = DateTime.fromMillisecondsSinceEpoch(1614620399 * 1000).toUtc();\n\n      expect(subject(type, data).toUtc(), expectedResult);\n    });\n  }\n\n  group('when the data is an int', () {\n    final data = {'int': 1614620399};\n\n    _itDecodesDataCorrectly(data);\n  });\n\n  group('when the data is a timestamp as a string', () {\n    final data = {'int': '1614620399'};\n\n    _itDecodesDataCorrectly(data);\n  });\n\n  group('when the data is a string date', () {\n    final data = {'string': '2021-03-01 17:39:59.000Z'};\n\n    _itDecodesDataCorrectly(data);\n  });\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Test MichelineDecoder functionality\n**Functionality:** Tests decoder's ability to correctly interpret different data types (int, timestamp as string, string date) and produce expected output using the `subject` function.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_decoder/timestamp_decoder_test.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "", "file_summary": "Here is a concise and holistic summary of the file 'test/micheline_decoder/timestamp_decoder_test.dart':\n\n**Purpose:** Validates MichelineDecoder functionality for various data types, including timestamp interpretation."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nimport 'package:test/test.dart';\nimport 'package:tezart/src/micheline_encoder/micheline_encoder.dart';\n\nvoid main() {\n  final subject = (Map<String, dynamic> type, dynamic params) => MichelineEncoder(type: type, params: params).encode();\n\n  final params = [\n    {'reference': 'txrsh', 'reference_2': '001'},\n    {'reference': '2', 'reference_2': '002'},\n  ];\n\n  final type = {\n    'prim': 'list',\n    'args': [\n      {\n        'prim': 'pair',\n        'args': [\n          {\n            'prim': 'string',\n            'annots': ['%reference']\n          },\n          {\n            'prim': 'string',\n            'annots': ['%reference_2']\n          }\n        ]\n      }\n    ]\n  };\n\n  test('it returns a valid value', () {\n    final expectedResult = [\n      {\n        'prim': 'Pair',\n        'args': [\n          {'string': 'txrsh'},\n          {'string': '001'}\n        ]\n      },\n      {\n        'prim': 'Pair',\n        'args': [\n          {'string': '2'},\n          {'string': '002'}", "explanation": "**Purpose:** Test the MichelineEncoder's encoding functionality.\n\n**Functionality:** Encodes a Micheline data structure with parameters and verifies its validity.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_encoder/list_encoder_test.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "", "file_summary": "Here's a concise summary:\n\n**File Summary:** 'test/micheline_encoder/list_encoder_test.dart'\nThis file contains test scenarios verifying the MichelineEncoder's ability to correctly encode Micheline data structures with parameters, ensuring its output meets expected validity standards."}
{"code": "        ]\n      }\n    ];\n\n    expect(subject(type, params), expectedResult);\n  });\n}\n", "explanation": "This is a test scenario written in a testing framework (likely Jest). It describes a set of expectations for the outcome of a function `subject` when provided certain inputs (`type`, `params`).", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_encoder/list_encoder_test.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "", "file_summary": "Here's a concise summary:\n\n**File Summary:** 'test/micheline_encoder/list_encoder_test.dart'\nThis file contains test scenarios verifying the MichelineEncoder's ability to correctly encode Micheline data structures with parameters, ensuring its output meets expected validity standards."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nimport 'package:test/test.dart';\nimport 'package:tezart/src/micheline_encoder/impl/micheline_encoder.dart';\n\nvoid main() {\n  final subject = (Map<String, dynamic> type, dynamic params) => MichelineEncoder(type: type, params: params).encode();\n\n  final type = {\n    'prim': 'pair',\n    'args': [\n      {\n        'prim': 'key',\n        'annots': ['%pub_key']\n      },\n      {\n        'prim': 'map',\n        'args': [\n          {'prim': 'string'},\n          {\n            'prim': 'pair',\n            'args': [\n              {\n                'prim': 'pair',\n                'args': [\n                  {\n                    'prim': 'pair',\n                    'args': [\n                      {\n                        'prim': 'timestamp',\n                        'annots': ['%date']\n                      },\n                      {\n                        'prim': 'nat',\n                        'annots': ['%price']\n                      }\n                    ]", "explanation": "**Summary**\n\nThis block is a test suite written in Dart, using the `test` package. It defines a function `subject` that encodes Micheline data using the `MichelineEncoder` class. The test suite likely verifies the correctness of this encoding process.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_encoder/map_encoder_test.dart", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "", "file_summary": "Here is a concise summary of the file 'test/micheline_encoder/map_encoder_test.dart':\n\nThis Dart test suite verifies the correctness of Micheline encoding using the `MichelineEncoder` class, specifically testing the encoding of spendings data structures into valid formats."}
{"code": "                  },\n                  {\n                    'prim': 'string',\n                    'annots': ['%reference']\n                  }\n                ]\n              },\n              {\n                'prim': 'nat',\n                'annots': ['%amount']\n              }\n            ]\n          }\n        ],\n        'annots': ['%spendings']\n      }\n    ]\n  };\n\n  final params = {\n    'pub_key': 'edpkvWLnfNsAKhWEDafxHaTmE8qtK19fSDJYAnLfg7J5Qf5jbkKgTW',\n    'spendings': {\n      'Spending--001': {'date': DateTime.utc(2020, 1, 1), 'price': 6000, 'reference': 'EG4WA', 'amount': 1000}\n    },\n  };\n\n  test('it returns a valid value', () {\n    final expectedResult = {\n      'prim': 'Pair',\n      'args': [\n        {'string': 'edpkvWLnfNsAKhWEDafxHaTmE8qtK19fSDJYAnLfg7J5Qf5jbkKgTW'},\n        [\n          {\n            'prim': 'Elt',\n            'args': [\n              {'string': 'Spending--001'},\n              {\n                'prim': 'Pair',\n                'args': [\n                  {\n                    'prim': 'Pair',", "explanation": "This appears to be JSON code. Here is a concise summary of its purpose and functionality:\n\n* Defines a data structure for spendings, including a public key.\n* Has an inner object with a single spending entry, containing date, price, reference, and amount fields.\n* The test block checks that this structure returns a valid value when processed.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_encoder/map_encoder_test.dart", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "", "file_summary": "Here is a concise summary of the file 'test/micheline_encoder/map_encoder_test.dart':\n\nThis Dart test suite verifies the correctness of Micheline encoding using the `MichelineEncoder` class, specifically testing the encoding of spendings data structures into valid formats."}
{"code": "                    'args': [\n                      {\n                        'prim': 'Pair',\n                        'args': [\n                          {'int': '1577836800'},\n                          {'int': '6000'}\n                        ]\n                      },\n                      {'string': 'EG4WA'}\n                    ]\n                  },\n                  {'int': '1000'}\n                ]\n              }\n            ]\n          }\n        ]\n      ]\n    };\n\n    expect(subject(type, params), expectedResult);\n  });\n}\n", "explanation": "This block defines a JSON structure with an array of objects containing various data types (integers, strings). \n\nIt appears to be setting up test data for a function call, where 'type' and 'params' are likely function arguments. The purpose is to test the function's behavior with specific inputs.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_encoder/map_encoder_test.dart", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "", "file_summary": "Here is a concise summary of the file 'test/micheline_encoder/map_encoder_test.dart':\n\nThis Dart test suite verifies the correctness of Micheline encoding using the `MichelineEncoder` class, specifically testing the encoding of spendings data structures into valid formats."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nimport 'package:test/test.dart';\nimport 'package:tezart/src/micheline_encoder/impl/micheline_encoder.dart';\n\nvoid main() {\n  final subject = (Map<String, dynamic> type, dynamic params) => MichelineEncoder(type: type, params: params).encode();\n\n  group('when type and params are valid', () {\n    group('when there is multiple parameters', () {\n      final type = {\n        'prim': 'pair',\n        'args': [\n          {\n            'prim': 'pair',\n            'args': [\n              {\n                'prim': 'pair',\n                'args': [\n                  {\n                    'prim': 'timestamp',\n                    'annots': ['%expires_at']\n                  },\n                  {\n                    'prim': 'string',\n                    'annots': ['%id']\n                  },\n                  {\n                    'prim': 'string',\n                    'annots': ['%third']\n                  }\n                ]\n              },\n              {", "explanation": "**Purpose:** Test suite for MichelineEncoder class.\n**Functionality:** Tests encoding of valid Micheline types with multiple parameters, using a test subject function to encode data.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_encoder/micheline_encoder_test.dart", "chunk_number": 1, "total_chunks": 4}, "repository_explanation": "", "file_summary": "Here is a concise summary of the file 'test/micheline_encoder/micheline_encoder_test.dart':\n\n**Test Suite:** MichelineEncoder class testing suite.\n**Purpose:** Verify correct encoding of valid Micheline types with parameters using a test subject function.\n**Functionality:** Tests various input scenarios, including single parameter, anonymous parameters, and multiple parameters as a list."}
{"code": "                'prim': 'bytes',\n                'annots': ['%payload']\n              }\n            ]\n          },\n          {\n            'prim': 'string',\n            'annots': ['%reference']\n          }\n        ]\n      };\n      final params = {\n        'payload': 'payload',\n        'reference': 'reference',\n        'id': 'id',\n        'expires_at': DateTime.utc(2020, 1, 1),\n        'third': 'third'\n      };\n\n      test('it returns a valid value', () {\n        expect(subject(type, params), {\n          'prim': 'Pair',\n          'args': [\n            {\n              'prim': 'Pair',\n              'args': [\n                {\n                  'prim': 'Pair',\n                  'args': [\n                    {'int': '1577836800'},\n                    {'string': 'id'},\n                    {'string': 'third'}\n                  ]\n                },\n                {'bytes': 'payload'}\n              ]\n            },\n            {'string': 'reference'}\n          ]\n        });\n      });\n    });\n", "explanation": "**Purpose:** This code snippet defines a data structure with pairs of key-value parameters.\n \n **Functionality:** It creates an object with two \"args\" properties, each containing another pair of key-value objects. The values are populated from an external \"params\" object.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_encoder/micheline_encoder_test.dart", "chunk_number": 2, "total_chunks": 4}, "repository_explanation": "", "file_summary": "Here is a concise summary of the file 'test/micheline_encoder/micheline_encoder_test.dart':\n\n**Test Suite:** MichelineEncoder class testing suite.\n**Purpose:** Verify correct encoding of valid Micheline types with parameters using a test subject function.\n**Functionality:** Tests various input scenarios, including single parameter, anonymous parameters, and multiple parameters as a list."}
{"code": "    group('when there is only one parameter', () {\n      final type = {\n        'prim': 'string',\n        'annots': ['%payload']\n      };\n      final params = {'payload': 'payload'};\n\n      test('it returns a valid value', () {\n        expect(subject(type, params), {'string': 'payload'});\n      });\n    });\n\n    group('when the parameter is anonymous', () {\n      final type = {\n        'prim': 'string',\n      };\n      final params = 'payload';\n\n      test('it returns a valid value', () {\n        expect(subject(type, params), {'string': 'payload'});\n      });\n    });\n\n    group('when the params is a List', () {\n      final params = ['1234', 'KT1UDJmqKvMYRcGzP2TSFhQqejS2CKaDsNEx', '4567'];\n      final type = {\n        'prim': 'pair',\n        'args': [\n          {\n            'prim': 'string',\n          },\n          {\n            'prim': 'pair',\n            'args': [\n              {\n                'prim': 'string',\n              },\n              {\n                'prim': 'string',\n              }\n            ]\n          }", "explanation": "**Summary:**\n\nThis block tests a function (`subject`) that parses parameters into a specific data structure. It has three test cases:\n\n1. When only one parameter is provided.\n2. When an anonymous (unnamed) parameter is used.\n3. When multiple parameters are passed as a list.\n\nEach test case verifies that the `subject` function correctly interprets the input and returns a valid value in a specific format.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_encoder/micheline_encoder_test.dart", "chunk_number": 3, "total_chunks": 4}, "repository_explanation": "", "file_summary": "Here is a concise summary of the file 'test/micheline_encoder/micheline_encoder_test.dart':\n\n**Test Suite:** MichelineEncoder class testing suite.\n**Purpose:** Verify correct encoding of valid Micheline types with parameters using a test subject function.\n**Functionality:** Tests various input scenarios, including single parameter, anonymous parameters, and multiple parameters as a list."}
{"code": "        ]\n      };\n\n      test('it returns a valid value', () {\n        expect(subject(type, params), {\n          'args': [\n            {'string': '1234'},\n            {\n              'args': [\n                {'string': 'KT1UDJmqKvMYRcGzP2TSFhQqejS2CKaDsNEx'},\n                {'string': '4567'}\n              ],\n              'prim': 'Pair'\n            }\n          ],\n          'prim': 'Pair',\n        });\n      });\n    });\n  });\n\n  group('With a comb pair', () {\n    final params = ['1234', 'KT1UDJmqKvMYRcGzP2TSFhQqejS2CKaDsNEx', '4567'];\n    final type = {\n      'prim': 'pair',\n      'args': [\n        {\n          'prim': 'string',\n        },\n        {\n          'prim': 'string',\n        },\n        {\n          'prim': 'string',\n        }\n      ]\n    };\n\n    test('it returns a valid value', () {\n      expect(subject(type, params), {\n        'prim': 'Pair',\n        'args': [\n          {'string': '1234'},\n          {'string': 'KT1UDJmqKvMYRcGzP2TSFhQqejS2CKaDsNEx'},\n          {'string': '4567'}\n        ]\n      });\n    });\n  });\n}\n", "explanation": "**Summary:**\n\nThis block of code defines test cases for a function called `subject` that takes in a type definition and parameters. It tests the function's ability to return valid output for different input types (string, pair) and parameter combinations.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_encoder/micheline_encoder_test.dart", "chunk_number": 4, "total_chunks": 4}, "repository_explanation": "", "file_summary": "Here is a concise summary of the file 'test/micheline_encoder/micheline_encoder_test.dart':\n\n**Test Suite:** MichelineEncoder class testing suite.\n**Purpose:** Verify correct encoding of valid Micheline types with parameters using a test subject function.\n**Functionality:** Tests various input scenarios, including single parameter, anonymous parameters, and multiple parameters as a list."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nimport 'package:test/test.dart';\nimport 'package:tezart/src/micheline_encoder/micheline_encoder.dart';\n\nvoid main() {\n  final subject = (Map<String, dynamic> type, dynamic params) => MichelineEncoder(type: type, params: params).encode();\n\n  final type = {\n    'prim': 'pair',\n    'args': [\n      {\n        'prim': 'option',\n        'args': [\n          {'prim': 'signature'}\n        ],\n        'annots': ['%signature']\n      },\n      {\n        'prim': 'option',\n        'args': [\n          {'prim': 'timestamp'},\n        ],\n        'annots': ['%valid_until']\n      }\n    ]\n  };\n\n  group('with null values', () {\n    final params = {\n      'valid_until': null,\n      'signature': null,\n    };\n\n    test('it returns a valid value', () {\n      expect(subject(type, params), {\n        'prim': 'Pair',\n        'args': [\n          {'prim': 'None'},\n          {'prim': 'None'}\n        ]\n      });\n    });\n  });\n\n  group('with some values', () {\n    final params = {", "explanation": "Here is a concise summary:\n\n**Purpose:** Test the MichelineEncoder's encode function with null values.\n\n**Functionality:** This block tests the encoding of a Micheline value with optionals set to null, verifying that it returns the expected output.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_encoder/option_encoder_test.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "", "file_summary": "Unfortunately, you provided two summaries, but none of them seem related to the code block \"test/micheline_encoder/option_encoder_test.dart\".\n\nHowever, based on the first summary you provided, here's a concise summary:\n\n**Purpose:** Test MichelineEncoder with null values.\n\n**Functionality:** Verifies expected output when encoding Micheline value with optionals set to null."}
{"code": "      'valid_until': DateTime.utc(2020, 1, 1),\n      'signature':\n          'edsigtp4wchrxPLWscwNQKyUssJixap4njeS3keCTwphwhx4MkQaFn8GfXkCJtk8vi5uV2ahrdS5YWc3qeC74awqWTGJfngKGrs',\n    };\n\n    test('it returns a valid value', () {\n      expect(subject(type, params), {\n        'prim': 'Pair',\n        'args': [\n          {\n            'prim': 'Some',\n            'args': [\n              {\n                'string':\n                    'edsigtp4wchrxPLWscwNQKyUssJixap4njeS3keCTwphwhx4MkQaFn8GfXkCJtk8vi5uV2ahrdS5YWc3qeC74awqWTGJfngKGrs'\n              }\n            ]\n          },\n          {\n            'prim': 'Some',\n            'args': [\n              {'int': '1577836800'},\n            ]\n          }\n        ]\n      });\n    });\n  });\n}\n", "explanation": "Here is a summary of the purpose and functionality of this block:\n\n**Block Summary:**\n\nThis block validates a signature and returns a pair value containing the signature and its valid until timestamp (January 1, 2020). \n\nIt appears to be written in Dart or a similar language, using a testing framework.", "metadata": {"repo": "magiclabs/tezart", "file": "test/micheline_encoder/option_encoder_test.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "", "file_summary": "Unfortunately, you provided two summaries, but none of them seem related to the code block \"test/micheline_encoder/option_encoder_test.dart\".\n\nHowever, based on the first summary you provided, here's a concise summary:\n\n**Purpose:** Test MichelineEncoder with null values.\n\n**Functionality:** Verifies expected output when encoding Micheline value with optionals set to null."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\n@Timeout(Duration(seconds: 60))\nimport 'package:test/test.dart';\nimport 'package:tezart/src/models/operation/impl/operation_hard_limits_setter_visitor.dart';\nimport 'package:tezart/tezart.dart';\n\nimport '../env/env.dart';\nimport '../test_utils/test_client.dart';\n\nvoid main() {\n  final tezart = testClient();\n  final originatorKeystore = Keystore.fromSecretKey(Env.originatorSk);\n  final rpcInterface = tezart.rpcInterface;\n  late Operation operation;\n\n  setUp(() {\n    operation = Operation(kind: Kinds.generic);\n  });\n\n  group('gas', () {\n    final subject = () async {\n      await OperationHardLimitsSetterVisitor().visit(operation);\n      return operation.gasLimit;\n    };\n\n    setUp(() {\n      OperationsList(\n        source: originatorKeystore,\n        rpcInterface: rpcInterface,\n      ).appendOperation(operation);\n    });\n\n    test('it returns the hard_gas_limit_per_operation node constant', () async {\n      expect(await subject(), 1040000);\n    });\n  });\n", "explanation": "Here is a concise summary:\n\nThis block is a test suite for the TezArt library, ensuring that the gas limit of an operation is set correctly. It tests the `OperationHardLimitsSetterVisitor` class by simulating a node's behavior and verifying its returned gas limit value matches the expected hard_gas_limit_per_operation constant.", "metadata": {"repo": "magiclabs/tezart", "file": "test/models/operation_hard_limits_setter_visitor.dart", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "", "file_summary": "Here is a concise summary:\n\nThis Dart file defines a test suite for verifying the gas limit of operations in the TezArt library, ensuring that it adheres to the specified hard limits per operation."}
{"code": "  group('storage', () {\n    final subject = () async {\n      await OperationHardLimitsSetterVisitor().visit(operation);\n\n      return operation.storageLimit;\n    };\n\n    group('when the source balance storage limitation is greater than the hard storage limitation per operation', () {\n      setUp(() {\n        OperationsList(\n          source: originatorKeystore,\n          rpcInterface: rpcInterface,\n        ).appendOperation(operation);\n      });\n\n      test('it returns the hard storage limitation per operation', () async {\n        expect(await subject(), 60000);\n      });\n    });\n\n    group('when the source balance storage limitation is lesser than the hard storage limitation per operation', () {\n      setUp(() async {\n        final destination = Keystore.random();\n        final operationsList = await tezart.transferOperation(\n          source: originatorKeystore,\n          destination: destination.address,\n          amount: 10000,\n        );\n        await operationsList.executeAndMonitor();", "explanation": "Here is a concise summary:\n\nThis block defines a test suite for verifying storage limitation behavior in a Tezos operation system.\n\nKey functionality:\n\n* Tests the interaction between source balance storage limitations and hard storage limitations per operation.\n* Evaluates expected outcomes based on comparison of these two values.\n* Uses setup and test procedures to simulate different scenarios.", "metadata": {"repo": "magiclabs/tezart", "file": "test/models/operation_hard_limits_setter_visitor.dart", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "", "file_summary": "Here is a concise summary:\n\nThis Dart file defines a test suite for verifying the gas limit of operations in the TezArt library, ensuring that it adheres to the specified hard limits per operation."}
{"code": "        final revealOperation = tezart.revealKeyOperation(destination);\n        await revealOperation.executeAndMonitor();\n\n        OperationsList(\n          source: destination,\n          rpcInterface: rpcInterface,\n        ).appendOperation(operation);\n      });\n\n      test('it returns the balance storage limitation', () async {\n        expect(await subject(), lessThan(9699));\n        expect(await subject(), greaterThan(9690));\n      });\n    });\n  });\n}\n", "explanation": "**Summary:**\n\nThis code block appears to be a test suite that executes an operation on a Tezos blockchain, monitors its execution, and then tests the return value of another function to ensure it falls within a specific range (9690-9699).", "metadata": {"repo": "magiclabs/tezart", "file": "test/models/operation_hard_limits_setter_visitor.dart", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "", "file_summary": "Here is a concise summary:\n\nThis Dart file defines a test suite for verifying the gas limit of operations in the TezArt library, ensuring that it adheres to the specified hard limits per operation."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nimport 'package:test/test.dart';\nimport 'package:tezart/tezart.dart';\n\nvoid main() {\n  final rpcInterface = RpcInterface('http://localhost:20000');\n  const kind = Kinds.generic;\n  final source = Keystore.fromSeed('edsk4CCa2afKwHWGxB5oZd4jvhq6tgd5EzFaryyR4vLdC3nvpjKUG6');\n  final publicKey = source.publicKey;\n  const destination = 'tz1Q9L8us1DWMNDCyPcaScghH9fcgUSD1zFy';\n  const amount = 1;\n  const balance = 1;\n  const counter = 543;\n  final parameters = {'first': 'parameter', 'second': 'parameter'};\n  final fee = 1;\n  final gasLimit = 10;\n  final storageLimit = 100;\n  final operationsList = OperationsList(source: source, rpcInterface: rpcInterface);\n\n  group('#toJson()', () {\n    test('returns valid Json when including public_key when the kind is revealall fields are present', () {\n      final operation = Operation(\n        kind: Kinds.reveal,\n        destination: destination,\n        balance: balance,\n        amount: amount,", "explanation": "Here's a concise summary:\n\n**Purpose:** Unit testing of Tezart library functionality.\n\n**Functionality:** Tests serialization and deserialization of various data structures, including operations and their parameters, using JSON formatting.", "metadata": {"repo": "magiclabs/tezart", "file": "test/models/operation_test.dart", "chunk_number": 1, "total_chunks": 4}, "repository_explanation": "", "file_summary": "Here's a concise summary of the file 'test/models/operation_test.dart':\n\nThis test suite verifies the Tezart library's functionality through unit tests. Specifically, it ensures correct JSON serialization of operations and their parameters, handles missing values, and simulates result handling in specific scenarios, including error propagation."}
{"code": "        params: parameters,\n      )\n        ..operationsList = operationsList\n        ..gasLimit = gasLimit\n        ..storageLimit = storageLimit\n        ..fee = fee\n        ..counter = counter;\n\n      final expectedResult = {\n        'kind': 'reveal',\n        'source': source.address,\n        'destination': destination,\n        'public_key': publicKey,\n        'balance': balance.toString(),\n        'amount': amount.toString(),\n        'counter': counter.toString(),\n        'fee': fee.toString(),\n        'gas_limit': gasLimit.toString(),\n        'storage_limit': storageLimit.toString(),\n        'parameters': {'value': parameters},\n      };\n\n      expect(operation.toJson(), equals(expectedResult));\n    });\n\n    test('returns valid Json when publicKey is missing', () {\n      final operation = Operation(\n        kind: kind,\n        destination: destination,\n        amount: amount,\n        params: parameters,\n      )\n        ..operationsList = operationsList\n        ..counter = counter;\n", "explanation": "Here is a concise summary:\n\nThis block appears to be a test suite in Dart, specifically testing the `Operation` class's JSON representation. It checks that the class correctly serializes its properties into a valid JSON object, including handling missing values (public key).", "metadata": {"repo": "magiclabs/tezart", "file": "test/models/operation_test.dart", "chunk_number": 2, "total_chunks": 4}, "repository_explanation": "", "file_summary": "Here's a concise summary of the file 'test/models/operation_test.dart':\n\nThis test suite verifies the Tezart library's functionality through unit tests. Specifically, it ensures correct JSON serialization of operations and their parameters, handles missing values, and simulates result handling in specific scenarios, including error propagation."}
{"code": "      expect(operation.toJson().keys, isNot(contains('public_key')));\n    });\n\n    test('returns valid Json when amount is missing', () {\n      final operation = Operation(\n        kind: kind,\n        destination: destination,\n        params: parameters,\n      )\n        ..operationsList = operationsList\n        ..counter = counter;\n\n      expect(operation.toJson().keys, isNot(contains('amount')));\n    });\n\n    test('returns valid Json when parameters is missing', () {\n      final operation = Operation(\n        kind: kind,\n        destination: destination,\n        amount: amount,\n      )\n        ..operationsList = operationsList\n        ..counter = counter;\n\n      expect(operation.toJson().keys, isNot(contains('parameters')));\n    });\n  });\n\n  group('#simulationResult=', () {\n    final subject = (Map<String, dynamic> simulationResult) {\n      final operation = Operation(\n        kind: kind,\n        destination: destination,\n        amount: amount,\n        params: parameters,\n      )", "explanation": "Here is a summary of the block:\n\n**Purpose:** Test the `Operation` class's JSON serialization functionality.\n\n**Functionality:** Three test cases are defined to ensure that an `Operation` object correctly omits certain properties (public key, amount, parameters) when converting it to JSON.", "metadata": {"repo": "magiclabs/tezart", "file": "test/models/operation_test.dart", "chunk_number": 3, "total_chunks": 4}, "repository_explanation": "", "file_summary": "Here's a concise summary of the file 'test/models/operation_test.dart':\n\nThis test suite verifies the Tezart library's functionality through unit tests. Specifically, it ensures correct JSON serialization of operations and their parameters, handles missing values, and simulates result handling in specific scenarios, including error propagation."}
{"code": "        ..operationsList = operationsList\n        ..counter = counter;\n      operation.simulationResult = simulationResult;\n    };\n\n    group('when the simulation fails', () {\n      final simulationResult = {\n        'kind': 'origination',\n        'metadata': {\n          'operation_result': {\n            'status': 'failed',\n            'errors': [\n              {\n                'id': 'proto.error1',\n              },\n              {\n                'id': 'proto.error2',\n              },\n            ],\n          },\n        },\n      };\n\n      test('throws an error', () {\n        expect(() => subject(simulationResult),\n            throwsA(predicate((e) => e is TezartNodeError && e.type == TezartNodeErrorTypes.simulationFailed)));\n      });\n    });\n  });\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Test simulation result handling in a specific scenario.\n\n**Functionality:** Verifies that when simulation fails, an error with type `simulationFailed` is thrown.", "metadata": {"repo": "magiclabs/tezart", "file": "test/models/operation_test.dart", "chunk_number": 4, "total_chunks": 4}, "repository_explanation": "", "file_summary": "Here's a concise summary of the file 'test/models/operation_test.dart':\n\nThis test suite verifies the Tezart library's functionality through unit tests. Specifically, it ensures correct JSON serialization of operations and their parameters, handles missing values, and simulates result handling in specific scenarios, including error propagation."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\n@Timeout(Duration(seconds: 60))\nimport 'package:test/test.dart';\nimport 'package:tezart/src/models/operation/impl/operation_fees_setter_visitor.dart';\nimport 'package:tezart/tezart.dart';\n\nimport '../env/env.dart';\nimport '../test_utils/test_client.dart';\n\nvoid main() {\n  final tezart = testClient();\n  final originatorKeystore = Keystore.fromSecretKey(Env.originatorSk);\n  late Operation operation;\n\n  group('when the operation customFee is set', () {\n    const customFee = 1234;\n    final subject = () => OperationFeesSetterVisitor().visit(operation);\n\n    setUp(() {\n      operation = Operation(kind: Kinds.generic, customFee: customFee);\n    });\n\n    test('it sets operation.fee using customFee', () async {\n      await subject();\n      expect(operation.fee, customFee);\n    });\n  });\n\n  group('when the operation customFee is not set', () {\n    final subject = () => OperationFeesSetterVisitor().visit(operation);\n\n    setUp(() async {", "explanation": "**Summary:**\n\nThis code block defines a test suite for verifying the behavior of an `OperationFeesSetterVisitor` in a Tezart-based application.\n\n**Purpose:** Test the correct setting of operation fees using a custom fee value.\n\n**Functionality:**\n\n1. The test creates an instance of `testClient()` and initializes an `Operation` object with a custom fee.\n2. It defines two test cases:\n\t* When the operation's custom fee is set, it tests if the visitor correctly sets the operation's fee to the custom value.\n\t* When the operation's custom fee is not set, it tests that no exception is thrown when visiting the operation.\n\n**Note:** The `@Timeout` annotation ensures the test completes within 60 seconds.", "metadata": {"repo": "magiclabs/tezart", "file": "test/models/operations_fees_setter_visitor_test.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "", "file_summary": "Here is a concise and to the point summary of the file 'test/models/operations_fees_setter_visitor_test.dart':\n\n**Summary:**\n\nThis test suite verifies that an `OperationFeesSetterVisitor` correctly sets operation fees in a Tezart-based application.\n\n**Purpose:** Ensure correct fee computation for operations."}
{"code": "      final destination = Keystore.random();\n      final operationsList = await tezart.transferOperation(\n        source: originatorKeystore,\n        destination: destination.address,\n        amount: 1000,\n      );\n      operation = operationsList.operations.last;\n      await operationsList.computeCounters();\n      await operationsList.computeLimits();\n    });\n\n    test('it computes the fees using the operation simulation', () async {\n      await subject();\n      expect(operation.fee, lessThan(64657));\n    });\n  });\n}\n", "explanation": "Here is a summary of the block in concise terms:\n\n**Purpose:** Verify that an operation's fee is computed correctly.\n\n**Functionality:** Simulates a Tezos transfer operation, computes fees, and checks if they are within an expected range.", "metadata": {"repo": "magiclabs/tezart", "file": "test/models/operations_fees_setter_visitor_test.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "", "file_summary": "Here is a concise and to the point summary of the file 'test/models/operations_fees_setter_visitor_test.dart':\n\n**Summary:**\n\nThis test suite verifies that an `OperationFeesSetterVisitor` correctly sets operation fees in a Tezart-based application.\n\n**Purpose:** Ensure correct fee computation for operations."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\n@Timeout(Duration(seconds: 60))\n@Tags([\"unstable\"])\n\nimport 'package:test/test.dart';\nimport 'package:tezart/tezart.dart';\n\nimport '../env/env.dart';\nimport '../test_utils/test_contract_script.dart';\nimport '../test_utils/test_client.dart';\n\nvoid main() {\n  final tezart = testClient();\n  final originatorKeystore = Keystore.fromSecretKey(Env.originatorSk);\n\n  group('#executeAndMonitor', () {\n    group('TransactionOperation', () {\n      final subject = (Keystore source, String destination, int amount) async {\n        final operationsList = await tezart.transferOperation(source: source, destination: destination, amount: amount);\n        await operationsList.executeAndMonitor();\n        return operationsList;\n      };\n\n      final amount = 10;\n      late String destination;\n\n      setUp(() {\n        destination = Keystore.random().address;\n      });\n\n      group('when the source key is revealed', () {\n        final source = originatorKeystore;\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Run automated tests for a Tezos contract using the Tezart package.\n\n**Functionality:**\n\n* Set a 1-minute timeout for each test.\n* Import necessary libraries and functions.\n* Create a test client and Keystore instances.\n* Define a test group and case for executing a transaction operation.\n* Test the operation when the source key is revealed.", "metadata": {"repo": "magiclabs/tezart", "file": "test/models/operations_list_test.dart", "chunk_number": 1, "total_chunks": 9}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/models/operations_list_test.dart':\n\nThis block of code tests a Tezos contract's operations using the Tezart package, verifying that various functions behave correctly when executed on a randomly generated Keystore object. It includes test cases for revealing keys, setting operation limits (gas, storage, fee), and testing error scenarios when inputs are invalid or when the key is already revealed."}
{"code": "        test('it transfers the amount from source to destination', () async {\n          var beforeTransferBalance = await tezart.getBalance(address: destination);\n          final operationsList = await subject(source, destination, amount);\n          final afterTransferBalance = await tezart.getBalance(address: destination);\n\n          expect(afterTransferBalance - beforeTransferBalance, equals(amount));\n          expect(RegExp(r'^o\\w+$').hasMatch(operationsList.result.id!), true);\n        });\n\n        test('it doesnt add a reveal operation', () async {\n          final result = await subject(source, destination, amount);\n          expect(result.operations.whereType<RevealOperation>(), isEmpty);\n        });\n\n        test('it sets simulationResult correctly', () async {\n          final result = await subject(source, destination, amount);\n          expect(result.operations.first.simulationResult, isNotNull);\n        });\n\n        test('it sets limits correctly', () async {", "explanation": "Here is a concise summary:\n\nThis block appears to be a set of automated tests (in Dart or Kotlin) for a Tezos transaction function (`subject`). The tests verify that the function:\n\n1. Transfers a specified amount from source to destination\n2. Does not add an unnecessary Reveal operation\n3. Sets simulation results and limits correctly", "metadata": {"repo": "magiclabs/tezart", "file": "test/models/operations_list_test.dart", "chunk_number": 2, "total_chunks": 9}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/models/operations_list_test.dart':\n\nThis block of code tests a Tezos contract's operations using the Tezart package, verifying that various functions behave correctly when executed on a randomly generated Keystore object. It includes test cases for revealing keys, setting operation limits (gas, storage, fee), and testing error scenarios when inputs are invalid or when the key is already revealed."}
{"code": "          final result = await subject(source, destination, amount);\n          final operation = result.operations.first;\n\n          expect(operation.gasLimit, 1520);\n          expect(operation.storageLimit, 257);\n          // can't test equality because there might be a difference of ~= 5 \u00b5tz because of the forged operation size difference\n          expect(operation.fee, lessThan(64656));\n        });\n      });\n\n      group('when the source key is not revealed', () {\n        late Keystore source;\n\n        setUp(() async {\n          source = Keystore.random();\n          final operationsList =\n              await tezart.transferOperation(source: originatorKeystore, destination: source.address, amount: 1000000);\n          await operationsList.executeAndMonitor();\n        });\n\n        test('it transfers the amount from source to destination', () async {\n          var beforeTransferBalance = await tezart.getBalance(address: destination);", "explanation": "Here is a summary of the code in 2-3 sentences:\n\n**Purpose:** This block tests a transfer operation between two Tezos accounts.\n\n**Functionality:** It checks that the correct gas limit, storage limit, and fee are set for the operation, as well as verifying that the balance is updated correctly when transferring funds from one account to another.", "metadata": {"repo": "magiclabs/tezart", "file": "test/models/operations_list_test.dart", "chunk_number": 3, "total_chunks": 9}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/models/operations_list_test.dart':\n\nThis block of code tests a Tezos contract's operations using the Tezart package, verifying that various functions behave correctly when executed on a randomly generated Keystore object. It includes test cases for revealing keys, setting operation limits (gas, storage, fee), and testing error scenarios when inputs are invalid or when the key is already revealed."}
{"code": "          final operationsList = await subject(source, destination, amount);\n          final afterTransferBalance = await tezart.getBalance(address: destination);\n          expect(afterTransferBalance - beforeTransferBalance, equals(amount));\n          expect(RegExp(r'^o\\w+$').hasMatch(operationsList.result.id!), true);\n        });\n\n        test('it reveals the key', () async {\n          await subject(source, destination, amount);\n          expect(await tezart.isKeyRevealed(source.address), true);\n        });\n\n        test('it sets limits correctly', () async {\n          final result = await subject(source, destination, amount);\n          final revealOperation = result.operations.first;\n          final transactionOperation = result.operations[1];\n\n          expect(revealOperation.gasLimit, 1100);\n          expect(revealOperation.storageLimit, 0);\n          // can't test equality because there might be a difference of ~= 5 \u00b5tz because of the forged operation size difference", "explanation": "Here is a concise summary:\n\nThis block contains three test cases for a Tezos transaction function (`subject`):\n\n1. Verifies that a transfer operation updates balances correctly.\n2. Checks if the sender's key is revealed after the transfer.\n3. Tests if transaction limits (gas and storage) are set correctly.", "metadata": {"repo": "magiclabs/tezart", "file": "test/models/operations_list_test.dart", "chunk_number": 4, "total_chunks": 9}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/models/operations_list_test.dart':\n\nThis block of code tests a Tezos contract's operations using the Tezart package, verifying that various functions behave correctly when executed on a randomly generated Keystore object. It includes test cases for revealing keys, setting operation limits (gas, storage, fee), and testing error scenarios when inputs are invalid or when the key is already revealed."}
{"code": "          expect(revealOperation.fee, lessThan(320));\n\n          expect(transactionOperation.gasLimit, 1520);\n          expect(transactionOperation.storageLimit, 257);\n          // can't test equality because there might be a difference of ~= 5 \u00b5tz because of the forged operation size difference\n          expect(transactionOperation.fee, lessThan(64612));\n        });\n      });\n    });\n\n    group('RevealOperation', () {\n      final subject = (Keystore keystore) async {\n        final operationsList = tezart.revealKeyOperation(keystore);\n        await operationsList.executeAndMonitor();\n        return operationsList;\n      };\n\n      final transferToDest = (Keystore destinationKeystore) async {\n        final operationsList = await tezart.transferOperation(\n          source: originatorKeystore,\n          destination: destinationKeystore.address,\n          amount: 10000,\n        );\n        await operationsList.executeAndMonitor();\n      };\n\n      group('when the key is not revealed', () {", "explanation": "Here is a concise summary:\n\nThis block of code contains test cases for Tezos operations using the TezArt library. It tests the correctness of reveal, transaction, and transfer operations by asserting their expected values and behaviors. The purpose is to ensure the functionality of these operations in a test environment.", "metadata": {"repo": "magiclabs/tezart", "file": "test/models/operations_list_test.dart", "chunk_number": 5, "total_chunks": 9}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/models/operations_list_test.dart':\n\nThis block of code tests a Tezos contract's operations using the Tezart package, verifying that various functions behave correctly when executed on a randomly generated Keystore object. It includes test cases for revealing keys, setting operation limits (gas, storage, fee), and testing error scenarios when inputs are invalid or when the key is already revealed."}
{"code": "        late Keystore keystore;\n\n        setUp(() {\n          keystore = Keystore.random();\n        });\n\n        setUp(() async {\n          await transferToDest(keystore);\n        });\n\n        test('it reveals the key', () async {\n          await subject(keystore);\n          final isKeyRevealed = await tezart.isKeyRevealed(keystore.address);\n\n          expect(isKeyRevealed, isTrue);\n        });\n\n        test('it sets limits correctly', () async {\n          final result = await subject(keystore);\n          final revealOperation = result.operations.first;\n\n          expect(revealOperation.gasLimit, 1100);\n          expect(revealOperation.storageLimit, 0);\n          // can't test equality because there might be a difference of ~= 5 \u00b5tz because of the forged operation size difference\n          expect(revealOperation.fee, lessThan(372));\n        });\n      });\n\n      group('when the key is already revealed', () {\n        final keystore = originatorKeystore;\n\n        test('throws an error', () async {\n          expect(", "explanation": "**Block Summary:**\n\nThis block tests a `subject` function, which operates on a randomly generated Keystore object. It verifies that the function:\n\n1. Reveals the key\n2. Sets correct operation limits (gas, storage, fee)\n\nThe block also includes a group of tests to check behavior when the key is already revealed, in which case it expects an error to be thrown.", "metadata": {"repo": "magiclabs/tezart", "file": "test/models/operations_list_test.dart", "chunk_number": 6, "total_chunks": 9}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/models/operations_list_test.dart':\n\nThis block of code tests a Tezos contract's operations using the Tezart package, verifying that various functions behave correctly when executed on a randomly generated Keystore object. It includes test cases for revealing keys, setting operation limits (gas, storage, fee), and testing error scenarios when inputs are invalid or when the key is already revealed."}
{"code": "              subject(keystore),\n              throwsA(predicate(\n                  (e) => e is TezartNodeError && e.message == \"You're trying to reveal an already revealed key.\")));\n        });\n      });\n    });\n\n    group('OriginationOperation', () {\n      final balanceAmount = 1;\n      final subject = ({\n        required List<Map<String, dynamic>> code,\n        required dynamic storage,\n      }) async {\n        final operationsList = await tezart.originateContractOperation(\n          source: originatorKeystore,\n          balance: balanceAmount,\n          code: code,\n          storage: storage,\n        );\n        await operationsList.executeAndMonitor();\n\n        return operationsList;\n      };\n\n      group('when all inputs are valid', () {\n        test('doesnt throw any error', () async {\n          // expect(()=> subject(), returnsNormally) fails silently\n          await subject(\n            code: testContractScript,\n            storage: {'int': '12'},\n          );\n        });\n", "explanation": "This block defines a set of tests for an Origination Operation in Tezos, which is used to create a new contract.\n\n* The `subject` function simulates the origination operation with given code and storage.\n* Tests are grouped by scenario:\n\t+ \"when all inputs are valid\": Test that the operation completes without errors.", "metadata": {"repo": "magiclabs/tezart", "file": "test/models/operations_list_test.dart", "chunk_number": 7, "total_chunks": 9}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/models/operations_list_test.dart':\n\nThis block of code tests a Tezos contract's operations using the Tezart package, verifying that various functions behave correctly when executed on a randomly generated Keystore object. It includes test cases for revealing keys, setting operation limits (gas, storage, fee), and testing error scenarios when inputs are invalid or when the key is already revealed."}
{"code": "        test('it sets contractAddress correctly', () async {\n          final operationsList = await subject(\n            code: testContractScript,\n            storage: {'int': '12'},\n          );\n\n          final contractAddress = (operationsList.operations.first as OriginationOperation).contractAddress;\n\n          expect(contractAddress.startsWith('KT'), true);\n        });\n\n        test('it sets limits correctly', () async {\n          final result = await subject(\n            code: testContractScript,\n            storage: {'int': '12'},\n          );\n          final originationOperation = result.operations.first;\n\n          expect(originationOperation.gasLimit, 1505);\n          expect(originationOperation.storageLimit, 295);\n          // can't test equality because there might be a difference of ~= 5 \u00b5tz because of the forged operation size difference\n          expect(originationOperation.fee, lessThan(74171));\n        });\n      });\n\n      group('when code and storage are invalid', () {", "explanation": "Here is a concise summary:\n\nThis block contains two unit tests for a function called \"subject\". The tests verify that the function correctly sets contract address and limits (gas, storage, and fee) when given valid inputs (code and storage). Additionally, there's an implicit test group for invalid input scenarios.", "metadata": {"repo": "magiclabs/tezart", "file": "test/models/operations_list_test.dart", "chunk_number": 8, "total_chunks": 9}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/models/operations_list_test.dart':\n\nThis block of code tests a Tezos contract's operations using the Tezart package, verifying that various functions behave correctly when executed on a randomly generated Keystore object. It includes test cases for revealing keys, setting operation limits (gas, storage, fee), and testing error scenarios when inputs are invalid or when the key is already revealed."}
{"code": "        test('throws an error', () async {\n          expect(\n              subject(code: [{}], storage: {}),\n              throwsA(predicate((e) =>\n                  e is TezartNodeError &&\n                  RegExp(r'ill_typed_contract.*invalid_expression_kind.*$').hasMatch(e.message))));\n        });\n      });\n    });\n  });\n}\n", "explanation": "This block of code:\n\n**Purpose:** Tests if a function throws an error.\n\n**Functionality:** Uses Jest's `expect` function to assert that calling `subject` with specific inputs (`[{}]`, `{}`) will throw an instance of `TezartNodeError` with a message matching a regular expression pattern.", "metadata": {"repo": "magiclabs/tezart", "file": "test/models/operations_list_test.dart", "chunk_number": 9, "total_chunks": 9}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/models/operations_list_test.dart':\n\nThis block of code tests a Tezos contract's operations using the Tezart package, verifying that various functions behave correctly when executed on a randomly generated Keystore object. It includes test cases for revealing keys, setting operation limits (gas, storage, fee), and testing error scenarios when inputs are invalid or when the key is already revealed."}
{"code": "import 'dart:typed_data';\n\nfinal signedBytesWithGenericWatermark = Uint8List.fromList([\n  229,\n  200,\n  154,\n  36,\n  32,\n  132,\n  19,\n  20,\n  182,\n  171,\n  138,\n  236,\n  220,\n  221,\n  197,\n  249,\n  28,\n  130,\n  199,\n  91,\n  74,\n  119,\n  121,\n  58,\n  106,\n  46,\n  67,\n  233,\n  219,\n  89,\n  170,\n  254,\n  172,\n  19,\n  33,\n  175,\n  87,\n  254,\n  50,\n  110,\n  74,\n  23,\n  192,\n  131,\n  254,\n  35,\n  249,\n  178,\n  212,\n  43,\n  204,\n  6,\n  171,\n  159,\n  202,\n  40,\n  26,\n  1,\n  148,\n  228,\n  95,\n  238,\n  116,\n  1,\n]);\n\nfinal signedBytesWithNullWatermark = Uint8List.fromList([\n  134,\n  66,\n  236,\n  139,\n  243,\n  129,\n  54,\n  21,\n  127,\n  15,\n  182,\n  124,\n  172,\n  50,\n  74,\n  29,\n  45,\n  186,\n  68,\n  32,\n  239,\n  78,\n  235,\n  120,\n  229,\n  125,\n  143,\n  113,\n  250,\n  81,\n  51,\n  113,\n  15,\n  147,\n  236,\n  109,\n  70,\n  210,\n  70,\n  113,\n  132,\n  194,\n  20,\n  146,\n  9,\n  60,\n  32,\n  73,\n  135,\n  63,\n  9,\n  174,\n  164,\n  45,\n  132,\n  98,\n  183,\n  118,\n  219,\n  210,\n  203,\n  241,\n  241,\n  2,\n]);\n", "explanation": "**Summary**\n\nThis block defines two byte arrays (`signedBytesWithGenericWatermark` and `signedBytesWithNullWatermark`) in Dart, using the `Uint8List.fromList()` function. The arrays contain a list of hexadecimal values that represent signed bytes with watermarks.", "metadata": {"repo": "magiclabs/tezart", "file": "test/signature/expected_results/signature.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "", "file_summary": "Here is a concise summary:\n\n**Summary**\n\nThe file 'signature.dart' defines two byte arrays (`signedBytesWithGenericWatermark` and `signedBytesWithNullWatermark`) containing signed bytes with watermarks in Dart."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nimport 'dart:typed_data';\n\nimport 'package:test/test.dart';\nimport 'package:tezart/tezart.dart';\n\nimport 'expected_results/signature.dart' as expected_results;\n\nvoid main() {\n  final keystore = Keystore.fromSeed('edsk3RR5U7JsUJ8ctjsuymUPayxMm4LHXaB7VJSfeyMb8fAvbJUnsa');\n\n  group('.fromBytes', () {\n    final bytes = Uint8List.fromList([43, 59, 54, 09]);\n    final subject = Signature.fromBytes(bytes: bytes, keystore: keystore);\n\n    test('it sets bytes correctly', () {\n      expect(subject.bytes, equals(bytes));\n    });\n\n    test('it sets keystore correctly', () {\n      expect(subject.keystore, equals(keystore));\n    });\n  });\n\n  group('.fromHex', () {\n    final subject = (String data) => Signature.fromHex(data: data, keystore: keystore);\n    group('when the data is valid', () {\n      final data = '12345adf';\n\n      test('it sets bytes correctly', () {\n        final bytes = [18, 52, 90, 223];\n\n        expect(subject(data).bytes, equals(bytes));\n      });\n", "explanation": "Here is a concise summary:\n\nThis block of code tests the functionality of the `Signature` class in the `tezart` package. It creates a test case for two methods: `.fromBytes` and `.fromHex`, verifying that they correctly set the `bytes` and `keystore` properties of a `Signature` object.", "metadata": {"repo": "magiclabs/tezart", "file": "test/signature/signature_test.dart", "chunk_number": 1, "total_chunks": 5}, "repository_explanation": "", "file_summary": "Here is a concise holistic summary of the file 'test/signature/signature_test.dart':\n\n**Summary:** This test suite verifies the functionality of the `Signature` class, ensuring correct behavior for various methods such as `.fromBytes`, `.edsig`, `.hexIncludingPayload`, and equality checks between signatures."}
{"code": "      test('it sets keystore correctly', () {\n        expect(subject(data).keystore, equals(keystore));\n      });\n    });\n\n    group(\"when the data's length is odd\", () {\n      final data = '12345adff';\n\n      test('it throws an error', () {\n        expect(() => subject(data),\n            throwsA(predicate((e) => e is CryptoError && e.type == CryptoErrorTypes.invalidHexDataLength)));\n      });\n    });\n\n    group('when the data contains non hexadecimal characters', () {\n      final data = '123t';\n\n      test('it throws an error', () {\n        expect(\n          () => subject(data),\n          throwsA(predicate((e) => e is CryptoError && e.type == CryptoErrorTypes.invalidHex)),\n        );\n      });\n    });\n  });\n\n  group('.signedBytes', () {\n    final subject = (Watermarks? watermark) => Signature.fromHex(\n          data: '123abd43',\n          keystore: keystore,\n          watermark: watermark,\n        ).signedBytes;\n\n    group('when watermak is not null', () {\n      final result = subject(Watermarks.generic);\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Test suite for cryptographic functions.\n\n**Functionality:** \n\n* Verifies that `keystore` is set correctly.\n* Tests error handling for:\n\t+ Odd-length hexadecimal data.\n\t+ Non-hexadecimal characters in data.\n* Demonstrates the usage of `.signedBytes` method, specifically when using a non-null watermark.", "metadata": {"repo": "magiclabs/tezart", "file": "test/signature/signature_test.dart", "chunk_number": 2, "total_chunks": 5}, "repository_explanation": "", "file_summary": "Here is a concise holistic summary of the file 'test/signature/signature_test.dart':\n\n**Summary:** This test suite verifies the functionality of the `Signature` class, ensuring correct behavior for various methods such as `.fromBytes`, `.edsig`, `.hexIncludingPayload`, and equality checks between signatures."}
{"code": "      test('it returns a valid signed bytes list', () {\n        expect(result, equals(expected_results.signedBytesWithGenericWatermark));\n      });\n    });\n\n    group('when watermak is null', () {\n      final result = subject(null);\n\n      test('it returns a valid signed bytes list', () {\n        expect(result, equals(expected_results.signedBytesWithNullWatermark));\n      });\n    });\n  });\n\n  group('.edsig', () {\n    final subject = () => Signature.fromHex(\n          data: '123abd43',\n          keystore: keystore,\n          watermark: Watermarks.generic,\n        ).edsig;\n\n    test('it returns a valid edsig signature', () {\n      final expectedResult =\n          'edsigu3sNYboRMWw81pn8YPe4GSVsqv25Y5jWrzvFJN3wNkaUhbsRFzpFfNYX2LiXpyz7Si1TMcqNVTTwy3Q4ACYAopEjaSNb3S';\n      expect(subject(), equals(expectedResult));\n    });\n  });\n\n  group('.hexIncludingPayload', () {\n    final subject = () => Signature.fromHex(\n          data: '123abd43',\n          keystore: keystore,\n          watermark: Watermarks.generic,", "explanation": "Here is a concise summary of the block:\n\n**Purpose:** Test the functionality of `Signature` class methods.\n\n**Functionality:**\n\n* Tests return valid signed bytes lists with or without watermarks.\n* Verifies the `.edsig` method returns a correct edsig signature.\n* Checks the `.hexIncludingPayload` method generates expected hex strings.", "metadata": {"repo": "magiclabs/tezart", "file": "test/signature/signature_test.dart", "chunk_number": 3, "total_chunks": 5}, "repository_explanation": "", "file_summary": "Here is a concise holistic summary of the file 'test/signature/signature_test.dart':\n\n**Summary:** This test suite verifies the functionality of the `Signature` class, ensuring correct behavior for various methods such as `.fromBytes`, `.edsig`, `.hexIncludingPayload`, and equality checks between signatures."}
{"code": "        ).hexIncludingPayload;\n\n    test('it returns a valid hex signature', () {\n      final expectedResult =\n          '123abd43e5c89a2420841314b6ab8aecdcddc5f91c82c75b4a77793a6a2e43e9db59aafeac1321af57fe326e4a17c083fe23f9b2d42bcc06ab9fca281a0194e45fee7401';\n      expect(subject(), equals(expectedResult));\n    });\n  });\n\n  group('equality', () {\n    test('two signatures are equal if their data and keystores are equal', () {\n      final data = '1234ae';\n      final sig1 = Signature.fromHex(data: data, keystore: keystore);\n      final sig2 = Signature.fromHex(data: data, keystore: keystore);\n\n      expect(sig1, equals(sig2));\n    });\n\n    test('two signatures are not equal if their keystores are different and their data are equal', () {\n      final data = '1234';\n      final keystore2 = Keystore.fromSeed('edsk4CCa2afKwHWGxB5oZd4jvhq6tgd5EzFaryyR4vLdC3nvpjKUG6');\n      final sig1 = Signature.fromHex(data: data, keystore: keystore);\n      final sig2 = Signature.fromHex(data: data, keystore: keystore2);\n", "explanation": "Here is a summary of the code block:\n\n**Purpose:** Testing the functionality of `Signature` class methods.\n\n**Functionality:**\n\n* Verifying that `hexIncludingPayload` returns a valid hex signature.\n* Testing equality between two signatures based on their data and keystore contents.", "metadata": {"repo": "magiclabs/tezart", "file": "test/signature/signature_test.dart", "chunk_number": 4, "total_chunks": 5}, "repository_explanation": "", "file_summary": "Here is a concise holistic summary of the file 'test/signature/signature_test.dart':\n\n**Summary:** This test suite verifies the functionality of the `Signature` class, ensuring correct behavior for various methods such as `.fromBytes`, `.edsig`, `.hexIncludingPayload`, and equality checks between signatures."}
{"code": "      expect(sig1, isNot(equals(sig2)));\n    });\n\n    test('two signatures are not equal if their datas are different and their keystores are equal', () {\n      final data1 = '1234';\n      final data2 = '4321';\n      final sig1 = Signature.fromHex(data: data1, keystore: keystore);\n      final sig2 = Signature.fromHex(data: data2, keystore: keystore);\n\n      expect(sig1, isNot(equals(sig2)));\n    });\n  });\n}\n", "explanation": "Here is a concise summary:\n\nThis block of code tests that two signatures (`sig1` and `sig2`) are not equal when their data contents are different, even if they share the same keystore.", "metadata": {"repo": "magiclabs/tezart", "file": "test/signature/signature_test.dart", "chunk_number": 5, "total_chunks": 5}, "repository_explanation": "", "file_summary": "Here is a concise holistic summary of the file 'test/signature/signature_test.dart':\n\n**Summary:** This test suite verifies the functionality of the `Signature` class, ensuring correct behavior for various methods such as `.fromBytes`, `.edsig`, `.hexIncludingPayload`, and equality checks between signatures."}
{"code": "import 'package:collection/collection.dart';\n\nFunction listEquals = const ListEquality().equals;\n", "explanation": "**Purpose:** Provides a function to compare two lists for equality.\n\n**Functionality:** `listEquals` is a function that takes two lists as input and returns `true` if they are equal, `false` otherwise.", "metadata": {"repo": "magiclabs/tezart", "file": "test/test_utils/common.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "", "file_summary": "Here's a concise summary of the file 'test/test_utils/common.dart':\n\n**File Summary:** Provides utility functions, including `listEquals`, for testing purposes in Dart applications."}
{"code": "import 'package:logging/logging.dart';\nimport '../env/env.dart';\nimport 'package:test/test.dart';\nimport 'dart:async';\n\nLevel _logLevel() {\n  return Level.LEVELS.firstWhere((level) => level.name == Env.logLevel, orElse: () => Level.OFF);\n}\n\nvoid logFailedTests() {\n  Logger.root.level = _logLevel();\n  StreamSubscription? subscription;\n\n  setUp(() {\n    subscription = Logger.root.onRecord.listen((record) {\n      printOnFailure(record.message);\n    });\n  });\n\n  tearDown(() {\n    subscription?.cancel();\n    subscription = null;\n  });\n}\n", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Set up logging for test failures, printing log messages when tests fail.\n\n**Functionality:** Establishes a logger that prints specific log records (i.e., messages) when tests fail, based on a configurable log level.", "metadata": {"repo": "magiclabs/tezart", "file": "test/test_utils/log_failed_tests.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "", "file_summary": "Here is a concise summary of the file 'test/test_utils/log_failed_tests.dart':\n\nSets up logging for test failures, printing log records with customizable verbosity when tests fail."}
{"code": "import 'package:tezart/tezart.dart';\nimport '../env/env.dart';\nimport './log_failed_tests.dart';\n\nTezartClient testClient() {\n  logFailedTests();\n  return TezartClient(Env.tezosNodeUrl);\n}\n", "explanation": "Here is a concise summary:\n\nThis block creates and returns a `TezartClient` instance, configured with a Tezos node URL from an environment variable. It also logs failed tests via a separate function `logFailedTests`.", "metadata": {"repo": "magiclabs/tezart", "file": "test/test_utils/test_client.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "", "file_summary": "Here is a concise and to-the-point holistic summary of the file 'test/test_utils/test_client.dart':\n\n\"Instantiates a `TezartClient` with a Tezos node URL from an environment variable, while logging failed tests via a separate function.\""}
{"code": "final List<Map<String, dynamic>> testContractScript = [\n  {\n    'prim': 'storage',\n    'args': [\n      {'prim': 'int'}\n    ]\n  },\n  {\n    'prim': 'parameter',\n    'args': [\n      {'prim': 'unit'}\n    ]\n  },\n  {\n    'prim': 'code',\n    'args': [\n      [\n        {'prim': 'CDR'},\n        {\n          'prim': 'NIL',\n          'args': [\n            {'prim': 'operation'}\n          ]\n        },\n        {'prim': 'PAIR'}\n      ]\n    ]\n  }\n];\n\nfinal List<Map<String, dynamic>> storeValueContract = [\n  {\n    'prim': 'storage',\n    'args': [\n      {'prim': 'nat'}\n    ]\n  },\n  {\n    'prim': 'parameter',\n    'args': [\n      {\n        'prim': 'or',\n        'args': [\n          {\n            'prim': 'nat',\n            'annots': ['%divide']\n          },\n          {\n            'prim': 'or',\n            'args': [\n              {\n                'prim': 'unit',\n                'annots': ['%double']\n              },\n              {\n                'prim': 'nat',\n                'annots': ['%replace']\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  },", "explanation": "Here is a concise summary:\n\nThis block defines two lists of contract scripts in JSON format.\n\n1. **testContractScript**: A single contract with three components: storage, parameter, and code.\n2. **storeValueContract**: A contract that stores a value (natural number) to storage, with optional parameters for division, doubling, or replacement.", "metadata": {"repo": "magiclabs/tezart", "file": "test/test_utils/test_contract_script.dart", "chunk_number": 1, "total_chunks": 15}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/test_utils/test_contract_script.dart':\n\nThis code defines various data structures representing Michelson smart contract code, used in Tezos blockchain. It includes sequences of operations for conditional execution, data manipulation, and logical operations. The code blocks define contracts with different functionalities, such as storing values, updating big maps, and performing arithmetic calculations. They use primitives like CAR, CDR, UPDATE, PAIR, SWAP, and DUP to manipulate data."}
{"code": "  {\n    'prim': 'code',\n    'args': [\n      [\n        {'prim': 'UNPAIR'},\n        {\n          'prim': 'IF_LEFT',\n          'args': [\n            [\n              {'prim': 'DUP'},\n              {\n                'prim': 'PUSH',\n                'args': [\n                  {'prim': 'nat'},\n                  {'int': '5'}\n                ]\n              },\n              {'prim': 'COMPARE'},\n              {'prim': 'LT'},\n              {\n                'prim': 'IF',\n                'args': [\n                  [],\n                  [\n                    {\n                      'prim': 'PUSH',\n                      'args': [\n                        {'prim': 'string'},\n                        {'string': 'WrongCondition: params.divisor > 5'}\n                      ]\n                    },\n                    {'prim': 'FAILWITH'}\n                  ]\n                ]\n              },\n              {'prim': 'SWAP'},\n              {'prim': 'EDIV'},\n              {\n                'prim': 'IF_NONE',\n                'args': [", "explanation": "**Block Purpose:** Error handling for division by value greater than 5.\n\n**Functionality:**\n\n1. Unpack arguments (UNPAIR).\n2. Check if left argument is less than 5 (COMPARE, LT, IF).\n3. If true, divide right argument by 5 (EDIV) and continue.\n4. Otherwise, push an error message (PUSH string) and fail with the error (FAILWITH).", "metadata": {"repo": "magiclabs/tezart", "file": "test/test_utils/test_contract_script.dart", "chunk_number": 2, "total_chunks": 15}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/test_utils/test_contract_script.dart':\n\nThis code defines various data structures representing Michelson smart contract code, used in Tezos blockchain. It includes sequences of operations for conditional execution, data manipulation, and logical operations. The code blocks define contracts with different functionalities, such as storing values, updating big maps, and performing arithmetic calculations. They use primitives like CAR, CDR, UPDATE, PAIR, SWAP, and DUP to manipulate data."}
{"code": "                  [\n                    {\n                      'prim': 'PUSH',\n                      'args': [\n                        {'prim': 'int'},\n                        {'int': '20'}\n                      ]\n                    },\n                    {'prim': 'FAILWITH'}\n                  ],\n                  [\n                    {'prim': 'CAR'}\n                  ]\n                ]\n              }\n            ],\n            [\n              {\n                'prim': 'IF_LEFT',\n                'args': [\n                  [\n                    {'prim': 'DROP'},\n                    {\n                      'prim': 'PUSH',\n                      'args': [\n                        {'prim': 'nat'},\n                        {'int': '2'}\n                      ]\n                    },\n                    {'prim': 'MUL'}\n                  ],\n                  [\n                    {'prim': 'SWAP'},\n                    {'prim': 'DROP'}\n                  ]\n                ]\n              }\n            ]\n          ]\n        },", "explanation": "This appears to be a data structure representing Michelson code, which is used in Tezos blockchain smart contracts.\n\nThe summary is:\n\n**Michelson Code Block**\n\n* Executes two programs sequentially:\n\t1. Pushes an integer value of 20 and fails if not executed.\n\t2. Returns the first element (CAR) of the result.\n* Conditional execution using IF_LEFT:\n\t+ If left branch succeeds, it drops a value, pushes a natural number value of 2, multiplies by 2, and returns.\n\t+ Otherwise, swaps two values and discards them.", "metadata": {"repo": "magiclabs/tezart", "file": "test/test_utils/test_contract_script.dart", "chunk_number": 3, "total_chunks": 15}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/test_utils/test_contract_script.dart':\n\nThis code defines various data structures representing Michelson smart contract code, used in Tezos blockchain. It includes sequences of operations for conditional execution, data manipulation, and logical operations. The code blocks define contracts with different functionalities, such as storing values, updating big maps, and performing arithmetic calculations. They use primitives like CAR, CDR, UPDATE, PAIR, SWAP, and DUP to manipulate data."}
{"code": "        {\n          'prim': 'NIL',\n          'args': [\n            {'prim': 'operation'}\n          ]\n        },\n        {'prim': 'PAIR'}\n      ]\n    ]\n  }\n];\n\nfinal bigMapContract = [\n  {\n    'prim': 'storage',\n    'args': [\n      {\n        'prim': 'big_map',\n        'args': [\n          {'prim': 'string'},\n          {'prim': 'string'}\n        ]\n      }\n    ]\n  },\n  {\n    'prim': 'parameter',\n    'args': [\n      {\n        'prim': 'pair',\n        'args': [\n          {\n            'prim': 'string',\n            'annots': ['%my_key']\n          },\n          {\n            'prim': 'string',\n            'annots': ['%my_val']\n          }\n        ],\n        'annots': ['%add_value']\n      }\n    ]\n  },\n  {\n    'prim': 'code',\n    'args': [\n      [\n        {'prim': 'UNPAIR'},\n        {'prim': 'DUP'},\n        {\n          'prim': 'DUG',\n          'args': [\n            {'int': '2'}\n          ]\n        },\n        {'prim': 'CDR'},\n        {'prim': 'SOME'},\n        {\n          'prim': 'DIG',\n          'args': [\n            {'int': '2'}\n          ]\n        },", "explanation": "Here is a concise summary:\n\nThis code block defines a contract with two functions: `storage` and `parameter`. The `storage` function creates a big map, while the `parameter` function adds a value to an existing pair in the map using a specific key.", "metadata": {"repo": "magiclabs/tezart", "file": "test/test_utils/test_contract_script.dart", "chunk_number": 4, "total_chunks": 15}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/test_utils/test_contract_script.dart':\n\nThis code defines various data structures representing Michelson smart contract code, used in Tezos blockchain. It includes sequences of operations for conditional execution, data manipulation, and logical operations. The code blocks define contracts with different functionalities, such as storing values, updating big maps, and performing arithmetic calculations. They use primitives like CAR, CDR, UPDATE, PAIR, SWAP, and DUP to manipulate data."}
{"code": "        {'prim': 'CAR'},\n        {'prim': 'UPDATE'},\n        {\n          'prim': 'NIL',\n          'args': [\n            {'prim': 'operation'}\n          ]\n        },\n        {'prim': 'PAIR'}\n      ]\n    ]\n  }\n];\n\nfinal noStorageContract = [\n  {\n    'prim': 'storage',\n    'args': [\n      {'prim': 'unit'}\n    ]\n  },\n  {\n    'prim': 'parameter',\n    'args': [\n      {\n        'prim': 'unit',\n        'annots': ['%empty_entrypoint']\n      }\n    ]\n  },\n  {\n    'prim': 'code',\n    'args': [\n      [\n        {'prim': 'CDR'},\n        {\n          'prim': 'NIL',\n          'args': [\n            {'prim': 'operation'}\n          ]\n        },\n        {'prim': 'PAIR'}\n      ]\n    ]\n  }\n];\n\nfinal multipleStructuresContract = [\n  {\n    'prim': 'storage',\n    'args': [\n      {\n        'prim': 'pair',\n        'args': [\n          {\n            'prim': 'big_map',\n            'args': [\n              {'prim': 'string'},\n              {'prim': 'string'}\n            ],\n            'annots': ['%my_big_map']\n          },\n          {\n            'prim': 'pair',", "explanation": "**Summary**\n\nThe provided blocks appear to be data structures representing Michelson smart contract code. They define various operations such as updating, pairing, and storing data in a contract.\n\n**Functionality**\n\n* The first block defines a sequence of operations:\n\t+ CAR (extract head)\n\t+ UPDATE\n\t+ NIL (delete operation)\n\t+ PAIR (create pair)\n* The second block (`noStorageContract`) defines a contract with no storage functionality.\n* The third block (`multipleStructuresContract`) defines a contract that stores multiple structures, specifically big maps and pairs.", "metadata": {"repo": "magiclabs/tezart", "file": "test/test_utils/test_contract_script.dart", "chunk_number": 5, "total_chunks": 15}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/test_utils/test_contract_script.dart':\n\nThis code defines various data structures representing Michelson smart contract code, used in Tezos blockchain. It includes sequences of operations for conditional execution, data manipulation, and logical operations. The code blocks define contracts with different functionalities, such as storing values, updating big maps, and performing arithmetic calculations. They use primitives like CAR, CDR, UPDATE, PAIR, SWAP, and DUP to manipulate data."}
{"code": "            'args': [\n              {\n                'prim': 'big_map',\n                'args': [\n                  {'prim': 'string'},\n                  {'prim': 'string'}\n                ],\n                'annots': ['%my_big_map_2']\n              },\n              {\n                'prim': 'map',\n                'args': [\n                  {'prim': 'string'},\n                  {'prim': 'string'}\n                ],\n                'annots': ['%my_map']\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  },\n  {\n    'prim': 'parameter',\n    'args': [\n      {\n        'prim': 'pair',\n        'args': [\n          {\n            'prim': 'string',\n            'annots': ['%my_key']\n          },\n          {\n            'prim': 'string',\n            'annots': ['%my_val']\n          }\n        ],\n        'annots': ['%add_value']\n      }\n    ]\n  },\n  {\n    'prim': 'code',\n    'args': [\n      [\n        {'prim': 'UNPAIR'},\n        {'prim': 'SWAP'},\n        {'prim': 'DUP'},\n        {'prim': 'CAR'},\n        {\n          'prim': 'DUP',", "explanation": "This block defines a parameterized schema for a smart contract. It consists of two main elements:\n\n1. A list of arguments (`args`) that define multiple data structures:\n\t* A `big_map` with two string arguments, annotated as `%my_big_map_2`.\n\t* A `map` with two string arguments, annotated as `%my_map`.\n2. A single parameter definition that takes a pair of strings as input, annotated as `%add_value`.", "metadata": {"repo": "magiclabs/tezart", "file": "test/test_utils/test_contract_script.dart", "chunk_number": 6, "total_chunks": 15}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/test_utils/test_contract_script.dart':\n\nThis code defines various data structures representing Michelson smart contract code, used in Tezos blockchain. It includes sequences of operations for conditional execution, data manipulation, and logical operations. The code blocks define contracts with different functionalities, such as storing values, updating big maps, and performing arithmetic calculations. They use primitives like CAR, CDR, UPDATE, PAIR, SWAP, and DUP to manipulate data."}
{"code": "          'args': [\n            {'int': '3'}\n          ]\n        },\n        {'prim': 'CDR'},\n        {'prim': 'SOME'},\n        {\n          'prim': 'DUP',\n          'args': [\n            {'int': '4'}\n          ]\n        },\n        {'prim': 'CAR'},\n        {'prim': 'UPDATE'},\n        {\n          'prim': 'UPDATE',\n          'args': [\n            {'int': '1'}\n          ]\n        },\n        {'prim': 'DUP'},\n        {\n          'prim': 'GET',\n          'args': [\n            {'int': '3'}\n          ]\n        },\n        {\n          'prim': 'DUP',\n          'args': [\n            {'int': '3'}\n          ]\n        },\n        {'prim': 'CDR'},\n        {'prim': 'SOME'},\n        {\n          'prim': 'DUP',\n          'args': [\n            {'int': '4'}\n          ]\n        },\n        {'prim': 'CAR'},\n        {'prim': 'UPDATE'},\n        {\n          'prim': 'UPDATE',\n          'args': [\n            {'int': '3'}\n          ]\n        },\n        {'prim': 'DUP'},\n        {\n          'prim': 'GET',\n          'args': [\n            {'int': '4'}\n          ]\n        },", "explanation": "This block appears to be a sequence of programming operations in a Scheme-like syntax, likely for manipulating linked data structures or lists. It defines a series of functions (called \"prim\") with various arguments (\"args\"), including numbers and some form of pointer manipulation. The purpose seems to be updating values within a list or tree structure, but the specific goal is unclear without more context.", "metadata": {"repo": "magiclabs/tezart", "file": "test/test_utils/test_contract_script.dart", "chunk_number": 7, "total_chunks": 15}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/test_utils/test_contract_script.dart':\n\nThis code defines various data structures representing Michelson smart contract code, used in Tezos blockchain. It includes sequences of operations for conditional execution, data manipulation, and logical operations. The code blocks define contracts with different functionalities, such as storing values, updating big maps, and performing arithmetic calculations. They use primitives like CAR, CDR, UPDATE, PAIR, SWAP, and DUP to manipulate data."}
{"code": "        {\n          'prim': 'DUP',\n          'args': [\n            {'int': '3'}\n          ]\n        },\n        {'prim': 'CDR'},\n        {'prim': 'SOME'},\n        {\n          'prim': 'DIG',\n          'args': [\n            {'int': '3'}\n          ]\n        },\n        {'prim': 'CAR'},\n        {'prim': 'UPDATE'},\n        {\n          'prim': 'UPDATE',\n          'args': [\n            {'int': '4'}\n          ]\n        },\n        {\n          'prim': 'NIL',\n          'args': [\n            {'prim': 'operation'}\n          ]\n        },\n        {'prim': 'PAIR'}\n      ]\n    ]\n  }\n];\n\nfinal List<Map<String, dynamic>> demoContract = [\n  {\n    'prim': 'storage',\n    'args': [\n      {\n        'prim': 'pair',\n        'args': [\n          {\n            'prim': 'big_map',\n            'args': [\n              {'prim': 'string'},\n              {'prim': 'int'}\n            ],\n            'annots': ['%big_map_first']\n          },\n          {\n            'prim': 'big_map',\n            'args': [\n              {'prim': 'string'},\n              {'prim': 'string'}", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\nThis block defines a sequence of operations on big maps, including updating values, retrieving specific data, and constructing data structures (e.g., pairs). The operations involve using functions such as DUP, CDR, SOME, DIG, CAR, UPDATE, NIL, and PAIR to manipulate data.", "metadata": {"repo": "magiclabs/tezart", "file": "test/test_utils/test_contract_script.dart", "chunk_number": 8, "total_chunks": 15}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/test_utils/test_contract_script.dart':\n\nThis code defines various data structures representing Michelson smart contract code, used in Tezos blockchain. It includes sequences of operations for conditional execution, data manipulation, and logical operations. The code blocks define contracts with different functionalities, such as storing values, updating big maps, and performing arithmetic calculations. They use primitives like CAR, CDR, UPDATE, PAIR, SWAP, and DUP to manipulate data."}
{"code": "            ],\n            'annots': ['%big_map_second']\n          }\n        ]\n      }\n    ]\n  },\n  {\n    'prim': 'parameter',\n    'args': [\n      {\n        'prim': 'or',\n        'args': [\n          {\n            'prim': 'or',\n            'args': [\n              {\n                'prim': 'pair',\n                'args': [\n                  {\n                    'prim': 'string',\n                    'annots': ['%key']\n                  },\n                  {\n                    'prim': 'int',\n                    'annots': ['%value']\n                  }\n                ],\n                'annots': ['%add_first']\n              },\n              {\n                'prim': 'pair',\n                'args': [\n                  {\n                    'prim': 'string',\n                    'annots': ['%key']\n                  },\n                  {\n                    'prim': 'string',\n                    'annots': ['%value']\n                  }\n                ],\n                'annots': ['%add_second']\n              }\n            ]", "explanation": "This block defines a parameter with two possible values, represented as \"or\" conditions. The conditions are pairs of key-value data, where keys can be strings and values can be either integers or strings.", "metadata": {"repo": "magiclabs/tezart", "file": "test/test_utils/test_contract_script.dart", "chunk_number": 9, "total_chunks": 15}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/test_utils/test_contract_script.dart':\n\nThis code defines various data structures representing Michelson smart contract code, used in Tezos blockchain. It includes sequences of operations for conditional execution, data manipulation, and logical operations. The code blocks define contracts with different functionalities, such as storing values, updating big maps, and performing arithmetic calculations. They use primitives like CAR, CDR, UPDATE, PAIR, SWAP, and DUP to manipulate data."}
{"code": "          },\n          {\n            'prim': 'or',\n            'args': [\n              {\n                'prim': 'pair',\n                'args': [\n                  {\n                    'prim': 'pair',\n                    'args': [\n                      {\n                        'prim': 'string',\n                        'annots': ['%first']\n                      },\n                      {\n                        'prim': 'string',\n                        'annots': ['%key']\n                      }\n                    ]\n                  },\n                  {\n                    'prim': 'pair',\n                    'args': [\n                      {\n                        'prim': 'string',\n                        'annots': ['%second']\n                      },\n                      {\n                        'prim': 'string',\n                        'annots': ['%third']\n                      }\n                    ]\n                  }\n                ],\n                'annots': ['%add_third']\n              },", "explanation": "This block defines a data structure using prim (primitive) and args (arguments). It appears to be a nested JSON-like object, possibly for use in code generation or a configuration file. The exact purpose depends on the context in which it's being used.", "metadata": {"repo": "magiclabs/tezart", "file": "test/test_utils/test_contract_script.dart", "chunk_number": 10, "total_chunks": 15}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/test_utils/test_contract_script.dart':\n\nThis code defines various data structures representing Michelson smart contract code, used in Tezos blockchain. It includes sequences of operations for conditional execution, data manipulation, and logical operations. The code blocks define contracts with different functionalities, such as storing values, updating big maps, and performing arithmetic calculations. They use primitives like CAR, CDR, UPDATE, PAIR, SWAP, and DUP to manipulate data."}
{"code": "              {\n                'prim': 'nat',\n                'annots': ['%always_fail']\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  },\n  {\n    'prim': 'code',\n    'args': [\n      [\n        {'prim': 'UNPAIR'},\n        {\n          'prim': 'IF_LEFT',\n          'args': [\n            [\n              {\n                'prim': 'IF_LEFT',\n                'args': [\n                  [\n                    {'prim': 'SWAP'},\n                    {'prim': 'UNPAIR'},\n                    {\n                      'prim': 'DUP',\n                      'args': [\n                        {'int': '3'}\n                      ]\n                    },\n                    {'prim': 'CDR'},\n                    {'prim': 'SOME'},\n                    {\n                      'prim': 'DIG',\n                      'args': [\n                        {'int': '3'}\n                      ]\n                    },\n                    {'prim': 'CAR'},\n                    {'prim': 'UPDATE'},\n                    {'prim': 'PAIR'}\n                  ],", "explanation": "This block is a data structure representing a Camille code, likely used in a blockchain or cryptographic context. It consists of a list of instructions that can be executed on-chain.\n\nFunctionalities include:\n\n* Conditional execution (`IF_LEFT`)\n* Data manipulation (`UNPAIR`, `SWAP`, `DUP`, `CDR`, `CAR`, `UPDATE`)\n* Logical and bitwise operations (not explicitly listed, but implied by the presence of `DIG` and other prim functions)\n\nThe purpose is to perform a specific computation or update on-chain.", "metadata": {"repo": "magiclabs/tezart", "file": "test/test_utils/test_contract_script.dart", "chunk_number": 11, "total_chunks": 15}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/test_utils/test_contract_script.dart':\n\nThis code defines various data structures representing Michelson smart contract code, used in Tezos blockchain. It includes sequences of operations for conditional execution, data manipulation, and logical operations. The code blocks define contracts with different functionalities, such as storing values, updating big maps, and performing arithmetic calculations. They use primitives like CAR, CDR, UPDATE, PAIR, SWAP, and DUP to manipulate data."}
{"code": "                  [\n                    {'prim': 'SWAP'},\n                    {'prim': 'UNPAIR'},\n                    {'prim': 'SWAP'},\n                    {\n                      'prim': 'DUP',\n                      'args': [\n                        {'int': '3'}\n                      ]\n                    },\n                    {'prim': 'CDR'},\n                    {'prim': 'SOME'},\n                    {\n                      'prim': 'DIG',\n                      'args': [\n                        {'int': '3'}\n                      ]\n                    },\n                    {'prim': 'CAR'},\n                    {'prim': 'UPDATE'},\n                    {'prim': 'SWAP'},\n                    {'prim': 'PAIR'}\n                  ]\n                ]\n              }\n            ],\n            [\n              {\n                'prim': 'IF_LEFT',\n                'args': [\n                  [\n                    {'prim': 'SWAP'},\n                    {'prim': 'UNPAIR'},\n                    {'prim': 'SWAP'},\n                    {", "explanation": "Here is a concise summary:\n\nThis block appears to be a sequence of Scheme-like code primitives, likely used in a programming context. The purpose is to manipulate data (likely lists or pairs) using various operations such as swapping, pairing, unpairing, duplication, and conditional checks.", "metadata": {"repo": "magiclabs/tezart", "file": "test/test_utils/test_contract_script.dart", "chunk_number": 12, "total_chunks": 15}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/test_utils/test_contract_script.dart':\n\nThis code defines various data structures representing Michelson smart contract code, used in Tezos blockchain. It includes sequences of operations for conditional execution, data manipulation, and logical operations. The code blocks define contracts with different functionalities, such as storing values, updating big maps, and performing arithmetic calculations. They use primitives like CAR, CDR, UPDATE, PAIR, SWAP, and DUP to manipulate data."}
{"code": "                      'prim': 'DIG',\n                      'args': [\n                        {'int': '2'}\n                      ]\n                    },\n                    {'prim': 'DUP'},\n                    {\n                      'prim': 'GET',\n                      'args': [\n                        {'int': '4'}\n                      ]\n                    },\n                    {'prim': 'SWAP'},\n                    {'prim': 'DUP'},\n                    {\n                      'prim': 'GET',\n                      'args': [\n                        {'int': '3'}\n                      ]\n                    },\n                    {'prim': 'SWAP'},\n                    {'prim': 'DUP'},\n                    {\n                      'prim': 'DUG',\n                      'args': [\n                        {'int': '5'}\n                      ]\n                    },\n                    {'prim': 'CAR'},\n                    {'prim': 'CAR'},\n                    {'prim': 'CONCAT'},\n                    {'prim': 'CONCAT'},", "explanation": "This block appears to be a series of instructions in a programming language, likely used for string manipulation. It fetches and manipulates strings using primitives like GET, SWAP, DUP, CAR, and CONCAT.", "metadata": {"repo": "magiclabs/tezart", "file": "test/test_utils/test_contract_script.dart", "chunk_number": 13, "total_chunks": 15}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/test_utils/test_contract_script.dart':\n\nThis code defines various data structures representing Michelson smart contract code, used in Tezos blockchain. It includes sequences of operations for conditional execution, data manipulation, and logical operations. The code blocks define contracts with different functionalities, such as storing values, updating big maps, and performing arithmetic calculations. They use primitives like CAR, CDR, UPDATE, PAIR, SWAP, and DUP to manipulate data."}
{"code": "                    {'prim': 'SOME'},\n                    {\n                      'prim': 'DIG',\n                      'args': [\n                        {'int': '3'}\n                      ]\n                    },\n                    {'prim': 'CAR'},\n                    {'prim': 'CDR'},\n                    {'prim': 'UPDATE'},\n                    {'prim': 'SWAP'},\n                    {'prim': 'PAIR'}\n                  ],\n                  [\n                    {\n                      'prim': 'PUSH',\n                      'args': [\n                        {'prim': 'nat'},\n                        {'int': '0'}\n                      ]\n                    },\n                    {'prim': 'SWAP'},\n                    {'prim': 'COMPARE'},\n                    {'prim': 'GE'},\n                    {\n                      'prim': 'IF',\n                      'args': [\n                        [\n                          {\n                            'prim': 'PUSH',\n                            'args': [", "explanation": "This block appears to be a list of code snippets, likely in Scheme or Lisp syntax, that define a series of primitive functions and operations. The functionality includes:\n\n* Basic data manipulation (CAR, CDR, UPDATE)\n* List processing (PAIR, SWAP)\n* Conditional logic (IF, GE)\n* Stack-based arithmetic (PUSH, COMPARE)\n\nThe purpose is to perform various computations using these primitives.", "metadata": {"repo": "magiclabs/tezart", "file": "test/test_utils/test_contract_script.dart", "chunk_number": 14, "total_chunks": 15}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/test_utils/test_contract_script.dart':\n\nThis code defines various data structures representing Michelson smart contract code, used in Tezos blockchain. It includes sequences of operations for conditional execution, data manipulation, and logical operations. The code blocks define contracts with different functionalities, such as storing values, updating big maps, and performing arithmetic calculations. They use primitives like CAR, CDR, UPDATE, PAIR, SWAP, and DUP to manipulate data."}
{"code": "                              {'prim': 'string'},\n                              {'string': \"I'm failing\"}\n                            ]\n                          },\n                          {'prim': 'FAILWITH'}\n                        ],\n                        []\n                      ]\n                    }\n                  ]\n                ]\n              }\n            ]\n          ]\n        },\n        {\n          'prim': 'NIL',\n          'args': [\n            {'prim': 'operation'}\n          ]\n        },\n        {'prim': 'PAIR'}\n      ]\n    ]\n  }\n];\n", "explanation": "This is a Scheme program data structure (S-expression) that appears to be implementing a stack with two operations: `FAILWITH` and `NIL`. The stack's initial state has \"I'm failing\" as its top element, and `FAILWITH` is pushed onto it, followed by `NIL`.", "metadata": {"repo": "magiclabs/tezart", "file": "test/test_utils/test_contract_script.dart", "chunk_number": 15, "total_chunks": 15}, "repository_explanation": "", "file_summary": "Here is a holistic summary of the file 'test/test_utils/test_contract_script.dart':\n\nThis code defines various data structures representing Michelson smart contract code, used in Tezos blockchain. It includes sequences of operations for conditional execution, data manipulation, and logical operations. The code blocks define contracts with different functionalities, such as storing values, updating big maps, and performing arithmetic calculations. They use primitives like CAR, CDR, UPDATE, PAIR, SWAP, and DUP to manipulate data."}
{"code": "// ignore_for_file: prefer_function_declarations_over_variables\n\nimport 'package:test/test.dart';\nimport 'package:tezart/src/common/validators/simulation_result_validator.dart';\nimport 'package:tezart/tezart.dart';\n\nvoid main() {\n  final subject = (Map<String, dynamic> simulationResult) => SimulationResultValidator(simulationResult).validate();\n\n  group('when the simulation result status is applied', () {\n    final simulationResult = {\n      'kind': 'origination',\n      'metadata': {\n        'operation_result': {'status': 'applied'}\n      }\n    };\n\n    test('it doesnt throw an error', () {\n      expect(() => subject(simulationResult), returnsNormally);\n    });\n  });\n\n  group('when the simulation result status is failed', () {\n    final simulationResult = {\n      'kind': 'origination',\n      'metadata': {\n        'operation_result': {\n          'status': 'failed',\n          'errors': [\n            {\n              'id': 'proto.123.error1',\n            },\n            {\n              'id': 'proto.123.error2',", "explanation": "**Summary:**\n\nThis block is a test suite written in Dart using the `test` package. It tests the functionality of a validator for simulation results, specifically checking that it doesn't throw an error when the status is \"applied\" or \"failed\". The code imports necessary libraries and defines test cases to verify the behavior of the `SimulationResultValidator`.", "metadata": {"repo": "magiclabs/tezart", "file": "test/validators/simulation_result_validator_test.dart", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "", "file_summary": "Here is a concise and to-the-point summary:\n\n**Summary:** \nThis file contains test cases for the `SimulationResultValidator` in Dart, verifying its behavior under various conditions, specifically checking for exception-free execution when status is \"applied\" or \"failed\"."}
{"code": "            },\n          ],\n        },\n      },\n    };\n\n    test('it throws a TezartNodeError', () {\n      expect(\n          () => subject(simulationResult),\n          throwsA(\n            predicate((e) =>\n                e is TezartNodeError &&\n                e.type == TezartNodeErrorTypes.simulationFailed &&\n                e.message == 'The simulation of the operation: \"origination\" failed with error(s) : error1, error2'),\n          ));\n    });\n  });\n}\n", "explanation": "Here is a concise summary:\n\nThis block is a test in a testing framework (likely Dart's `test` package). It expects a specific exception (`TezartNodeError`) to be thrown when running a simulation, with a particular error message and type.", "metadata": {"repo": "magiclabs/tezart", "file": "test/validators/simulation_result_validator_test.dart", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "", "file_summary": "Here is a concise and to-the-point summary:\n\n**Summary:** \nThis file contains test cases for the `SimulationResultValidator` in Dart, verifying its behavior under various conditions, specifically checking for exception-free execution when status is \"applied\" or \"failed\"."}
{"code": "#!/bin/bash\n\n# utility functions\n/bin/bash ./tool/tezart $@", "explanation": "**Summary**\n\nThis is a Bash script that serves as an entry point for a TezArt tool, calling its main function (`./tool/tezart`) with any command-line arguments ($@) passed to it.", "metadata": {"repo": "magiclabs/tezart", "file": "tezart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "", "file_summary": "Here is a concise summary of the file 'tezart':\n\n**Summary**\n\nEntry script that launches TezArt tool with optional command-line arguments."}
{"code": ".___________. _______  ________      ___      .______     .___________.\n|           ||   ____||       /     /   \\     |   _  \\    |           |\n`---|  |----`|  |__   `---/  /     /  ^  \\    |  |_)  |   `---|  |----`\n    |  |     |   __|     /  /     /  /_\\  \\   |      /        |  |     \n    |  |     |  |____   /  /----./  _____  \\  |  |\\  \\----.   |  |     \n    |__|     |_______| /________/__/     \\__\\ | _| `._____|   |__|     \n                                                                       ", "explanation": "This block appears to be a text-based ASCII art representation of a logo or icon, possibly for a gaming character (e.g. Link from The Legend of Zelda).", "metadata": {"repo": "magiclabs/tezart", "file": "tool/info-tezart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "", "file_summary": "Here is a holistic summary:\n\n**tool/info-tezart**: A simple, text-based ASCII art logo/icon representation, likely for a gaming character."}
{"code": "#!/bin/bash\n\n###################################################################                                                                                                                                                                                                                   \n# Description : \n# Utility functions to perform logging.\n#\n###################################################################\n\nreadonly BOLD=$(tput bold)\nexport NORMAL=$(tput sgr0)\nreadonly BLUE=\"\\\\033[1;34m\"\nreadonly RED=\"\\\\033[1;31m\"\nreadonly GREEN=\"\\\\033[1;32m\"\nreadonly YELLOW=\"\\\\033[1;33m\"\nreadonly MAGENTA=\"\\\\033[1;35m\"\nreadonly GRAS=\"\\033[1m\"\nreadonly END=\"\\\\033[1;00m\"\nreadonly CHECK_MARK=\"\\xE2\\x9C\\x94\"\nreadonly SUFFIX=\"TEZART\"\n\n####\n## Display url link in output\n## $1 message\n## $2 url\nlog::url() {\n\techo -e \"\\\\e]8;;http://example.com\\\\aThis is a hyperlink\\e]8;;\\\\a\"\n}\n\nlog::error() {\n\techo -e \"\\n$RED [ERROR:$SUFFIX] $* $END\" >&2\n}\n\nlog::error_and_exit() {\n\techo -e \"\\n$RED [ERROR:$SUFFIX] $*\\n $END\" >&2 && exit 1\n}\n\nlog::info() {", "explanation": "**Summary**\n\nThis is a Bash script that defines utility functions for logging purposes. It exports colors and sets up some basic logging functions, including:\n\n* `log::url`: displays a URL link in output\n* `log::error`: logs an error message with red color\n* `log::error_and_exit`: logs an error message and exits the program with code 1\n\nThe script uses ANSI escape codes to display colored text.", "metadata": {"repo": "magiclabs/tezart", "file": "tool/logger.sh", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "", "file_summary": "Here is a concise summary of the file 'tool/logger.sh':\n\nThis Bash script provides a set of logging utilities with colored output, including error handling and exit functionality. It exports 11 logging functions for various message types (INFO, DEBUG, WARN, ERROR), making it easy to log different types of messages in a shell script."}
{"code": "\techo -e \"\\n$GREEN [INFO:$SUFFIX]$END $* $END\"\n}\n\nlog::info_success() {\n\techo -e \"\\n$GREEN [INFO:$SUFFIX]$END $* $GREEN $CHECK_MARK $END\"\n}\n\nlog::info_and_exit() {\n\techo -e \"\\n$GREEN [INFO:$SUFFIX] $* $END\" && exit 0\n}\n\nlog::debug() {\n\t[[ -n $DEBUG ]] && echo -e \"\\n$BLUE [DEBUG:$SUFFIX---] $* $END\"\n}\n\nlog::warn() {\n\techo -e \"\\n$YELLOW [WARN:$SUFFIX] $* $END\"\n}\n\nlog::warn_and_exit() {\n\techo -e \"\\n$YELLOW [WARN:$SUFFIX] $* $END\" && exit 0\n}\n\nlog::message_success() {\n\techo -e \" $* $GREEN $CHECK_MARK $END\"\n}\n\nlog::message_error() {\n\techo -e \" $* $RED x $END\"\n}\n\nlog::title() {\n\techo -e \"\\n $* \"\n}  \n\nlog::title_success() {\n\techo -e \"\\n $GREEN [\u2713] $END $* \"\n}\n\nlog::title_warning() {\n\techo -e \"\\n $YELLOW [!] $END $* \"\n}\n\nlog::message() {\n\techo -e \" $* \"\n}  \n\n\nlog::application(){\n\techo -e \"\\n\\n$GREEN$(cat $BASEDIR/../tool/info-tezart)$END\"\n}", "explanation": "**Purpose:** A collection of logging functions for a shell script.\n\n**Functionality:**\n\nThe code defines 11 logging functions that display messages in various colors, including:\n\n* `INFO` (green)\n* `DEBUG` (blue)\n* `WARN` (yellow)\n* `ERROR` (red)\n\nEach function is designed to print a message with a specific color and prefix, followed by an optional suffix and exit code. The functions can be used to log different types of messages, such as successes, failures, warnings, and more.", "metadata": {"repo": "magiclabs/tezart", "file": "tool/logger.sh", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "", "file_summary": "Here is a concise summary of the file 'tool/logger.sh':\n\nThis Bash script provides a set of logging utilities with colored output, including error handling and exit functionality. It exports 11 logging functions for various message types (INFO, DEBUG, WARN, ERROR), making it easy to log different types of messages in a shell script."}
{"code": "import 'dart:io' show File;\nimport 'dart:convert';\n\nvoid main() async {\n  final jsonContent = await File('pana_output.json').readAsString();\n  final decoded = json.decode(jsonContent);\n  print(decoded['scores']['grantedPoints']);\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Reads JSON data from a file named \"pana_output.json\" and prints a specific value.\n\n**Functionality:** Async function that reads the file, decodes its content as JSON, and extracts a specific key-value pair (\"scores\" -> \"grantedPoints\") to print.", "metadata": {"repo": "magiclabs/tezart", "file": "tool/pana_output_parser.dart", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "", "file_summary": "Here is a concise summary of the file 'tool/pana_output_parser.dart':\n\n**Purpose:** Parses JSON data from \"pana_output.json\" and prints the \"grantedPoints\" value.\n\nLet me know if you'd like me to add anything!"}
{"code": "#!/bin/bash\n\n# exit when any command fails\nset -e\n\n###################################################################                                                                                                                                                                                                                   \n# Description : \n# Utility functions for dev, ci/cd operations ...\n#\n###################################################################\n\nreadonly BASEDIR=$( cd $( dirname $0 ) && pwd )\n\nsource $BASEDIR/../tool/logger.sh\n\n#  \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n#  \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\n#  \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2557  \n#  \u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \n#  \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n#  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\nUSAGE_HELP='Display this message'\nUSAGE_RUN_DOCTOR='Process to run the setup of the project'\nUSAGE_RUN_TESTS='Process to run tests'", "explanation": "**Summary**\n\nThis is a Bash script that:\n\n* Sets an error exit policy\n* Sources a logger function\n* Defines several utility functions for development, CI/CD operations\n* Displays usage help, runs project setup, or runs tests upon execution.", "metadata": {"repo": "magiclabs/tezart", "file": "tool/tezart", "chunk_number": 1, "total_chunks": 7}, "repository_explanation": "", "file_summary": "Here's a concise summary:\n\nThe `tool/tezart` file is a Bash script that provides a command-line interface for managing a Dart project called TezarT. It defines utility functions for development, CI/CD operations, and runs various tasks such as tests, code coverage, documentation, and performance analysis based on options provided. The script also checks requirements and local chain setup for the project."}
{"code": "USAGE_RUN_COVERAGE='Process to run the code coverage in dev environment'\nUSAGE_RUN_DOCS='Process to launch the documentation in dev environment'\nUSAGE_RUN_PANA='Process for analyzing the package with pana'\n\nusage() {\n\n\tlog::application\n\tcat <<EOF\n\n\tUsage: Script used to perform dev, ci/cd operations\n\n\tOPTIONS:\n\t========\n\tdoctor\t\t$USAGE_RUN_DOCTOR\n\ttests\t\t$USAGE_RUN_TESTS\n\tcoverage \t$USAGE_RUN_COVERAGE\n\tdocs \t\t$USAGE_RUN_DOCS\n\tpana \t\t$USAGE_RUN_PANA\n\t-h \t\t$USAGE_HELP\n\nEOF\n}\n\n###########\n### PRIVATE \n###########\n\ntezart::_check_localhost_chain() {\n\tretry=1\n\tisSanboxRunning=1\n\twhile [[ retry -le 5 ]]\n\tdo  \n\t\tcurl -s localhost:20000/chains/main/mempool/pending_operations  > /dev/null && isSanboxRunning=0 && break\n\t\tlog::warn \"retry $retry : Unable to curl localhost:20000/chains/main/mempool/pending_operations\"\n\t\t((retry=retry+1))\n\t\tsleep 1\n\tdone\n\t\n\tif [[ isSanboxRunning -eq 0 ]]\n\tthen\n\t\tlog::title_success \"a tezos sandbox is running locally\"\n\telse\n\t\tlog::error_and_exit \"Please read the README.md to run a tezos sandbox locally.\"\n\tfi\n", "explanation": "**Summary**\n\nThis block appears to be a script that provides a command-line interface for performing development, CI/CD operations on a Tezos project.\n\nThe script offers several options:\n\n* `doctor`: Analyze the package with Doctor (not shown in this excerpt)\n* `tests`: Run tests\n* `coverage`: Process code coverage in dev environment\n* `docs`: Launch documentation in dev environment\n* `pana`: Analyze the package with Pana\n\nIt also includes a private function `_check_localhost_chain` to verify if a Tezos sandbox is running locally.", "metadata": {"repo": "magiclabs/tezart", "file": "tool/tezart", "chunk_number": 2, "total_chunks": 7}, "repository_explanation": "", "file_summary": "Here's a concise summary:\n\nThe `tool/tezart` file is a Bash script that provides a command-line interface for managing a Dart project called TezarT. It defines utility functions for development, CI/CD operations, and runs various tasks such as tests, code coverage, documentation, and performance analysis based on options provided. The script also checks requirements and local chain setup for the project."}
{"code": "\t\n}\n\ntezart::_check_requirements() {\n\t## check for docker\n\tif docker --version &>/dev/null\n\tthen\n\t\tlog::title_success \"docker is present on your system\"\n\telse\n\t\tlog::error_and_exit 'The docker is missing on your system. Please read the README.md to install it'\n\tfi\n\n\t## check for dart\n\tif dart --version &>/dev/null\n\tthen\n\t\tlog::title_success \"dart sdk is present on your system\"\n\telse\n\t\tlog::error_and_exit 'The dart sdk is missing on your system. Please read the README.md to install it'\n\tfi\n\n\t## check for lefthook\n\tif lefthook &>/dev/null\n\tthen\n\t\tlog::title_success \"lefthook is present on your system\"\n\telse\n\t\tlog::error_and_exit 'The Lefthook plugin is missing on your system. Please read the README.md to install it'\n\tfi\n\n}\n\ntezart::_init_env_var() {\n\n\tif [[ -f .env.test ]]\n\tthen\n\t\tlog::title_warning \".env.test file is already found. The script won't generate a new one\"\n\telse\n\t\tlog::title_success \"a new .env.test file is generated for your tests\"\n\t\tcp .env.dist .env.test\n\tfi\n}\n\ntezart::_run_build_runner() {", "explanation": "Here are the summaries:\n\n**Tezart::_check_requirements**\n\nChecks for required tools (docker, dart, lefthook) on the system and exits with error if any are missing.\n\n**Tezart::_init_env_var**\n\nInitializes environment variables by copying a template file (.env.dist) to .env.test if it doesn't already exist.", "metadata": {"repo": "magiclabs/tezart", "file": "tool/tezart", "chunk_number": 3, "total_chunks": 7}, "repository_explanation": "", "file_summary": "Here's a concise summary:\n\nThe `tool/tezart` file is a Bash script that provides a command-line interface for managing a Dart project called TezarT. It defines utility functions for development, CI/CD operations, and runs various tasks such as tests, code coverage, documentation, and performance analysis based on options provided. The script also checks requirements and local chain setup for the project."}
{"code": "\tbase_command=\"dart run build_runner build\"\n\toptions=$([ \"$CI\" == true ] && echo \"--delete-conflicting-outputs\" || echo \"\")\n\tcommand=\"$base_command $options\"\n\teval $command\n}\n\n###########\n### PUBLIC \n###########\n\ntezart::run_coverage() {\n\tlog::info \"$USAGE_RUN_COVERAGE :\"\n\n\tdart pub get\n\ttezart::_run_build_runner\n\n\ttezart::_check_localhost_chain\n\ttezart::_init_env_var\n\n\tdart run test --concurrency=1 --chain-stack-traces --coverage ./coverage\n\tdart pub global activate coverage > /dev/null\n\texport PATH=\"$PATH\":\"$HOME/.pub-cache/bin\"\n\tformat_coverage --lcov --in=coverage --out=coverage/lcov.info --packages=.dart_tool/package_config.json --report-on=lib\n\n\tif [[ $CI != true ]]\n\tthen\n\t\t# Generate coverage info\n\t\tgenhtml -o coverage coverage/lcov.info\n\n\t\t# Open to see coverage info\n\t\topen coverage/index.html\n\tfi\n}\n\ntezart::run_doctor() {\n\tlog::info \"$USAGE_RUN_DOCTOR :\"\n\n\ttezart::_check_requirements\n\ttezart::_check_localhost_chain\n\ttezart::_init_env_var\n}\n\ntezart::run_tests() {\n\tlog::info \"$USAGE_RUN_TESTS :\"\n", "explanation": "Here is a concise summary of the purpose and functionality of these blocks:\n\n**Block 1:**\nA build script that runs `build_runner` with optional delete conflicting outputs flag, based on whether it's running in CI mode.\n\n**Block 2 (tezart::run_coverage):**\nRuns code coverage analysis for TezarT project using Dart, including:\n\t* Running tests with coverage and concurrency=1\n\t* Formatting coverage output to lcov format\n\t* Optionally generating HTML report and opening it in browser\n\n**Block 3 (tezart::run_doctor):**\nChecks requirements and local chain setup for TezarT project.\n\n**Block 4 (tezart::run_tests):**\nRuns tests for TezarT project.", "metadata": {"repo": "magiclabs/tezart", "file": "tool/tezart", "chunk_number": 4, "total_chunks": 7}, "repository_explanation": "", "file_summary": "Here's a concise summary:\n\nThe `tool/tezart` file is a Bash script that provides a command-line interface for managing a Dart project called TezarT. It defines utility functions for development, CI/CD operations, and runs various tasks such as tests, code coverage, documentation, and performance analysis based on options provided. The script also checks requirements and local chain setup for the project."}
{"code": "\ttezart::_check_localhost_chain\n\ttezart::_init_env_var\n\n\techo -e '\\n'\n\n\tdart pub get\n\ttezart::_run_build_runner\n\n\tdart run test --chain-stack-traces\n}\n\ntezart::run_docs() {\n\tlog::info \"$USAGE_RUN_DOCS :\"\n\n\tdart pub global activate dhttpd > /dev/null\n\tdhttpd --path docs\n}\n\ntezart::run_pana() {\n\tlog::info \"$USAGE_RUN_PANA :\"\n\n\tdart pub global activate pana 0.20.1 > /dev/null \n\texport PATH=\"$PATH\":\"$HOME/.pub-cache/bin\"\n\tdart pub global run pana -j > pana_output.json \n\t\n\tscore=$(dart tool/pana_output_parser.dart)\n\tlog::info \"pub.dev Score is $score\"\n\tif (( $score < 70 ))\n\tthen\n\t\tlog::error_and_exit \"You must improve the pana score\"\n\telse\n\t\tlog::title_success \"the score is ok\"\n\tfi\n\t\n}\n\n# \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557    \n# \u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551    \n# \u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551    \n# \u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551    \n# \u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551    \n# \u255a\u2550\u255d     \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d    \n\n#\n## Optional parameters\nRUN_DOCTOR=\nRUN_TESTS=\nRUN_COVERAGE=\nRUN_DOCS=\nRUN_PANA=\n\nmain() {", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** A shell script for managing and testing a Dart project.\n\n**Functionality:**\n\n* Installs dependencies using `dart pub get`.\n* Runs unit tests with chain stack traces.\n* Generates documentation using `tezart::run_docs`.\n* Runs performance analysis tool (`pana`) and checks its score.\n* Provides optional parameters to control the execution of these tasks.", "metadata": {"repo": "magiclabs/tezart", "file": "tool/tezart", "chunk_number": 5, "total_chunks": 7}, "repository_explanation": "", "file_summary": "Here's a concise summary:\n\nThe `tool/tezart` file is a Bash script that provides a command-line interface for managing a Dart project called TezarT. It defines utility functions for development, CI/CD operations, and runs various tasks such as tests, code coverage, documentation, and performance analysis based on options provided. The script also checks requirements and local chain setup for the project."}
{"code": "\t[[ -n $RUN_DOCTOR ]] && tezart::run_doctor\n\t[[ -n $RUN_TESTS ]] && tezart::run_tests\n\t[[ -n $RUN_COVERAGE ]] && tezart::run_coverage\n\t[[ -n $RUN_DOCS ]] && tezart::run_docs\n\t[[ -n $RUN_PANA ]] && tezart::run_pana\n\texit 0\n}\n\n#  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n# \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\n# \u2588\u2588\u2551  \u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n# \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d     \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\n# \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2551   \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\n#  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d   \u255a\u2550\u255d    \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n                                                   \n# Parse options to the `tezart` command\nwhile getopts \":h\" opt; do\n\tcase ${opt} in\n\t\th )\n\t\t\tusage\n\t\t\texit 0\n\t\t;;\n\t\t\\? )\n\t\t\tlog::error \"Invalid Option: -$OPTARG \"\n\t\t\tusage\n\t\t\texit 1\n\t\t;;\n\tesac\ndone\nshift $((OPTIND -1))\n\nsubcommand=$1; shift  # Remove 'tezart' from the argument list\ncase \"$subcommand\" in\n\tdoctor)\n\t\tRUN_DOCTOR=1\n\t\t;;\n\ttests)\n\t\tRUN_TESTS=1\n\t\t;;\n\tcoverage)\n\t\tRUN_COVERAGE=1\n\t\t;;\n\tdocs)\n\t\tRUN_DOCS=1\n\t\t;;\n\tpana)\n\t\tRUN_PANA=1\n\t\t;;\n\t*)", "explanation": "**Purpose:** Run specific tasks for the `tezart` command based on options provided.\n\n**Functionality:**\n\n* If any of the following environment variables are set, corresponding functions are executed:\n\t+ RUN_DOCTOR: run_doctor\n\t+ RUN_TESTS: run_tests\n\t+ RUN_COVERAGE: run_coverage\n\t+ RUN_DOCS: run_docs\n\t+ RUN_PANA: run_pana\n* Parse command-line options using `getopts` and handle help option (`-h`) or invalid input.\n* Execute a subcommand function based on the first argument passed to the script (e.g., \"doctor\", \"tests\", etc.).", "metadata": {"repo": "magiclabs/tezart", "file": "tool/tezart", "chunk_number": 6, "total_chunks": 7}, "repository_explanation": "", "file_summary": "Here's a concise summary:\n\nThe `tool/tezart` file is a Bash script that provides a command-line interface for managing a Dart project called TezarT. It defines utility functions for development, CI/CD operations, and runs various tasks such as tests, code coverage, documentation, and performance analysis based on options provided. The script also checks requirements and local chain setup for the project."}
{"code": "\t\tlog::error \"Unknow parameter '$subcommand' !\"\n\t\tusage\n\t\texit 2\n\t;;\nesac\nmain\n", "explanation": "This is a snippet of Bash script code.\n\n**Summary:**\n\nHandles unknown subcommands by logging an error, displaying usage instructions, and exiting with a status code of 2.", "metadata": {"repo": "magiclabs/tezart", "file": "tool/tezart", "chunk_number": 7, "total_chunks": 7}, "repository_explanation": "", "file_summary": "Here's a concise summary:\n\nThe `tool/tezart` file is a Bash script that provides a command-line interface for managing a Dart project called TezarT. It defines utility functions for development, CI/CD operations, and runs various tasks such as tests, code coverage, documentation, and performance analysis based on options provided. The script also checks requirements and local chain setup for the project."}
