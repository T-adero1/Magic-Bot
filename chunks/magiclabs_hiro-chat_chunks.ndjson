{"code": "version = 1\n\n[[analyzers]]\nname = \"javascript\"\n\n  [analyzers.meta]\n  environment = [\"nodejs\"]\n\n[[analyzers]]\nname = \"secrets\"\nenabled = true\n", "explanation": "Here is a concise summary:\n\nThis block configures analyzers for a system, specifically for JavaScript environments with Node.js, and enables a \"secrets\" analyzer for version 1.", "metadata": {"repo": "magiclabs/hiro-chat", "file": ".deepsource.toml", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise holistic summary of the file '.deepsource.toml':\n\nConfigures DeepSource analyzers for a JavaScript project with Node.js, including secrets detection."}
{"code": "NEXT_PUBLIC_MAGIC_API_KEY=\"Your magic public api key\"\nMAGIC_SECRET_KEY=\"Your magic secret key\"\nTEE_URL=https://global-tee-prod.magickms.com\n\nKV_REST_API_READ_ONLY_TOKEN=\"Retrieved from vercel\"\nKV_REST_API_TOKEN=\"Retrieved from vercel\"\nKV_REST_API_URL=\"Retrieved from vercel\"\nKV_URL=\"Retrieved from vercel\"\n\nOPENAI_API_KEY=\"Your openai api key\"\nTOGETHER_AI_API_KEY=\"Your together api key\"\nFIREWORKS_API_KEY=\"Your fireworks api key\"\n\nETHERSCAN_API_KEY=\"Your etherscan api key\"\nPOLYGONSCAN_API_KEY=\"Your polygonscan api key\"\nALCHEMY_API_KEY=\"Your alchemy api key\"\n\nTEE_FUNDER_PUBLIC_ADDRESS=\"Public address for tee funder\"\nTEE_FUNDER_ENCRYPTION_CONTEXT=\"encryption context for tee funder\"\n\nNEXT_PUBLIC_ALLOW_CONTRACT_UPLOAD=1\n\n\n", "explanation": "This block appears to be a collection of environment variables, used to store sensitive information such as API keys, secret keys, and public addresses, in order to securely configure an application or service.", "metadata": {"repo": "magiclabs/hiro-chat", "file": ".env.example", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary:\n\nThe '.env.example' file stores environmental variables for secure configuration, including API keys, secret keys, and public addresses."}
{"code": "{\n  \"extends\": \"next/core-web-vitals\"\n}\n", "explanation": "This block extends the Next.js Web Vitals template, inheriting its core features.", "metadata": {"repo": "magiclabs/hiro-chat", "file": ".eslintrc.json", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and to-the-point summary:\n\n`.eslintrc.json` file extends the Next.js Web Vitals template, inheriting core features."}
{"code": "{}\n", "explanation": "This block appears to be an empty code block or a placeholder in a programming context, likely used for organizational or structural purposes rather than executing any specific function.", "metadata": {"repo": "magiclabs/hiro-chat", "file": ".prettierrc.json", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "It seems there is no actual text to summarize.\n\nHowever, if you meant to provide a description of a `.prettierrc.json` file, here's a concise summary:\n\n`.prettierrc.json`: A configuration file for Prettier, specifying code formatting rules and styles for a project."}
{"code": "{\n  \"typescript.tsdk\": \"node_modules/typescript/lib\"\n}", "explanation": "This block is a configuration object specifying the TypeScript SDK location as `node_modules/typescript/lib`.", "metadata": {"repo": "magiclabs/hiro-chat", "file": ".vscode/settings.json", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and to-the-point summary:\n\n\".vscode/settings.json\" configures the TypeScript SDK location to \"node_modules/typescript/lib\"."}
{"code": "# Magic AI Chat Demo\n\n## Prerequisites\n\nBefore you begin, ensure you have the following:\n\n- **Node.js**: Install the latest stable version of Node.js from [nodejs.org](https://nodejs.org/).\n- **Magic Account**: Sign up at [Magic](https://magic.link/) for authentication and wallet services. You'll need access to the beta API wallets feature, reach out [here](https://magic.link/contact) to get it enabled.\n- **OpenAI API Key**: Get an API key from [OpenAI](https://platform.openai.com/signup/).\n- **Alchemy Account**: Sign up for [Alchemy](https://www.alchemy.com/). It is used as an RPC service.\n- **Vercel Account**: Set up KV Storage on Vercel [Vercel](https://vercel.com/docs/storage/vercel-kv). You can also use it for deploying your project.\n- **Etherscan/PolygonScan Accounts**: Sign up on [Etherscan](https://etherscan.io/) and [PolygonScan](https://polygonscan.com/) if you want to use their APIs for contract verification.\n\n## Quickstart\n\n### 1. Clone the Repository\n\n```bash\ngit clone <repo-url>", "explanation": "Here is a concise summary of the block's purpose and functionality:\n\n**Summary:** A demo project that showcases AI chat capabilities using Magic, OpenAI, Alchemy, Vercel, Etherscan, and PolygonScan APIs.\n\n**Functionality:** Guides users through setting up required accounts and services to deploy a Magic AI Chat Demo.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "README.md", "chunk_number": 1, "total_chunks": 12}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'README.md':\n\n**Project:** A demo project showcasing AI chat capabilities using various APIs (Magic, OpenAI, Alchemy, Vercel) and blockchain technologies (Etherscan, PolygonScan).\n\n**Purpose:** Initialize a repository for deploying a Magic AI Chat Demo by setting up required accounts, services, and dependencies.\n\n**Key Features:**\n\n* Configuration instructions for running a development project\n* Digital wallet interface for executing transactions, managing funds, and querying blockchain functions\n* Integration of Large Language Models (LLMs) via Ollama, Together.ai, and Fireworks.ai\n* SuggestedMessageList component for customizable message options\n* Filtering available smart contract functions based on conversation context\n* Timestamp functionality using Lambda functions with LLMs\n\n**Project Setup:**\n\n* Set up Vercel account and configure environment variables and KV storage\n* Deploy Next.js project on Vercel with automatic build and deployment\n* Authorize domain names for the deployed project"}
{"code": "cd <repo-folder>\n```\n\n### 2. Install Dependencies\n\n```bash\nnpm install\n```\n\n### 3. Configure Environment Variables\n\nYou'll need to set up various API keys and configuration settings. Copy the `.env.example` file as `.env` and update it as necessary with the values from your various accounts.\n\n- **Magic API**: Create an app on [Magic](https://magic.link/) and copy your **public** and **secret** API keys. Make sure your Magic app has TEE (Trusted Execution Environment) enabled.\n- **OpenAI API**: Get your API key for [OpenAI](https://platform.openai.com/).\n- **Alchemy API**: Create an app on Alchemy and obtain your API key. Follow the [Alchemy documentation](https://docs.alchemy.com/alchemy/) for more details.\n- **Vercel KV Store**: Copy your [Vercel KV](https://vercel.com/docs/storage/vercel-kv) environment variables into your `.env`", "explanation": "**Purpose:** Initialize a repository by changing directories, installing dependencies, and configuring environment variables.\n\n**Functionality:**\n\n1. Navigate to a specified repository folder.\n2. Run `npm install` to install project dependencies.\n3. Configure API keys and settings for Magic, OpenAI, Alchemy, and Vercel KV Store through `.env` file updates.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "README.md", "chunk_number": 2, "total_chunks": 12}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'README.md':\n\n**Project:** A demo project showcasing AI chat capabilities using various APIs (Magic, OpenAI, Alchemy, Vercel) and blockchain technologies (Etherscan, PolygonScan).\n\n**Purpose:** Initialize a repository for deploying a Magic AI Chat Demo by setting up required accounts, services, and dependencies.\n\n**Key Features:**\n\n* Configuration instructions for running a development project\n* Digital wallet interface for executing transactions, managing funds, and querying blockchain functions\n* Integration of Large Language Models (LLMs) via Ollama, Together.ai, and Fireworks.ai\n* SuggestedMessageList component for customizable message options\n* Filtering available smart contract functions based on conversation context\n* Timestamp functionality using Lambda functions with LLMs\n\n**Project Setup:**\n\n* Set up Vercel account and configure environment variables and KV storage\n* Deploy Next.js project on Vercel with automatic build and deployment\n* Authorize domain names for the deployed project"}
{"code": "- **Etherscan/PolygonScan API**: Optionally, create accounts on [Etherscan](https://etherscan.io/register) or [PolygonScan](https://polygonscan.com/register) and add their respective API keys.\n\n### 4. Run the Project\n\nTo start the development server:\n\n```bash\nnpm run dev\n```\n\nThe app should now be running on `http://localhost:3000`.\n\n### 5. Set Up Your Magic TEE Wallet\n\n1. **Login to your Magic account** via the UI.\n2. **Set up a PIN** for your TEE wallet. This will be used for signing transactions securely.\n3. **Transfer funds** You'll need some tokens in your wallet to pay for gas fees. You can use a faucet like [Chainlink](https://faucets.chain.link/sepolia) if you need some testnet tokens.\n\n### 6. Upload a Contract\n\n- You can upload contracts using your Magic TEE wallet. For example, you can start by uploading a **Uniswap contract** on the Sepolia testnet.\n\n  Example Uniswap contract address on Sepolia:\n\n  ```\n  0xC532a74256D3Db42D0Bf7a0400fEFDbad7694008\n  ```\n\n### 7. Execute Queries\n", "explanation": "Here is a summary of the block in a concise format:\n\n**Block Purpose:** Configuration instructions for running a development project, including setting up APIs, wallets, and uploading contracts.\n\n**Key Functionality:**\n\n* Set up Etherscan/PolygonScan API keys (optional)\n* Run the project using `npm run dev`\n* Set up Magic TEE wallet with login, PIN setup, and token transfer\n* Upload a contract to the Sepolia testnet", "metadata": {"repo": "magiclabs/hiro-chat", "file": "README.md", "chunk_number": 3, "total_chunks": 12}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'README.md':\n\n**Project:** A demo project showcasing AI chat capabilities using various APIs (Magic, OpenAI, Alchemy, Vercel) and blockchain technologies (Etherscan, PolygonScan).\n\n**Purpose:** Initialize a repository for deploying a Magic AI Chat Demo by setting up required accounts, services, and dependencies.\n\n**Key Features:**\n\n* Configuration instructions for running a development project\n* Digital wallet interface for executing transactions, managing funds, and querying blockchain functions\n* Integration of Large Language Models (LLMs) via Ollama, Together.ai, and Fireworks.ai\n* SuggestedMessageList component for customizable message options\n* Filtering available smart contract functions based on conversation context\n* Timestamp functionality using Lambda functions with LLMs\n\n**Project Setup:**\n\n* Set up Vercel account and configure environment variables and KV storage\n* Deploy Next.js project on Vercel with automatic build and deployment\n* Authorize domain names for the deployed project"}
{"code": "- **Wallet Address**: Your TEE wallet address will be visible in the bottom-left corner of the interface. Click the address to copy it.\n- **Ask Queries**: Try asking questions like \"Can you swap ETH for USDC?\" in the app's interface.\n- **Execute Functions**: Refine your query to a specific function execution. Click \"Execute\" and enter your PIN to proceed.\n\n### 8. Check Transaction Status\n\nIf the execution is successful, you will receive a link to the transaction on the blockchain (e.g., Etherscan). If not, check the following:\n\n- Ensure you have a valid wallet PIN.\n- Verify that you have sufficient funds for gas fees.\n- Check if the contract is correctly uploaded and the address is valid.\n\n## Known Issues\n\n- **Inline Toolcalls**:\n- **Hallucinate Values**:\n  - LLaMA 3.1 is more likely to respond with tool calls earlier than OpenAI and can hallucinate arguments in tool calls. It can be nudged with more conversation.\n- **Ambiguous Tool Calls**:", "explanation": "Here's a concise summary:\n\n**Purpose:** A digital wallet interface for executing transactions, managing funds, and querying blockchain functions.\n\n**Functionality:**\n\n* Display wallet address\n* Execute transactions and queries (e.g., swapping tokens)\n* Check transaction status and troubleshoot issues (PIN, gas fees, contract validity)", "metadata": {"repo": "magiclabs/hiro-chat", "file": "README.md", "chunk_number": 4, "total_chunks": 12}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'README.md':\n\n**Project:** A demo project showcasing AI chat capabilities using various APIs (Magic, OpenAI, Alchemy, Vercel) and blockchain technologies (Etherscan, PolygonScan).\n\n**Purpose:** Initialize a repository for deploying a Magic AI Chat Demo by setting up required accounts, services, and dependencies.\n\n**Key Features:**\n\n* Configuration instructions for running a development project\n* Digital wallet interface for executing transactions, managing funds, and querying blockchain functions\n* Integration of Large Language Models (LLMs) via Ollama, Together.ai, and Fireworks.ai\n* SuggestedMessageList component for customizable message options\n* Filtering available smart contract functions based on conversation context\n* Timestamp functionality using Lambda functions with LLMs\n\n**Project Setup:**\n\n* Set up Vercel account and configure environment variables and KV storage\n* Deploy Next.js project on Vercel with automatic build and deployment\n* Authorize domain names for the deployed project"}
{"code": "  - Even with multi-agent filtering, it's possible to have too many or ambiguous tool calls based on the number of uploaded and enabled contracts.\n- **Contract Functions with ETH**:\n  - If you upload a contract with functions that require a non-zero amount of ETH in the transaction, you'll need to manually add those function descriptions after upload.\n- **Token Calculation Error**:\n  - You may encounter the error:\n    ```\n    Failed to calculate number of tokens, falling back to approximate count\n    Error: Unknown model\n    ```\n  - This occurs when using ChatTogetherAI and ChatFireworks with LangChain's OpenAI interface, which relies on `js-tiktoken`. This package only handles OpenAI model names [hardcoded in the source](https://github.com/langchain-ai/langchainjs/blob/747f324d20a5fe7f4a282b184d63919e8e95e00a/langchain-core/src/language_models/base.ts).\n\n## Repo structure\n\n- TODO\n\n## Customization\n\n#### This project supports LLM inference through Ollama, Together.ai, and Fireworks.ai.\n", "explanation": "Here is a concise summary:\n\nThis block discusses potential issues with contract management and token calculation errors in a specific system, and provides information on customization options for integrating Large Language Models (LLMs) via Ollama, Together.ai, and Fireworks.ai.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "README.md", "chunk_number": 5, "total_chunks": 12}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'README.md':\n\n**Project:** A demo project showcasing AI chat capabilities using various APIs (Magic, OpenAI, Alchemy, Vercel) and blockchain technologies (Etherscan, PolygonScan).\n\n**Purpose:** Initialize a repository for deploying a Magic AI Chat Demo by setting up required accounts, services, and dependencies.\n\n**Key Features:**\n\n* Configuration instructions for running a development project\n* Digital wallet interface for executing transactions, managing funds, and querying blockchain functions\n* Integration of Large Language Models (LLMs) via Ollama, Together.ai, and Fireworks.ai\n* SuggestedMessageList component for customizable message options\n* Filtering available smart contract functions based on conversation context\n* Timestamp functionality using Lambda functions with LLMs\n\n**Project Setup:**\n\n* Set up Vercel account and configure environment variables and KV storage\n* Deploy Next.js project on Vercel with automatic build and deployment\n* Authorize domain names for the deployed project"}
{"code": "- To add other LLMs, edit `MODELS` inside `constants/index.ts` and add the model to its respective inference provider.\n\n- **Ollama**: No special configuration is required. Ensure Ollama is installed and running locally, and add the model name to `constants/index.ts`.\n\n- **Together.ai**: Create an account at Together.ai, retrieve your API key from the [dashboard](https://api.together.ai/settings/api-keys), and add it to your `.env` as `{TOGETHER_AI_API_KEY}`.\n\n- **Fireworks.ai**: Sign up at Fireworks.ai, create an API key in the [dashboard](https://fireworks.ai/account/api-keys), and add it to your `.env` as `{FIREWORKS_API_KEY}`.\n\n#### Predefined chat messages\n", "explanation": "**Purpose:** Configure additional Large Language Models (LLMs) for integration with a project.\n\n**Functionality:**\n\n* Add models to `constants/index.ts`\n* Edit API keys in `.env` file:\n\t+ Ollama: No config required, add model name\n\t+ Together.ai: Add API key from dashboard\n\t+ Fireworks.ai: Add API key from dashboard", "metadata": {"repo": "magiclabs/hiro-chat", "file": "README.md", "chunk_number": 6, "total_chunks": 12}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'README.md':\n\n**Project:** A demo project showcasing AI chat capabilities using various APIs (Magic, OpenAI, Alchemy, Vercel) and blockchain technologies (Etherscan, PolygonScan).\n\n**Purpose:** Initialize a repository for deploying a Magic AI Chat Demo by setting up required accounts, services, and dependencies.\n\n**Key Features:**\n\n* Configuration instructions for running a development project\n* Digital wallet interface for executing transactions, managing funds, and querying blockchain functions\n* Integration of Large Language Models (LLMs) via Ollama, Together.ai, and Fireworks.ai\n* SuggestedMessageList component for customizable message options\n* Filtering available smart contract functions based on conversation context\n* Timestamp functionality using Lambda functions with LLMs\n\n**Project Setup:**\n\n* Set up Vercel account and configure environment variables and KV storage\n* Deploy Next.js project on Vercel with automatic build and deployment\n* Authorize domain names for the deployed project"}
{"code": "- The SuggestedMessageList component allows you to add an array of suggested messages, to quickly provide predefined options for user interaction. These messages can be tailored to specific use cases, such as contract functions or common queries. If you need different default options, simply modify the buttonMessages array in the component.\n- Alternatively, the predefined options can be dynamically generated based on the application's context, such as user inputs or available smart contracts, making the component adaptable to various scenarios by passing the array of suggested Message to the component via its props.\n\n#### Walk through how to edit contracts, how context works, how modifying function/ function input descriptions works\n\n#### Walk through how to disable/enable contracts locally\n\n## Prompt Control Flow\n\n### Multi Agent functionality\n", "explanation": "Here is a concise summary:\n\n**Purpose:** The SuggestedMessageList component provides pre-defined message options for user interaction, adaptable to specific use cases.\n\n**Functionality:** It allows customization of default options through an array (buttonMessages) or dynamically generates options based on application context (e.g., user inputs, smart contracts).", "metadata": {"repo": "magiclabs/hiro-chat", "file": "README.md", "chunk_number": 7, "total_chunks": 12}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'README.md':\n\n**Project:** A demo project showcasing AI chat capabilities using various APIs (Magic, OpenAI, Alchemy, Vercel) and blockchain technologies (Etherscan, PolygonScan).\n\n**Purpose:** Initialize a repository for deploying a Magic AI Chat Demo by setting up required accounts, services, and dependencies.\n\n**Key Features:**\n\n* Configuration instructions for running a development project\n* Digital wallet interface for executing transactions, managing funds, and querying blockchain functions\n* Integration of Large Language Models (LLMs) via Ollama, Together.ai, and Fireworks.ai\n* SuggestedMessageList component for customizable message options\n* Filtering available smart contract functions based on conversation context\n* Timestamp functionality using Lambda functions with LLMs\n\n**Project Setup:**\n\n* Set up Vercel account and configure environment variables and KV storage\n* Deploy Next.js project on Vercel with automatic build and deployment\n* Authorize domain names for the deployed project"}
{"code": "Given the limitation on the number of tools that can be bound to LLMs for an invocation (refer to your LLM for specific limits), the app includes a filtering mechanism that narrows down available smart contract functions based on conversation context.\n\n#### How It Works:\n\n1. **Conversation Context**:  \n   As the user interact with the chat, their inputs are analyzed to understand their intent and the type of smart contract interactions they require (e.g., token transfers, swaps, etc.) if any.\n\n2. **Initial Prompt Filtering**:  \n   The app calls a \"reasoning prompt\". The LLM will understand the intent of the chat with the function sigantures as part of its plain text prompt. This LLM invocation will return a structured response that is used filter the list of available smart contract functions. This filter is based on the context of the user\u2019s ongoing conversation, ensuring that only relevant tools (contract functions) are returned.\n\n3. **Reducing Tool Calls**:  ", "explanation": "Here is a concise summary:\n\n**Purpose:** Filters available smart contract functions based on conversation context to reduce tool calls.\n\n**Functionality:**\n\n* Analyzes user input to understand intent and required interactions.\n* Uses LLM to reason and filter contract functions based on conversation context.\n* Returns only relevant tools for the current conversation.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "README.md", "chunk_number": 8, "total_chunks": 12}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'README.md':\n\n**Project:** A demo project showcasing AI chat capabilities using various APIs (Magic, OpenAI, Alchemy, Vercel) and blockchain technologies (Etherscan, PolygonScan).\n\n**Purpose:** Initialize a repository for deploying a Magic AI Chat Demo by setting up required accounts, services, and dependencies.\n\n**Key Features:**\n\n* Configuration instructions for running a development project\n* Digital wallet interface for executing transactions, managing funds, and querying blockchain functions\n* Integration of Large Language Models (LLMs) via Ollama, Together.ai, and Fireworks.ai\n* SuggestedMessageList component for customizable message options\n* Filtering available smart contract functions based on conversation context\n* Timestamp functionality using Lambda functions with LLMs\n\n**Project Setup:**\n\n* Set up Vercel account and configure environment variables and KV storage\n* Deploy Next.js project on Vercel with automatic build and deployment\n* Authorize domain names for the deployed project"}
{"code": "    By filtering the available tools, the LLM is more focused on the appropriate smart contract interactions, minimizing the risk of errors or hallucinations. This ensures that the LLM can efficiently respond to the user's requests within the limits of its tool-calling capabilities.\n   ![Multi Agent Diagram](assets/multiagent%20layout.png \"Multi Agent Diagram\")\n\n#### Lambda timestamp functionality\n\nLangChain\u2019s architecture enables flexible integration between language models (LLMs), prompts, and external tools, making it well-suited for dynamic workflows like generating timestamps. In scenarios where smart contract functions require precise timestamps, LLMs can struggle to produce accurate results on their own.\n\nThe **timestamp lambda** approach provides a reliable solution by handling the natural language input through the following process:\n\n1. **User Input & Reasoning**: The LLM receives natural language input (e.g., \"5 hours from now\") and reasons about the relative time.", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Ensure accurate smart contract interactions by filtering tools and providing timestamp functionality.\n\n**Functionality:** Use Lambda functions with LLMs to reason about timestamps, ensuring precise timing for smart contracts despite potential inaccuracies in natural language inputs.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "README.md", "chunk_number": 9, "total_chunks": 12}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'README.md':\n\n**Project:** A demo project showcasing AI chat capabilities using various APIs (Magic, OpenAI, Alchemy, Vercel) and blockchain technologies (Etherscan, PolygonScan).\n\n**Purpose:** Initialize a repository for deploying a Magic AI Chat Demo by setting up required accounts, services, and dependencies.\n\n**Key Features:**\n\n* Configuration instructions for running a development project\n* Digital wallet interface for executing transactions, managing funds, and querying blockchain functions\n* Integration of Large Language Models (LLMs) via Ollama, Together.ai, and Fireworks.ai\n* SuggestedMessageList component for customizable message options\n* Filtering available smart contract functions based on conversation context\n* Timestamp functionality using Lambda functions with LLMs\n\n**Project Setup:**\n\n* Set up Vercel account and configure environment variables and KV storage\n* Deploy Next.js project on Vercel with automatic build and deployment\n* Authorize domain names for the deployed project"}
{"code": "2. **Tool Call**: Instead of guessing the timestamp, the LLM generates a tool call that contains the time difference in seconds.\n3. **Timestamp Tool**: The invoked tool calculates the exact Unix timestamp based on the provided seconds.\n4. **Injecting Result**: This timestamp is injected back into the LLM's reasoning process to complete the prompt or interaction.\n\n![Timestamp Lambda Diagram](assets/timestampLambda.png \"Timestamp Lmabda Diagram\")\n\n## Deployment\n\nYou can deploy your this project to Vercel\n\n### Prerequisites\n\n1. A [GitHub](https://github.com/), [GitLab](https://gitlab.com/), or [Bitbucket](https://bitbucket.org/) account.\n2. A [Vercel account](https://vercel.com/signup) (can sign up with your GitHub, GitLab, or Bitbucket account).\n\n### 2. Deploy to Vercel\n\n#### 2.1. Sign in to Vercel\n\n1. Go to [Vercel](https://vercel.com) and sign in using your GitHub, GitLab, or Bitbucket account. Or connect your VSC to an existing account\n2. Click **Add New Project**.\n\n#### 2.2. Import Your Repository\n", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\nThis block describes a process for generating a Unix timestamp using a Large Language Model (LLM) and a tool call, allowing for more accurate time-based calculations in interactions or prompts.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "README.md", "chunk_number": 10, "total_chunks": 12}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'README.md':\n\n**Project:** A demo project showcasing AI chat capabilities using various APIs (Magic, OpenAI, Alchemy, Vercel) and blockchain technologies (Etherscan, PolygonScan).\n\n**Purpose:** Initialize a repository for deploying a Magic AI Chat Demo by setting up required accounts, services, and dependencies.\n\n**Key Features:**\n\n* Configuration instructions for running a development project\n* Digital wallet interface for executing transactions, managing funds, and querying blockchain functions\n* Integration of Large Language Models (LLMs) via Ollama, Together.ai, and Fireworks.ai\n* SuggestedMessageList component for customizable message options\n* Filtering available smart contract functions based on conversation context\n* Timestamp functionality using Lambda functions with LLMs\n\n**Project Setup:**\n\n* Set up Vercel account and configure environment variables and KV storage\n* Deploy Next.js project on Vercel with automatic build and deployment\n* Authorize domain names for the deployed project"}
{"code": "1. Select your Git provider (GitHub, GitLab, or Bitbucket).\n2. Vercel will show a list of your repositories. You may need to authorize vercel app on github to have access to the repository.\n3. Find and select the repository containing your Next.js project.\n\n#### 2.3. Configure the Project\n\n1. Set up **Environment Variables** inside your Vercel dashboard\n2. Create/Connect Vercel KV to your project more information can be found [here](https://vercel.com/docs/storage/vercel-kv/quickstart#create-a-kv-database).\n3. Once you're done, click **Deploy**.\n\n### 3. Vercel Builds and Deploys Your Project\n\nVercel will build and deploy your project automatically. You can follow the logs during the build process.\n\n### 4. Authorize Domain name on magic dashboard\n\nAfter deployment add the set domain name for the deployed project to your Magic App in the [dashboard](https://dashboard.magic.link/app/settings)\n\n## Dependencies\n\n### Important Libraries\n\nRefer to documentation for the follow libraries for additional functionality\n", "explanation": "Here is a concise summary:\n\nThis block guides users through setting up their Next.js project on Vercel, including:\n\n* Connecting their Git provider (GitHub, GitLab, or Bitbucket)\n* Configuring environment variables and Vercel KV storage\n* Deploying the project with automatic build and deployment\n* Authorizing domain names for the deployed project.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "README.md", "chunk_number": 11, "total_chunks": 12}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'README.md':\n\n**Project:** A demo project showcasing AI chat capabilities using various APIs (Magic, OpenAI, Alchemy, Vercel) and blockchain technologies (Etherscan, PolygonScan).\n\n**Purpose:** Initialize a repository for deploying a Magic AI Chat Demo by setting up required accounts, services, and dependencies.\n\n**Key Features:**\n\n* Configuration instructions for running a development project\n* Digital wallet interface for executing transactions, managing funds, and querying blockchain functions\n* Integration of Large Language Models (LLMs) via Ollama, Together.ai, and Fireworks.ai\n* SuggestedMessageList component for customizable message options\n* Filtering available smart contract functions based on conversation context\n* Timestamp functionality using Lambda functions with LLMs\n\n**Project Setup:**\n\n* Set up Vercel account and configure environment variables and KV storage\n* Deploy Next.js project on Vercel with automatic build and deployment\n* Authorize domain names for the deployed project"}
{"code": "- [Vercel/ai](https://sdk.vercel.ai/)\n- [Langchain JS](https://js.langchain.com/docs/introduction/)\n- [Shadcn/UI](https://ui.shadcn.com/docs/components)\n- [Magic SDK](https://magic.link/docs/api/client-side-sdks/web)\n- [Ethers](https://docs.ethers.org/v6/)\n", "explanation": "Here is a concise summary of each block:\n\n1. **Vercel/ai**: A platform for building, deploying, and managing AI models.\n2. **Langchain JS**: An open-source JavaScript library for building conversational AI applications.\n3. **Shadcn/UI**: A UI component library for React development.\n4. **Magic SDK**: A client-side API for building web applications with authentication, authorization, and other features.\n5. **Ethers**: A JavaScript library for interacting with the Ethereum blockchain.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "README.md", "chunk_number": 12, "total_chunks": 12}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'README.md':\n\n**Project:** A demo project showcasing AI chat capabilities using various APIs (Magic, OpenAI, Alchemy, Vercel) and blockchain technologies (Etherscan, PolygonScan).\n\n**Purpose:** Initialize a repository for deploying a Magic AI Chat Demo by setting up required accounts, services, and dependencies.\n\n**Key Features:**\n\n* Configuration instructions for running a development project\n* Digital wallet interface for executing transactions, managing funds, and querying blockchain functions\n* Integration of Large Language Models (LLMs) via Ollama, Together.ai, and Fireworks.ai\n* SuggestedMessageList component for customizable message options\n* Filtering available smart contract functions based on conversation context\n* Timestamp functionality using Lambda functions with LLMs\n\n**Project Setup:**\n\n* Set up Vercel account and configure environment variables and KV storage\n* Deploy Next.js project on Vercel with automatic build and deployment\n* Authorize domain names for the deployed project"}
{"code": "import { NextRequest, NextResponse } from \"next/server\";\nimport { getToolsFromContracts } from \"@/utils/llm/generateToolFromABI\";\nimport { CustomParser } from \"@/utils/llm/CustomParser\";\nimport { contractCollection } from \"@/utils/kv/collections\";\nimport { reasoningPrompt } from \"@/utils/llm/reasoningPrompt\";\nimport { getStructuredPrompt } from \"@/utils/llm/structuredPrompt\";\nimport { getTimestampLambda } from \"@/utils/llm/timestampLambda\";\nimport { RunnableSequence } from \"@langchain/core/runnables\";\nimport { MODELS } from \"@/constants\";\nimport { getModel } from \"@/utils/llm/getModel\";\n\nexport const runtime = \"nodejs\";\nexport const maxDuration = 300;\n\nexport async function POST(req: NextRequest) {\n  try {\n    const body = await req.json();\n    const messages = body.messages ?? [];\n    const modelName = body.modelName ?? MODELS[\"openai\"][0];\n    const contracts = (await contractCollection.get()).filter(\n      (c) => !(body.disabledContractKeys ?? []).includes(c.key),\n    );", "explanation": "**Summary**\n\nThis code block handles an incoming POST request, extracting user input and data from a Next.js server. It appears to be a custom API endpoint that interacts with blockchain contracts, utilizes LLM (Large Language Model) tools, and executes a RunnableSequence based on the provided inputs. The purpose is to generate structured prompts for AI reasoning tasks.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/api/chat/route.ts", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary:\n\n**app/api/chat/route.ts**: This file handles incoming POST requests, utilizing LLM tools and blockchain contracts to generate structured prompts for AI reasoning tasks. It retrieves relevant data, uses machine learning models, and filters contracts based on user input, ultimately returning a response through a sequence of operations."}
{"code": "    const previousMessages = messages.slice(0, -1);\n    const currentMessageContent = messages[messages.length - 1].content;\n    const contractAddresses = contracts.map(({ address }) => address);\n\n    const prompt = getStructuredPrompt(previousMessages);\n\n    try {\n      // Reasoning prompt takes the contracts and chat history to asks the llm to reduce the # of abi functions\n      // It returns an object of the contract and abis most appropriate to the chat history\n      const reasoningPromptResponse = await reasoningPrompt({\n        modelName: modelName,\n        contracts,\n        input: currentMessageContent,\n        chatHistory: previousMessages,\n      });\n\n      const reducedContractAddresses = reasoningPromptResponse.map(\n        ({ address }) => address,\n      );\n\n      const filteredContracts = contracts\n        .filter((contract) =>\n          reducedContractAddresses.includes(contract.address),\n        )\n        .map(({ abi, ...contract }) => {", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Filter contracts based on a reasoning prompt's response.\n\n**Functionality:**\n\n1. Get chat history and current message content.\n2. Generate a structured prompt from chat history.\n3. Run a reasoning prompt to reduce contract ABIs based on chat history and current message.\n4. Filter contracts that are still relevant according to the reduced ABIs.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/api/chat/route.ts", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary:\n\n**app/api/chat/route.ts**: This file handles incoming POST requests, utilizing LLM tools and blockchain contracts to generate structured prompts for AI reasoning tasks. It retrieves relevant data, uses machine learning models, and filters contracts based on user input, ultimately returning a response through a sequence of operations."}
{"code": "          const matchingReducedContract = reasoningPromptResponse.find(\n            (res) => res.address === contract.address,\n          );\n\n          return {\n            ...contract,\n            abi: matchingReducedContract?.abi ?? [],\n          };\n        });\n\n      const tools = getToolsFromContracts(filteredContracts);\n      const model = getModel(modelName);\n      const modelWithTool = model.bindTools(tools);\n\n      const stream = await RunnableSequence.from([\n        getTimestampLambda(modelName),\n        prompt,\n        modelWithTool,\n        new CustomParser(),\n      ]).stream({\n        contractAddresses: contractAddresses,\n        input: currentMessageContent,\n      });\n\n      return new Response(stream);\n    } catch (error) {\n      console.error(\"Error:\", error);\n      throw error;\n    }\n  } catch (e: any) {\n    return NextResponse.json({ error: e.message }, { status: e.status ?? 500 });\n  }\n}\n", "explanation": "Here is a concise summary:\n\n**Functionality:** This block processes a contract and returns a response based on user input.\n\n**Purpose:** It retrieves relevant data, uses machine learning models, and generates a response through a sequence of operations. \n\n**Key Functions:**\n\n* Retrieves contracts with matching addresses\n* Binds tools to a model\n* Streams a series of functions (timestamp, prompt, model, parser) using the `RunnableSequence` class", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/api/chat/route.ts", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary:\n\n**app/api/chat/route.ts**: This file handles incoming POST requests, utilizing LLM tools and blockchain contracts to generate structured prompts for AI reasoning tasks. It retrieves relevant data, uses machine learning models, and filters contracts based on user input, ultimately returning a response through a sequence of operations."}
{"code": "import { contractCollection } from \"@/utils/kv/collections\";\nimport { getAbi } from \"@/utils/abi\";\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { getContractABIDescriptions } from \"@/utils/llm/generateToolFromABI\";\nimport { AbiFunction } from \"abitype\";\n\nconst CONTRACT_UPLOAD_DISABLED =\n  process.env.NEXT_PUBLIC_ALLOW_CONTRACT_UPLOAD !== \"1\";\n\nexport const runtime = \"nodejs\";\n\nexport async function GET() {\n  try {\n    const contracts = await contractCollection.get();\n\n    return NextResponse.json({ contracts }, { status: 200 });\n  } catch (e: any) {\n    console.log(e);\n    return NextResponse.json({ error: e.message }, { status: e.status ?? 500 });\n  }\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    const body = await req.json();\n    const existingContracts = await contractCollection.get();\n\n    if (CONTRACT_UPLOAD_DISABLED) {\n      throw new Error(\"Contract upload has been disabled\");\n    }\n\n    if (\n      existingContracts.some(", "explanation": "Here is a concise summary:\n\n**Purpose:** API endpoint to handle GET and POST requests for interacting with a contract collection.\n\n**Functionality:**\n\n* **GET:** Returns a list of contracts in JSON format.\n* **POST:** Handles contract upload, checks if uploading is enabled, and prevents duplicates. If an error occurs, returns the error message as JSON.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/api/contracts/route.ts", "chunk_number": 1, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and holistic summary of the file 'app/api/contracts/route.ts':\n\n**Purpose:** Handle API requests for interacting with contract collections.\n\n**Functionality:**\n\n* GET: Returns all contracts in JSON format.\n* POST: Uploads, validates, and adds new contracts to the collection, preventing duplicates and errors.\n* PATCH & DELETE:\n\t+ Update existing contracts with new data or delete a specific contract from the collection.\n\t+ Validate requests and return updated contracts or error messages on failure."}
{"code": "        (c) => c.address === body.address && c.chainId === body.chainId,\n      )\n    ) {\n      throw new Error(\"Contract has already been uploaded\");\n    }\n\n    if (!isValidEthereumAddress(body.address)) {\n      throw new Error(\"Contract address is not valid\");\n    }\n\n    let abi: AbiFunction[] = [];\n    try {\n      if (body.abi) {\n        abi = await JSON.parse(body.abi);\n      } else {\n        abi = await getAbi(body.address, body.chainId);\n      }\n    } catch (e) {\n      throw new Error(\"Contract ABI is not valid\");\n    }\n\n    const abiDescriptions = getContractABIDescriptions(\n      { key: -1, ...body },\n      abi,\n    );\n    await contractCollection.add({\n      address: body.address,\n      name: body.name,\n      description: body.description,\n      context: \"\",\n      chainId: body.chainId,\n      abi,\n      abiDescriptions,\n    });\n\n    const contracts = await contractCollection.get();\n\n    return NextResponse.json({ contracts }, { status: 200 });\n  } catch (e: any) {\n    console.log(e);", "explanation": "Here is a concise summary:\n\n**Purpose:** Validate and add a new Ethereum contract to a collection.\n\n**Functionality:** \n\n1. Check if a contract with the same address and chain ID already exists.\n2. Validate the contract's Ethereum address.\n3. Parse or retrieve the contract's ABI (Application Binary Interface).\n4. Get descriptions for the parsed ABI functions.\n5. Add the validated contract data to the collection.\n6. Return a JSON response with the updated contracts list.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/api/contracts/route.ts", "chunk_number": 2, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and holistic summary of the file 'app/api/contracts/route.ts':\n\n**Purpose:** Handle API requests for interacting with contract collections.\n\n**Functionality:**\n\n* GET: Returns all contracts in JSON format.\n* POST: Uploads, validates, and adds new contracts to the collection, preventing duplicates and errors.\n* PATCH & DELETE:\n\t+ Update existing contracts with new data or delete a specific contract from the collection.\n\t+ Validate requests and return updated contracts or error messages on failure."}
{"code": "    return NextResponse.json({ error: e.message }, { status: e.status ?? 500 });\n  }\n}\n\nexport async function PATCH(req: NextRequest) {\n  try {\n    const body = await req.json();\n    const existingContracts = await contractCollection.get();\n\n    if (CONTRACT_UPLOAD_DISABLED) {\n      throw new Error(\"Contract upload has been disabled\");\n    }\n\n    if (!existingContracts.some((c) => c.key === body.key)) {\n      throw new Error(\"Contract doesnt exist\");\n    }\n\n    await contractCollection.update({\n      key: body.key,\n      name: body.name,\n      description: body.description,\n      context: body.context,\n      abiDescriptions: body.abiDescriptions,\n    });\n\n    const contracts = await contractCollection.get();\n\n    return NextResponse.json({ contracts }, { status: 200 });\n  } catch (e: any) {\n    console.log(e);\n    return NextResponse.json({ error: e.message }, { status: e.status ?? 500 });\n  }\n}\n\nexport async function DELETE(req: NextRequest) {\n  try {\n    if (CONTRACT_UPLOAD_DISABLED) {", "explanation": "Here is a summary of the purpose and functionality:\n\n**Purpose:** Handle PATCH and DELETE requests for contract updates.\n\n**Functionality:** \n\n* For PATCH requests:\n\t+ Validate request body and existing contracts\n\t+ Update contract collection with new data if valid\n\t+ Return updated contracts on success or error message on failure\n* For DELETE requests:\n\t+ Check if contract upload is disabled (if so, throw an error)\n\t+ Delete the contract from the collection if valid\n\t+ Return a response on success or error message on failure", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/api/contracts/route.ts", "chunk_number": 3, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and holistic summary of the file 'app/api/contracts/route.ts':\n\n**Purpose:** Handle API requests for interacting with contract collections.\n\n**Functionality:**\n\n* GET: Returns all contracts in JSON format.\n* POST: Uploads, validates, and adds new contracts to the collection, preventing duplicates and errors.\n* PATCH & DELETE:\n\t+ Update existing contracts with new data or delete a specific contract from the collection.\n\t+ Validate requests and return updated contracts or error messages on failure."}
{"code": "      throw new Error(\"Contract upload has been disabled\");\n    }\n\n    const body = await req.json();\n    await contractCollection.delete(body.key);\n    const contracts = await contractCollection.get();\n\n    return NextResponse.json({ contracts }, { status: 200 });\n  } catch (e: any) {\n    console.log(e);\n    return NextResponse.json({ error: e.message }, { status: e.status ?? 500 });\n  }\n}\n\nfunction isValidEthereumAddress(address: string) {\n  if (\n    typeof address !== \"string\" ||\n    address.length !== 42 ||\n    !address.startsWith(\"0x\")\n  ) {\n    return false;\n  }\n\n  const hexPattern = /^0x[0-9a-fA-F]{40}$/;\n  return hexPattern.test(address);\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Deletes a contract from a database and returns an updated list of contracts.\n\n**Functionality:** \n\n* Throws an error if contract upload is disabled.\n* Retrieves JSON body from request, deletes the corresponding contract, and retrieves the updated contract list.\n* Returns the updated contract list in JSON format with a 200 status code on success or a custom error message with a 500 status code on failure.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/api/contracts/route.ts", "chunk_number": 4, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and holistic summary of the file 'app/api/contracts/route.ts':\n\n**Purpose:** Handle API requests for interacting with contract collections.\n\n**Functionality:**\n\n* GET: Returns all contracts in JSON format.\n* POST: Uploads, validates, and adds new contracts to the collection, preventing duplicates and errors.\n* PATCH & DELETE:\n\t+ Update existing contracts with new data or delete a specific contract from the collection.\n\t+ Validate requests and return updated contracts or error messages on failure."}
{"code": "import { NextRequest, NextResponse } from \"next/server\";\nimport { getToolsFromContracts } from \"@/utils/llm/generateToolFromABI\";\nimport { routeBodySchema } from \"./schemas\";\nimport { contractCollection } from \"@/utils/kv/collections\";\nimport { hashPin } from \"@/utils/tee\";\n\nexport const runtime = \"nodejs\";\nexport const maxDuration = 300;\n\n/**\n * Error responds with json: { error: \"message of the error\"}\n * Success responds with stringified json: { status: \"string of the tx status\", message: \"String of what happened\", payload: Object with metadata about the tx }\n */\nexport async function POST(req: NextRequest) {\n  try {\n    const body = await req.json();\n    const result = routeBodySchema.safeParse(body);\n\n    if (!result.success) {\n      const errorMessages = result.error.issues\n        .map((issue) => issue.message)\n        .join(\" \");\n      return NextResponse.json({ error: errorMessages }, { status: 400 });\n    }\n\n    const { toolCall, didToken, pin } = result.data;\n", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Handles POST requests for generating tools from contracts.\n\n**Functionality:** Validates request body using a schema, retrieves necessary data, and returns a response (error or success with metadata) after executing an unknown operation (`toolCall` in `getToolsFromContracts`).", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/api/execute/route.ts", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'app/api/execute/route.ts':\n\nHandles POST requests for generating tools from contracts, validating inputs, executing unknown operations, and returning responses (success or error) based on execution outcomes."}
{"code": "    const encryptionContext = await hashPin(pin);\n\n    // parse contractAddress from toolCall.name;  Should be in format `${contractKey}_${functionName}_${overload function index}``\n    const contractKey = parseInt(toolCall.name.split(\"_\").at(0) as string, 10);\n    const contracts = (await contractCollection.get()).filter(\n      (c) => !(body.disabledContractKeys ?? []).includes(c.key),\n    );\n    const contract = contracts.find(({ key }) => contractKey === key);\n\n    if (!contract) {\n      return NextResponse.json(\n        {\n          error: `Unable to find reference ${contractKey}`,\n        },\n        { status: 400 },\n      );\n    }\n\n    try {\n      const tool = getToolsFromContracts(\n        [contract],\n        didToken,\n        encryptionContext,\n      ).find((t) => t.name === toolCall.name);\n\n      if (!tool) {\n        return NextResponse.json(\n          {\n            error: `Function ${toolCall.name} not found in ${contract.address}`,\n          },\n          { status: 404 },\n        );\n      }\n\n      try {", "explanation": "**Summary**\n\nThis block retrieves a contract from a collection, checks if it exists, and then uses it to find a specific tool function call by name. If the contract or function is not found, it returns an error response with a corresponding status code (400 or 404).", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/api/execute/route.ts", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'app/api/execute/route.ts':\n\nHandles POST requests for generating tools from contracts, validating inputs, executing unknown operations, and returning responses (success or error) based on execution outcomes."}
{"code": "        // Reply should be stringified { message: string, status: string, payload: record<string, any>}\n        const reply = await tool.func(toolCall.args);\n        console.log(reply);\n        // tool.func will not throw an error because it should always return a string. Ergo this will always return 200\n        return new Response(reply, { status: 200 });\n      } catch (error) {\n        console.error(error);\n        return NextResponse.json(\n          {\n            error: \"An unknown Error occured\",\n          },\n          { status: 500 },\n        );\n      }\n    } catch (error) {\n      console.error(\"Error:\", error);\n      throw error;\n    }\n  } catch (e: any) {\n    return NextResponse.json({ error: e.message }, { status: e.status ?? 500 });\n  }\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Return a response with a success status code (200) based on tool.func output, or an error message with a failure status code (500) if an exception occurs.\n\n**Functionality:** Executes tool.func, logs its result, and returns it as a Response object. If an error occurs, returns an error message as a JSON response with a 500 status code.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/api/execute/route.ts", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'app/api/execute/route.ts':\n\nHandles POST requests for generating tools from contracts, validating inputs, executing unknown operations, and returning responses (success or error) based on execution outcomes."}
{"code": "import { z } from \"zod\";\n\nconst toolCallSchema = z.object({\n  name: z.string({\n    required_error: \"toolCall.name is required\",\n    invalid_type_error: \"toolCall.name must be a string\",\n  }),\n  args: z.record(z.unknown()).optional(),\n});\nexport const routeBodySchema = z.object({\n  toolCall: toolCallSchema.refine((data) => data.name.trim().length > 0, {\n    message: \"toolCall.name cannot be an empty string\",\n  }),\n  didToken: z\n    .string({\n      required_error: \"didToken is required\",\n      invalid_type_error: \"didToken must be a string\",\n    })\n    .min(1, \"didToken cannot be an empty string\"),\n  pin: z\n    .string({\n      required_error: \"pin is required\",\n      invalid_type_error: \"pin must be a string\",\n    })\n    .min(1, \"pin cannot be an empty string\"),\n});\n", "explanation": "Here is a summary of the purpose and functionality of this block:\n\n**Purpose:** Define data validation schemas for API requests.\n\n**Functionality:** Validate JSON payloads against custom schema rules, ensuring required fields are present and have correct types (strings).", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/api/execute/schemas.ts", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise holistic summary of the file 'app/api/execute/schemas.ts':\n\n**Defines and validates data schemas for API requests**: Ensures JSON payloads conform to custom rules, requiring necessary fields with correct string types."}
{"code": "import { getWalletUUIDandAccessKey } from \"@/utils/tee\";\nimport { Magic } from \"@magic-sdk/admin\";\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { hashPin } from \"@/utils/tee\";\n\nexport const runtime = \"nodejs\";\nconst magic = await Magic.init(process.env.MAGIC_SECRET_KEY);\nexport const maxDuration = 300;\n\nexport async function GET(req: NextRequest) {\n  try {\n    const didToken = req.nextUrl.searchParams.get(\"didToken\") ?? \"\";\n    const pin = req.nextUrl.searchParams.get(\"pin\");\n\n    if (!didToken) throw new Error(\"TOKEN missing\");\n\n    const userMetadata = await magic.users.getMetadataByToken(didToken);\n    const publicAddress = userMetadata.publicAddress ?? \"\";\n    const encryptionContext = pin ? await hashPin(pin) : undefined;\n\n    try {\n      const result = await getWalletUUIDandAccessKey(\n        publicAddress,\n        encryptionContext,\n      );\n      return NextResponse.json({ wallet_address: result.wallet_address });\n    } catch (e) {\n      return NextResponse.json(", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Authenticate a user using Magic's DID Token and retrieve their wallet information.\n\n**Functionality:** It initializes Magic's admin SDK, extracts user metadata from a provided DID token, and uses it to fetch the user's wallet UUID and access key.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/api/wallet/route.ts", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and holistic summary of the file 'app/api/wallet/route.ts':\n\n**Summary:** Authenticates users using Magic's DID Token and retrieves their wallet information, handling errors with response codes 400 or 500 as needed."}
{"code": "        { error: \"Wallet does not exist and no PIN was provided\" },\n        { status: 400 },\n      );\n    }\n  } catch (e: any) {\n    return NextResponse.json({ error: e.message }, { status: e.status ?? 500 });\n  }\n}\n", "explanation": "This block:\n\n* Handles errors in a function\n* Returns an error response (JSON object with \"error\" key) with a 400 or 500 status code, depending on the error type.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/api/wallet/route.ts", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and holistic summary of the file 'app/api/wallet/route.ts':\n\n**Summary:** Authenticates users using Magic's DID Token and retrieves their wallet information, handling errors with response codes 400 or 500 as needed."}
{"code": "@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer base {\n  :root {\n    --background: 0 0% 100%;\n    --foreground: 240 10% 3.9%;\n    --card: 0 0% 100%;\n    --card-foreground: 240 10% 3.9%;\n    --popover: 0 0% 100%;\n    --popover-foreground: 240 10% 3.9%;\n    --primary: 240 5.9% 10%;\n    --primary-foreground: 0 0% 98%;\n    --secondary: 240 4.8% 95.9%;\n    --secondary-foreground: 240 5.9% 10%;\n    --muted: 240 4.8% 95.9%;\n    --muted-foreground: 240 3.8% 46.1%;\n    --accent: 240 4.8% 95.9%;\n    --accent-foreground: 240 5.9% 10%;\n    --destructive: 0 84.2% 60.2%;\n    --destructive-foreground: 0 0% 98%;\n    --border: 240 5.9% 90%;\n    --input: 240 5.9% 90%;\n    --ring: 240 10% 3.9%;\n    --radius: 0.5rem;\n    --chart-1: 12 76% 61%;\n    --chart-2: 173 58% 39%;\n    --chart-3: 197 37% 24%;\n    --chart-4: 43 74% 66%;\n    --chart-5: 27 87% 67%;\n  }\n\n  .dark {\n    --background: 240 10% 3.9%;\n    --foreground: 0 0% 98%;\n    --card: 240 10% 3.9%;\n    --card-foreground: 0 0% 98%;\n    --popover: 240 10% 3.9%;", "explanation": "**Summary**\n\nThis block is a configuration file for a Tailwind CSS setup, which is a utility-first CSS framework. It defines custom color variables and their values in different modes (e.g., light and dark). The `@layer base` directive specifies that these definitions should be applied at the base layer of the stylesheet.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/globals.css", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary:\n\n**app/globals.css**\n\nConfigures Tailwind CSS with custom color variables for light and dark modes, defining a set of global styles for backgrounds, text, borders, and more."}
{"code": "    --popover-foreground: 0 0% 98%;\n    --primary: 0 0% 98%;\n    --primary-foreground: 240 5.9% 10%;\n    --secondary: 240 3.7% 15.9%;\n    --secondary-foreground: 0 0% 98%;\n    --muted: 240 3.7% 15.9%;\n    --muted-foreground: 240 5% 64.9%;\n    --accent: 240 3.7% 15.9%;\n    --accent-foreground: 0 0% 98%;\n    --destructive: 0 62.8% 30.6%;\n    --destructive-foreground: 0 0% 98%;\n    --border: 240 3.7% 15.9%;\n    --input: 240 3.7% 15.9%;\n    --ring: 240 4.9% 83.9%;\n    --chart-1: 220 70% 50%;\n    --chart-2: 160 60% 45%;\n    --chart-3: 30 80% 55%;\n    --chart-4: 280 65% 60%;\n    --chart-5: 340 75% 55%;\n  }\n}\n\n@layer base {\n  * {\n    @apply border-border;\n  }\n  body {\n    @apply bg-background text-foreground;\n  }\n}\n\ndialog::backdrop {\n  background: rgba(0, 0, 0, 0.5);\n}\n\n@supports (overflow-wrap: anywhere) {\n  .break-anywhere {\n    overflow-wrap: anywhere;\n  }\n}\n", "explanation": "This block defines a set of color palette values and applies global styles to an HTML document. It sets default colors for backgrounds, text, borders, and other visual elements.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/globals.css", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary:\n\n**app/globals.css**\n\nConfigures Tailwind CSS with custom color variables for light and dark modes, defining a set of global styles for backgrounds, text, borders, and more."}
{"code": "import MagicProvider from \"@/components/MagicProvider\";\nimport ChatProvider from \"@/components/ChatProvider\";\nimport { Toaster } from \"@/components/ui/sonner\";\n\nimport \"./globals.css\";\nimport { Assistant } from \"next/font/google\";\n\nconst assistant = Assistant({ subsets: [\"latin\"] });\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <title>Magic AI Chat Demo</title>\n        <link rel=\"shortcut icon\" href=\"/images/favicon.ico\" />\n        <meta name=\"description\" content=\"Magic AI Chat Demo\" />\n        <meta property=\"og:title\" content=\"Magic AI Chat Demo\" />\n        <meta property=\"og:description\" content=\"Magic AI Chat Demo\" />\n        <meta name=\"twitter:title\" content=\"Magic AI Chat Demo\" />\n        <meta name=\"twitter:description\" content=\"Magic AI Chat Demo\" />\n      </head>\n      <body className={assistant.className}>\n        <MagicProvider>\n          <ChatProvider>", "explanation": "Here is a concise summary:\n\nThis block imports necessary components, sets up global styles and fonts, and defines the basic HTML structure of a web page using React. It provides a layout for the app, wrapping child components with MagicProvider and ChatProvider.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/layout.tsx", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary:\n\nThe `app/layout.tsx` file sets up the basic HTML structure of the web page using React, applying global styles and fonts. It provides a layout template that wraps child components with `ChatProvider` and `MagicProvider`, featuring a full-screen background and a \"Toaster\" notification component at top-right corner."}
{"code": "            <div className=\"flex h-screen w-full flex-col bg-background\">\n              {children}\n            </div>\n            <Toaster position=\"top-right\" />\n          </ChatProvider>\n        </MagicProvider>\n      </body>\n    </html>\n  );\n}\n", "explanation": "This code block is a React component that:\n\n* Renders a full-screen div with a background color.\n* Contains a \"Toaster\" component (likely for displaying notifications) at the top-right corner of the screen.\n* Is wrapped in two providers: `ChatProvider` and `MagicProvider` ( likely for providing app-wide context).", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/layout.tsx", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary:\n\nThe `app/layout.tsx` file sets up the basic HTML structure of the web page using React, applying global styles and fonts. It provides a layout template that wraps child components with `ChatProvider` and `MagicProvider`, featuring a full-screen background and a \"Toaster\" notification component at top-right corner."}
{"code": "\"use client\";\n\nimport React, { useState } from \"react\";\nimport { ChatWindow } from \"@/components/ChatWindow\";\nimport { useMagic } from \"@/components/MagicProvider\";\nimport { LoadingIcon } from \"@/components/LoadingIcon\";\nimport { Button } from \"@/components/ui/button\";\nimport { UploadContractModal } from \"@/components/UploadContractModal\";\nimport { ContractItem } from \"@/components/ContractItem\";\nimport { useContracts } from \"@/utils/hooks/useContracts\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport { EditContractModal } from \"@/components/EditContractModal\";\nimport { ConfirmAlert } from \"@/components/ConfirmAlert\";\nimport { ChatSettingsModal } from \"@/components/ChatSettingsModal\";\nimport { shortenAddress } from \"@/utils/shortenAddress\";\nimport { toast } from \"sonner\";\nimport { useChat } from \"@/components/ChatProvider\";\nimport { Input } from \"@/components/ui/input\";\n\nconst CONTRACT_UPLOAD_ENABLED =\n  process.env.NEXT_PUBLIC_ALLOW_CONTRACT_UPLOAD === \"1\";\n", "explanation": "Here is a concise summary:\n\n**Purpose:** A React client-side component that enables contract management, including upload and editing, within a chat window.\n\n**Functionality:** Displays a list of contracts with functionality for uploading, editing, and managing contracts, as well as related settings and alerts.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/page.tsx", "chunk_number": 1, "total_chunks": 6}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise and holistic summary of the file 'app/page.tsx':\n\n**Purpose:** A React component that manages contracts within a chat window, handling upload, editing, settings, and alerts.\n\n**Functionality:** Displays contract lists, modals for editing/uploading, and related settings. It also handles user authentication, login, and logout processes."}
{"code": "export default function Page() {\n  const { contracts } = useContracts();\n  const [editContractKey, setEditContractKey] = useState<number | null>(null);\n  const [isUploadModalOpen, setIsUploadModalOpen] = useState(false);\n  const [email, setEmail] = useState(\"\");\n  const [isSettingsModalOpen, setIsSettingsModalOpen] = useState(false);\n  const { teeWalletAddress, didToken, handleLogin, handleLogout, isLoading } =\n    useMagic();\n  const { modelName } = useChat();\n\n  if (isLoading) {\n    return (\n      <div className=\"flex flex-col h-screen\">\n        <div className=\"flex-1 items-center flex justify-center\">\n          <LoadingIcon className=\"text-black\" />\n        </div>\n      </div>\n    );\n  }\n  return (\n    <div className=\"flex flex-col h-screen\">\n      {didToken ? (\n        <>\n          <div className=\"flex flex-1 overflow-hidden\">\n            <div className=\"hidden w-72 md:w-96 flex-col border-r bg-card p-4 sm:flex\">\n              <div className=\"grid gap-2 text-foreground\">", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** A React functional component (Page) that renders various UI components based on user authentication and contract data.\n\n**Functionality:**\n\n* Handles loading state and displays a loading icon.\n* Displays different UI components based on whether the user has logged in with their DID token.\n* Manages modal windows for editing contracts, uploading files, and settings.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/page.tsx", "chunk_number": 2, "total_chunks": 6}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise and holistic summary of the file 'app/page.tsx':\n\n**Purpose:** A React component that manages contracts within a chat window, handling upload, editing, settings, and alerts.\n\n**Functionality:** Displays contract lists, modals for editing/uploading, and related settings. It also handles user authentication, login, and logout processes."}
{"code": "                <div className=\"px-2 text-xs font-medium text-muted-foreground\">\n                  Uploaded Contracts\n                </div>\n\n                <ScrollArea className=\"max-h-[calc(100vh-11rem)]\">\n                  <div className=\"grid gap-2\">\n                    {contracts.map((contract) => (\n                      <ContractItem\n                        key={contract.key}\n                        contract={contract}\n                        onEdit={\n                          CONTRACT_UPLOAD_ENABLED\n                            ? () => setEditContractKey(contract.key)\n                            : undefined\n                        }\n                      />\n                    ))}\n                  </div>\n                </ScrollArea>\n                {CONTRACT_UPLOAD_ENABLED && (\n                  <Button onClick={() => setIsUploadModalOpen(true)}>\n                    Upload Contract\n                  </Button>\n                )}\n              </div>\n            </div>\n", "explanation": "Here is a summary of the block:\n\n**Purpose:** Display uploaded contracts in a scrollable area with an option to upload a new contract.\n\n**Functionality:**\n\n* Lists uploaded contracts using a `ContractItem` component\n* Scrolls through contracts within a set height (100vh - 11rem)\n* Displays an \"Upload Contract\" button when enabled, which opens a modal.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/page.tsx", "chunk_number": 3, "total_chunks": 6}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise and holistic summary of the file 'app/page.tsx':\n\n**Purpose:** A React component that manages contracts within a chat window, handling upload, editing, settings, and alerts.\n\n**Functionality:** Displays contract lists, modals for editing/uploading, and related settings. It also handles user authentication, login, and logout processes."}
{"code": "            <div id=\"temp\" className=\"flex-1 overflow-hidden flex flex-col\">\n              {/* Top Navigation */}\n              <nav className=\"bg-background border-b text-primary p-4 flex justify-between items-center\">\n                <h1 className=\"text-xl font-bold\">Magic AI Chat Demo</h1>\n                <div className=\"flex gap-4 items-center\">\n                  <Button onClick={() => setIsSettingsModalOpen(true)}>\n                    Settings\n                  </Button>\n                  <ConfirmAlert\n                    onConfirm={handleLogout}\n                    button={<Button>Logout</Button>}\n                    description=\"Are you sure you want to logout?\"\n                  />\n                </div>\n              </nav>\n\n              <div className=\"flex-1\">\n                <ChatWindow />\n              </div>\n\n              <div className=\"p-4 opacity-50 text-sm flex justify-between\">\n                {teeWalletAddress && (\n                  <p\n                    className=\"cursor-pointer\"", "explanation": "Here is a concise summary:\n\nThis block (HTML element) serves as a container for a chat interface, featuring:\n\n* A top navigation bar with title, settings button, and logout confirmation prompt\n* A chat window component\n* Optional display of wallet address information at bottom of page.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/page.tsx", "chunk_number": 4, "total_chunks": 6}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise and holistic summary of the file 'app/page.tsx':\n\n**Purpose:** A React component that manages contracts within a chat window, handling upload, editing, settings, and alerts.\n\n**Functionality:** Displays contract lists, modals for editing/uploading, and related settings. It also handles user authentication, login, and logout processes."}
{"code": "                    onClick={() => {\n                      toast(\"Copied to clipboard\");\n                      navigator.clipboard.writeText(teeWalletAddress);\n                    }}\n                  >\n                    Wallet Address: {shortenAddress(teeWalletAddress)}\n                  </p>\n                )}\n\n                <p>Model: {modelName}</p>\n              </div>\n            </div>\n          </div>\n\n          <ChatSettingsModal\n            isOpen={isSettingsModalOpen}\n            onClose={() => setIsSettingsModalOpen(false)}\n          />\n\n          <EditContractModal\n            contractKey={editContractKey}\n            onClose={() => setEditContractKey(null)}\n          />\n\n          <UploadContractModal\n            isOpen={isUploadModalOpen}\n            onClose={() => setIsUploadModalOpen(false)}\n          />\n        </>\n      ) : (\n        <div className=\"flex-1 items-center flex justify-center px-4\">\n          <form\n            className=\"flex-1 flex gap-4 max-w-[24rem]\"\n            onSubmit={(e) => {", "explanation": "**Summary:**\n\nThis block is a functional component that displays information about a model, including its wallet address and a button to copy the address to the clipboard. It also contains modals for chat settings and contract editing/uploading. \n\n**Functionality:** \n\n- Displays wallet address and a \"Copy\" button\n- Opens modals for chat settings and contract editing/uploading", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/page.tsx", "chunk_number": 5, "total_chunks": 6}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise and holistic summary of the file 'app/page.tsx':\n\n**Purpose:** A React component that manages contracts within a chat window, handling upload, editing, settings, and alerts.\n\n**Functionality:** Displays contract lists, modals for editing/uploading, and related settings. It also handles user authentication, login, and logout processes."}
{"code": "              e.preventDefault();\n              handleLogin(email);\n            }}\n          >\n            <Input\n              placeholder=\"Enter your email\"\n              value={email}\n              type=\"email\"\n              onChange={(e) => setEmail(e.target.value)}\n            />\n            <Button type=\"submit\">Login</Button>\n          </form>\n        </div>\n      )}\n    </div>\n  );\n}\n", "explanation": "**Summary**\n\nThis block is a form for user login, containing an input field for entering email and a submit button to trigger the login process.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "app/page.tsx", "chunk_number": 6, "total_chunks": 6}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise and holistic summary of the file 'app/page.tsx':\n\n**Purpose:** A React component that manages contracts within a chat window, handling upload, editing, settings, and alerts.\n\n**Functionality:** Displays contract lists, modals for editing/uploading, and related settings. It also handles user authentication, login, and logout processes."}
{"code": "{\n  \"$schema\": \"https://ui.shadcn.com/schema.json\",\n  \"style\": \"default\",\n  \"rsc\": true,\n  \"tsx\": true,\n  \"tailwind\": {\n    \"config\": \"tailwind.config.ts\",\n    \"css\": \"app/globals.css\",\n    \"baseColor\": \"zinc\",\n    \"cssVariables\": true,\n    \"prefix\": \"\"\n  },\n  \"aliases\": {\n    \"components\": \"@/components\",\n    \"utils\": \"@/lib/utils\"\n  }\n}", "explanation": "This block appears to be a configuration file (likely in JSON format) that defines settings for a UI component or project. It specifies the schema, style, and configuration options for Tailwind CSS, as well as alias paths for importing components and utilities.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components.json", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the 'components.json' file:\n\n**Components Configuration File**\n\nA JSON configuration file that defines settings for a UI component or project, including schema, style, and configuration options for Tailwind CSS."}
{"code": "import type { Message } from \"ai/react\";\nimport Link from \"next/link\";\nimport { User, Bot, Sparkles } from \"lucide-react\";\n\nimport { LoadingIcon } from \"./LoadingIcon\";\nimport { useState } from \"react\";\nimport { toast } from \"sonner\";\nimport { Button } from \"./ui/button\";\nimport { useMagic } from \"./MagicProvider\";\nimport { Badge } from \"./ui/badge\";\nimport { ToolArgsTable } from \"./ToolArgsTable\";\nimport { useContracts } from \"@/utils/hooks/useContracts\";\nimport { CHAINS } from \"@/constants\";\nimport { IContract } from \"@/types\";\nimport { usePinInput } from \"./PinInput\";\n\ntype IToolCall = {\n  name: string;\n  args: Record<string, any>;\n};\n\nconst getStyleForRole = (role: Message[\"role\"]) => {\n  const colorClassName =\n    role === \"user\"\n      ? \"bg-primary text-primary-foreground\"\n      : \"bg-muted text-primary-background\";\n  const alignmentClassName =\n    role === \"user\" ? \"ml-auto justify-end\" : \"mr-auto justify-start\";\n  const icon =\n    role === \"user\" ? (\n      <User strokeWidth={1.5} size={20} />\n    ) : (", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Importing various components and libraries**\n\nThis block imports necessary components, icons, and hooks from external libraries, including React, Next.js, and custom UI components. It also sets up state management using `useState` and provides access to magic and contract utilities through custom hooks. The code appears to be setting up a user interface for interacting with tools or contracts, possibly in the context of web3 development.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ChatMessageBubble.tsx", "chunk_number": 1, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise summary of the file 'components/ChatMessageBubble.tsx':\n\nThis file contains the `UserChatBubble` component, which renders chat message bubbles with customizable layouts and icons based on message types (user or tool call). The component displays the message content, user information (if applicable), and an optional link to view transactions."}
{"code": "      <Bot strokeWidth={1.5} size={24} />\n    );\n  return {\n    colorClassName,\n    alignmentClassName,\n    icon,\n  };\n};\n\nexport function UserChatBubble(props: { message: Message }) {\n  const { colorClassName, alignmentClassName, icon } = getStyleForRole(\n    props.message.role,\n  );\n\n  return (\n    <div\n      className={`${alignmentClassName} ${colorClassName} rounded p-2 max-w-[80%] flex`}\n    >\n      <div className=\"flex flex-col\">\n        <span className=\"break-all whitespace-pre-wrap\">\n          {props.message.content}\n        </span>\n      </div>\n      <div className=\"ml-2\">{icon}</div>\n    </div>\n  );\n}\n\ntype IToolCallResponse = {\n  message: string;\n  status: string;\n  payload: Record<string, any>;\n};\n\nfunction ToolCallSuccessBadge({\n  toolCallResponse,\n  contract,\n}: {\n  toolCallResponse: IToolCallResponse | null;\n  contract: IContract | null;\n}) {\n  if (!toolCallResponse)\n    return (\n      <div>\n        <Badge className=\"bg-zinc-500\">Unknown Error</Badge>\n      </div>\n    );\n\n  if (toolCallResponse.status !== \"success\") {", "explanation": "Here is a concise summary:\n\n**Block Summary**\n\nThis block contains two React components: `getStyleForRole` and `UserChatBubble`. The `getStyleForRole` function returns style classes based on a user's role, which is used in `UserChatBubble` to render a chat bubble with the user's message content and an icon.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ChatMessageBubble.tsx", "chunk_number": 2, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise summary of the file 'components/ChatMessageBubble.tsx':\n\nThis file contains the `UserChatBubble` component, which renders chat message bubbles with customizable layouts and icons based on message types (user or tool call). The component displays the message content, user information (if applicable), and an optional link to view transactions."}
{"code": "    return (\n      <div>\n        <Badge className=\"bg-rose-500\">Error</Badge>\n        {toolCallResponse.payload.transactionHash && contract && (\n          <TransactionLink\n            hash={toolCallResponse.payload.transactionHash}\n            contract={contract}\n          />\n        )}\n        <div className=\"mt-2 text-xs opacity-70 break-all\">\n          {toolCallResponse.message}\n        </div>\n        <div className=\"mt-2 text-xs opacity-70 break-all\">\n          {JSON.stringify(toolCallResponse.payload)}\n        </div>\n      </div>\n    );\n  }\n  return (\n    <div>\n      <Badge className=\"bg-emerald-500\">Success</Badge>\n      {toolCallResponse.payload.transactionHash && contract && (\n        <TransactionLink\n          hash={toolCallResponse.payload.transactionHash}\n          contract={contract}\n        />\n      )}\n    </div>\n  );\n}\n\nexport function ToolCallMessageBubble(props: { message: Message }) {\n  const [toolCallSuccess, setToolCallSuccess] = useState(false);\n  const [toolCallResponse, setToolCallResponse] =", "explanation": "Here is a concise summary:\n\n**Purpose:** Display a success or error message with additional details.\n\n**Functionality:**\n\n* Displays a \"Error\" or \"Success\" badge.\n* If successful, shows a link to a transaction on a blockchain platform (TransactionLink).\n* Shows the tool call response payload as JSON.\n* Uses state variables to manage whether the message is for a success or error scenario.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ChatMessageBubble.tsx", "chunk_number": 3, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise summary of the file 'components/ChatMessageBubble.tsx':\n\nThis file contains the `UserChatBubble` component, which renders chat message bubbles with customizable layouts and icons based on message types (user or tool call). The component displays the message content, user information (if applicable), and an optional link to view transactions."}
{"code": "    useState<IToolCallResponse | null>(null);\n  const [loading, setLoading] = useState(false);\n  const { didToken } = useMagic();\n  const { contracts, disabledKeys } = useContracts();\n  const { colorClassName, alignmentClassName, icon } = getStyleForRole(\n    props.message.role,\n  );\n  const { getPin, pinInput } = usePinInput();\n\n  let content: { text: string; toolCall?: IToolCall } = {\n    text: \"\",\n    toolCall: undefined,\n  };\n  try {\n    content = JSON.parse(props.message.content);\n  } catch (e) {\n    content.text = props.message.content;\n  }\n\n  const onToolCall = async (toolCall?: IToolCall) => {\n    if (!toolCall) return;\n\n    setLoading(true);\n    try {\n      const pin = await getPin();\n      if (!pin) throw new Error(\"Invalid PIN\");\n      const resp = await fetch(\"/api/execute\", {\n        method: \"POST\",\n        body: JSON.stringify({\n          toolCall,\n          didToken,\n          pin,\n          disabledContractKeys: disabledKeys,\n        }),\n      });\n\n      if (resp.status === 200) {", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Execute a tool call in response to a message.\n\n**Functionality:** \n\n1. Parse message content into JSON or plain text.\n2. If valid tool call, make API request to execute tool call with PIN authentication.\n3. Display loading indicator while executing.\n4. Handle errors and provide feedback.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ChatMessageBubble.tsx", "chunk_number": 4, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise summary of the file 'components/ChatMessageBubble.tsx':\n\nThis file contains the `UserChatBubble` component, which renders chat message bubbles with customizable layouts and icons based on message types (user or tool call). The component displays the message content, user information (if applicable), and an optional link to view transactions."}
{"code": "        const data = await resp.text();\n        setToolCallSuccess(true);\n        setToolCallResponse(JSON.parse(data));\n      } else {\n        const json = await resp.json();\n        toast(`error: ${json.error}`);\n      }\n    } catch (error) {\n      if (error instanceof Error) {\n        toast(`Error: ${error.message}`);\n      } else {\n        toast(\"An unexpected error occurred\");\n      }\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  let renderContent = null;\n\n  if (content.toolCall) {\n    const [key, name] = content.toolCall?.name.split(\"_\");\n    const contract = contracts.find((c) => c.key === Number(key));\n    if (contract) {\n      renderContent = (\n        <>\n          <span className=\"mb-2\">Would you like me to execute:</span>\n          <div\n            title={content.toolCall?.name}\n            className=\"mb-2 flex gap-2 items-center\"\n          >\n            <span className=\"\">{name}</span>\n            <span className=\"text-xs font-mono text-muted-foreground\">", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Handle API response from tool call, parse JSON data, and display success or error messages.\n\n**Functionality:**\n\n* Parse JSON response data\n* Update application state with parsed data (e.g., `setToolCallSuccess` and `setToolCallResponse`)\n* Display toast message for success or error cases\n* Catch and handle errors, displaying an error message in the UI\n* Set loading state to false when finished processing", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ChatMessageBubble.tsx", "chunk_number": 5, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise summary of the file 'components/ChatMessageBubble.tsx':\n\nThis file contains the `UserChatBubble` component, which renders chat message bubbles with customizable layouts and icons based on message types (user or tool call). The component displays the message content, user information (if applicable), and an optional link to view transactions."}
{"code": "              {contract.name}: {contract.address} (\n              {CHAINS[contract.chainId].name})\n            </span>\n          </div>\n          <span className=\"mb-2\">\n            <ToolArgsTable args={content.toolCall.args} />\n          </span>\n          <div>\n            {!toolCallSuccess ? (\n              <Button\n                className=\"rounded-full text-xs font-semibold\"\n                disabled={loading || toolCallSuccess}\n                onClick={() => {\n                  onToolCall(content.toolCall);\n                }}\n              >\n                {loading ? (\n                  <LoadingIcon />\n                ) : (\n                  <>\n                    <Sparkles strokeWidth={1.5} size={14} className=\"mr-1\" />\n                    Execute\n                  </>\n                )}\n              </Button>\n            ) : (\n              <ToolCallSuccessBadge\n                toolCallResponse={toolCallResponse}\n                contract={contract}\n              />\n            )}\n          </div>\n        </>", "explanation": "Here is a summary of the purpose and functionality of this block:\n\n**Purpose:** Display information about a blockchain contract, including its name, address, and chain, along with an option to execute a tool call.\n\n**Functionality:**\n\n* Displays contract details\n* Allows user to execute a tool call (with success/failure indication)\n* Updates with a \"success badge\" if the tool call is successful", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ChatMessageBubble.tsx", "chunk_number": 6, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise summary of the file 'components/ChatMessageBubble.tsx':\n\nThis file contains the `UserChatBubble` component, which renders chat message bubbles with customizable layouts and icons based on message types (user or tool call). The component displays the message content, user information (if applicable), and an optional link to view transactions."}
{"code": "      );\n    } else {\n      renderContent = <span>Bad tool call: {content.toolCall?.name}</span>;\n    }\n  } else {\n    renderContent = <span>{content.text}</span>;\n  }\n\n  return (\n    <>\n      <div\n        className={`${alignmentClassName} ${colorClassName} rounded p-2 max-w-[80%] flex`}\n      >\n        <div className=\"mr-2\">{icon}</div>\n        <div className=\"pr-6 break-anywhere whitespace-pre-wrap flex flex-col\">\n          {renderContent}\n        </div>\n      </div>\n\n      {pinInput}\n    </>\n  );\n}\n\nexport function ChatMessageBubble(props: { message: Message }) {\n  switch (props.message.role) {\n    case \"user\":\n      return <UserChatBubble {...props} />;\n    case \"assistant\":\n      return <ToolCallMessageBubble {...props} />;\n  }\n}\n\nconst TransactionLink = (props: { hash: string; contract: IContract }) => {\n  const uri = CHAINS[props.contract.chainId].explorerURI;\n  return (\n    <div className=\"mt-2 text-xs opacity-70 break-all\">\n      <Link target=\"_blank\" href={`${uri}/${props.hash}`} className=\"underline\">", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Functionality:** Renders a chat message bubble component with a customizable layout and icon, depending on the type of message (user or tool call).\n\n**Purpose:** To display user and tool call messages in a visually distinct way, allowing for customization through props.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ChatMessageBubble.tsx", "chunk_number": 7, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise summary of the file 'components/ChatMessageBubble.tsx':\n\nThis file contains the `UserChatBubble` component, which renders chat message bubbles with customizable layouts and icons based on message types (user or tool call). The component displays the message content, user information (if applicable), and an optional link to view transactions."}
{"code": "        View your Transaction\n      </Link>\n    </div>\n  );\n};\n", "explanation": "This block is a React component that displays a link for users to view their transactions.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ChatMessageBubble.tsx", "chunk_number": 8, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise summary of the file 'components/ChatMessageBubble.tsx':\n\nThis file contains the `UserChatBubble` component, which renders chat message bubbles with customizable layouts and icons based on message types (user or tool call). The component displays the message content, user information (if applicable), and an optional link to view transactions."}
{"code": "\"use client\";\n\nimport { createContext, useContext, useState } from \"react\";\nimport { UseChatHelpers, UseChatOptions, useChat as useAiChat } from \"ai/react\";\nimport { MODELS } from \"@/constants\";\nimport { useContracts } from \"@/utils/hooks/useContracts\";\nimport { toast } from \"sonner\";\n\nexport const ChatContext = createContext<\n  Pick<\n    UseChatOptions & UseChatHelpers,\n    \"messages\" | \"handleInputChange\" | \"handleSubmit\" | \"isLoading\" | \"input\"\n  > & {\n    modelName: string;\n    clearOnChange: boolean;\n    onClearMessages: () => void;\n    setModelName: (name: string) => void;\n    setClearOnChange: (v: boolean) => void;\n    addMessage: (message: string) => void;\n  }\n>({\n  messages: [],\n  handleInputChange: () => {},\n  handleSubmit: () => {},\n  isLoading: false,\n  input: \"\",\n  modelName: \"\",\n  clearOnChange: false,\n  onClearMessages: () => {},\n  setModelName: () => {},\n  setClearOnChange: () => {},\n  addMessage: (message: string) => {},\n});\n\nexport const useChat = () => useContext(ChatContext);\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Provide a chat functionality context for React components.\n\n**Functionality:** Creates a reusable chat context with pre-defined states and functions, allowing components to interact with a chat system using the `useChat` hook.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ChatProvider.tsx", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and holistic summary of the file 'components/ChatProvider.tsx':\n\n**Provides a reusable React context for AI-powered chat functionality, enabling components to interact with a chat system through the `useChat` hook.**"}
{"code": "const ChatProvider = ({ children }: any) => {\n  const { disabledKeys } = useContracts();\n  const [modelName, setModelName] = useState(MODELS[\"openai\"][0]);\n  const [clearOnChange, setClearOnChange] = useState(false);\n\n  const chatContext = useAiChat({\n    api: \"api/chat\",\n    body: { disabledContractKeys: disabledKeys, modelName },\n    streamProtocol: \"text\",\n    onError: (e) => {\n      toast(e.message);\n    },\n  });\n\n  const addMessage = (message: string) => {\n    if (chatContext.isLoading) return;\n    chatContext.append({ role: \"user\", content: message });\n  };\n\n  const onClearMessages = () => {\n    chatContext.setMessages([]);\n  };\n\n  return (\n    <ChatContext.Provider\n      value={{\n        ...chatContext,\n        modelName,\n        setModelName,\n        clearOnChange,\n        setClearOnChange,\n        onClearMessages,\n        addMessage,\n      }}\n    >\n      {children}\n    </ChatContext.Provider>\n  );\n};\n\nexport default ChatProvider;\n", "explanation": "Here is a concise summary of the block's purpose and functionality:\n\n**Purpose:** A React hook that provides a chat context for use with AI-powered chat functionality.\n\n**Functionality:** Wraps children components in a `ChatContext.Provider` with props for managing chat conversations, including adding messages, clearing messages, and setting model names.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ChatProvider.tsx", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and holistic summary of the file 'components/ChatProvider.tsx':\n\n**Provides a reusable React context for AI-powered chat functionality, enabling components to interact with a chat system through the `useChat` hook.**"}
{"code": "\"use client\";\n\nimport { useState } from \"react\";\nimport { Label } from \"@/components/ui/label\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport { Checkbox } from \"./ui/checkbox\";\nimport { MODELS } from \"@/constants\";\nimport { Button } from \"./ui/button\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogTitle,\n  DialogHeader,\n  DialogFooter,\n} from \"./ui/dialog\";\nimport { useChat } from \"./ChatProvider\";\nimport { findInferenceByModelName } from \"@/utils/llm/getModel\";\n\ntype IChatSettingProps = {\n  isOpen: boolean;\n  onClose: () => void;\n};\n\nexport function ChatSettingsModal(props: IChatSettingProps) {\n  const {\n    modelName,\n    setModelName,\n    onClearMessages,\n    clearOnChange,\n    setClearOnChange,\n  } = useChat();\n\n  const onSetModelName = (value: string) => {\n    if (clearOnChange) {\n      onClearMessages();\n    }\n    setModelName(value);\n  };\n\n  const [inferenceProvider, setInferenceProvider] = useState(() => {", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** A chat settings modal dialog that allows users to select models and clear messages.\n\n**Functionality:**\n\n* Displays a dropdown list of available inference providers (models) using the `Select` component\n* Allows users to select a model and set it as the current model for the chat application\n* Includes buttons to clear messages and toggle whether messages are cleared on selection change", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ChatSettingsModal.tsx", "chunk_number": 1, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a holistic summary of the file 'components/ChatSettingsModal.tsx':\n\nThis component renders a settings modal with a dropdown list of available inference providers (models), allowing users to select a model and clear messages. It includes buttons for clearing messages, toggling message clearance on selection change, and a label with optional checkbox for clearing previous results when changed."}
{"code": "    return findInferenceByModelName(modelName);\n  });\n\n  const handleInferenceProviderChange = (value: keyof typeof MODELS) => {\n    setInferenceProvider(value);\n  };\n\n  return (\n    <Dialog open={props.isOpen} onOpenChange={props.onClose}>\n      <DialogContent className=\"\">\n        <DialogHeader>\n          <DialogTitle>Settings</DialogTitle>\n        </DialogHeader>\n\n        <div className=\"flex w-full flex-col gap-4 mt-4\">\n          <div>\n            <Label htmlFor=\"inferenceProvider\">Inference</Label>\n            <Select\n              value={inferenceProvider}\n              onValueChange={handleInferenceProviderChange}\n            >\n              <SelectTrigger id=\"modelName\">\n                <SelectValue placeholder=\"Select a provider\" />\n              </SelectTrigger>\n              <SelectContent>\n                {Object.keys(MODELS).map((i) => (\n                  <SelectItem key={i} value={i}>\n                    {i}\n                  </SelectItem>\n                ))}\n              </SelectContent>", "explanation": "Here is a concise summary:\n\nThis block defines two functions: `handleInferenceProviderChange` updates an `inferenceProvider` state variable when selected from a dropdown menu, and returns a result of `findInferenceByModelName(modelName)`. It also renders a settings dialog with a select input for choosing an inference provider.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ChatSettingsModal.tsx", "chunk_number": 2, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a holistic summary of the file 'components/ChatSettingsModal.tsx':\n\nThis component renders a settings modal with a dropdown list of available inference providers (models), allowing users to select a model and clear messages. It includes buttons for clearing messages, toggling message clearance on selection change, and a label with optional checkbox for clearing previous results when changed."}
{"code": "            </Select>\n          </div>\n          {inferenceProvider && (\n            <div>\n              <Label htmlFor=\"modelName\">Model</Label>\n              <Select value={modelName} onValueChange={onSetModelName}>\n                <SelectTrigger id=\"modelName\">\n                  <SelectValue placeholder=\"Select a model\" />\n                </SelectTrigger>\n                <SelectContent>\n                  {MODELS[inferenceProvider].map((modelName) => (\n                    <SelectItem key={modelName} value={modelName}>\n                      {modelName}\n                    </SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n            </div>\n          )}\n\n          <div className=\"flex items-center space-x-2\">\n            <Checkbox\n              id=\"terms\"\n              checked={clearOnChange}\n              onCheckedChange={setClearOnChange}\n            />\n            <label\n              htmlFor=\"terms\"", "explanation": "Here is a concise summary:\n\nThis block contains a select dropdown menu that allows users to choose a model, and an optional checkbox for clearing previous results when changed.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ChatSettingsModal.tsx", "chunk_number": 3, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a holistic summary of the file 'components/ChatSettingsModal.tsx':\n\nThis component renders a settings modal with a dropdown list of available inference providers (models), allowing users to select a model and clear messages. It includes buttons for clearing messages, toggling message clearance on selection change, and a label with optional checkbox for clearing previous results when changed."}
{"code": "              className=\"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\"\n            >\n              Clear Chat on Model change\n            </label>\n          </div>\n\n          <DialogFooter>\n            <Button onClick={props.onClose}>Close</Button>\n          </DialogFooter>\n        </div>\n      </DialogContent>\n    </Dialog>\n  );\n}\n", "explanation": "This block appears to be a part of a dialog box in a UI component, likely used for user interactions.\n\n**Purpose:** To display a label (\"Clear Chat on Model change\") that is disabled when certain conditions are met (based on the \"peer-disabled\" class).\n\n**Functionality:** A clickable label that, when clicked, triggers an action or closes the dialog.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ChatSettingsModal.tsx", "chunk_number": 4, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a holistic summary of the file 'components/ChatSettingsModal.tsx':\n\nThis component renders a settings modal with a dropdown list of available inference providers (models), allowing users to select a model and clear messages. It includes buttons for clearing messages, toggling message clearance on selection change, and a label with optional checkbox for clearing previous results when changed."}
{"code": "\"use client\";\n\nimport { useEffect, useRef, type FormEvent } from \"react\";\nimport { Input } from \"@/components/ui/input\";\nimport { Button } from \"@/components/ui/button\";\nimport { Card, CardContent, CardFooter } from \"@/components/ui/card\";\nimport { ChatMessageBubble } from \"@/components/ChatMessageBubble\";\nimport { LoadingIcon } from \"@/components/LoadingIcon\";\nimport { Label } from \"@/components/ui/label\";\nimport { CornerDownLeft, Trash2 } from \"lucide-react\";\nimport { ConfirmAlert } from \"./ConfirmAlert\";\nimport { useChat } from \"./ChatProvider\";\nimport { SuggestedMessageList } from \"./SuggestedMessageList\";\n\nexport function ChatWindow() {\n  const chatContainerRef = useRef<HTMLDivElement>(null);\n\n  const {\n    messages,\n    input,\n    handleInputChange,\n    handleSubmit,\n    onClearMessages,\n    addMessage,\n    isLoading,\n  } = useChat();\n\n  const scrollToBottom = () => {\n    if (chatContainerRef.current) {\n      const { scrollHeight, clientHeight } = chatContainerRef.current;", "explanation": "Here is a concise summary:\n\n**Purpose:** Render a chat window component.\n\n**Functionality:**\n\n* Displays a chat interface with input field and button.\n* Fetches and displays chat messages using `useChat` hook.\n* Provides functionality for submitting new messages, clearing all messages, and scrolling to the bottom of the chat container.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ChatWindow.tsx", "chunk_number": 1, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'components/ChatWindow.tsx':\n\n**Purpose:** Display chat history and allow users to send new messages.\n\n**Functionality:** Render a scrollable chat interface with input field, button, and loading indicator, enabling users to submit new messages, clear all messages, and scroll to the bottom when new messages are added."}
{"code": "      chatContainerRef.current.scrollTop = scrollHeight - clientHeight;\n    }\n  };\n\n  useEffect(() => {\n    scrollToBottom();\n  }, [messages]);\n\n  useEffect(() => {\n    const chatContainer = chatContainerRef.current;\n    if (chatContainer) {\n      const observer = new MutationObserver(() => {\n        if (\n          chatContainer.scrollTop + chatContainer.clientHeight >=\n          chatContainer.scrollHeight - 100\n        ) {\n          scrollToBottom();\n        }\n      });\n      observer.observe(chatContainer, { childList: true, subtree: true });\n      return () => observer.disconnect();\n    }\n  }, []);\n  async function sendMessage(e: FormEvent<HTMLFormElement>) {\n    e.preventDefault();\n    if (!messages.length) {\n      await new Promise((resolve) => setTimeout(resolve, 300));\n    }\n    if (isLoading) {\n      return;\n    }\n    handleSubmit(e);\n  }\n\n  return (\n    <Card className=\"flex grow flex-col h-[calc(100vh-8rem)] border-none shadow-none\">\n      <CardContent className=\"flex-grow overflow-hidden p-0\">", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Maintain a chat conversation interface that scrolls to the bottom when new messages are added or when the user reaches the end of the conversation.\n\n**Functionality:**\n\n* Scrolls to the bottom of the chat container when new messages are received.\n* Observes changes in the chat container for scrolling and adjusts accordingly.\n* Prevents multiple form submissions while sending a message.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ChatWindow.tsx", "chunk_number": 2, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'components/ChatWindow.tsx':\n\n**Purpose:** Display chat history and allow users to send new messages.\n\n**Functionality:** Render a scrollable chat interface with input field, button, and loading indicator, enabling users to submit new messages, clear all messages, and scroll to the bottom when new messages are added."}
{"code": "        <div className=\"flex h-full\">\n          <div ref={chatContainerRef} className=\"flex-1 p-4 overflow-y-auto\">\n            <div className=\"grid gap-4\">\n              {messages.length > 0\n                ? messages.map((m) => (\n                    <ChatMessageBubble key={m.id} message={m} />\n                  ))\n                : null}\n            </div>\n          </div>\n        </div>\n      </CardContent>\n      <CardFooter className=\"flex-col pb-0 px-4 gap-2\">\n        <div className=\"flex gap-2 flex-wrap\">\n          <SuggestedMessageList addMessage={addMessage} />\n        </div>\n\n        <form\n          onSubmit={sendMessage}\n          className=\"w-full relative overflow-hidden rounded-lg border bg-background\"\n        >\n          <Label htmlFor=\"message\" className=\"sr-only\">\n            Message\n          </Label>\n          <Input\n            id=\"message\"\n            className=\"min-h-12 border-0 p-3 pb-2 shadow-none focus-visible:ring-0\"\n            value={input}", "explanation": "This block is a chat interface with two main sections:\n\n1. **Message display**: A scrollable container displaying previous messages from `messages` array, rendered as `ChatMessageBubble` components.\n2. **Input and send button**: A form allowing users to input a message, which can be submitted via the `sendMessage` function, and displayed in the chat interface using the `addMessage` function.\n\nIn short: display chat history and allow user to send new messages.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ChatWindow.tsx", "chunk_number": 3, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'components/ChatWindow.tsx':\n\n**Purpose:** Display chat history and allow users to send new messages.\n\n**Functionality:** Render a scrollable chat interface with input field, button, and loading indicator, enabling users to submit new messages, clear all messages, and scroll to the bottom when new messages are added."}
{"code": "            placeholder=\"Type your message here...\"\n            onChange={handleInputChange}\n          />\n          <div className=\"flex items-center p-2 pt-0\">\n            <ConfirmAlert\n              onConfirm={onClearMessages}\n              description=\"This will clear out your chat history\"\n              button={\n                <Button variant=\"ghost\" size=\"icon\" title=\"Clear messages\">\n                  <Trash2 strokeWidth={1.5} size={20} />\n                  <span className=\"sr-only\">Clear messages</span>\n                </Button>\n              }\n            />\n            <Button\n              type=\"submit\"\n              size=\"sm\"\n              className=\"ml-auto gap-1.5\"\n              disabled={isLoading}\n            >\n              {isLoading ? (\n                <div role=\"status\" className=\"flex justify-center\">\n                  <LoadingIcon />\n                  <span className=\"sr-only\">Loading...</span>\n                </div>\n              ) : (\n                <>\n                  Send", "explanation": "Here is a concise summary:\n\n**Functionality:** A message input field with a submit button, accompanied by a clear messages confirmation alert and a loading indicator.\n\n**Purpose:** Allows users to input and send messages, while also providing an option to clear previous chat history and displaying a loading indicator when sending.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ChatWindow.tsx", "chunk_number": 4, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'components/ChatWindow.tsx':\n\n**Purpose:** Display chat history and allow users to send new messages.\n\n**Functionality:** Render a scrollable chat interface with input field, button, and loading indicator, enabling users to submit new messages, clear all messages, and scroll to the bottom when new messages are added."}
{"code": "                  <CornerDownLeft strokeWidth={1.5} size={20} />\n                </>\n              )}\n            </Button>\n          </div>\n        </form>\n      </CardFooter>\n    </Card>\n  );\n}\n", "explanation": "A React component block.\n\n**Summary:** A reusable button component with a corner-down-left icon, likely used for submitting or saving data in a form.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ChatWindow.tsx", "chunk_number": 5, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'components/ChatWindow.tsx':\n\n**Purpose:** Display chat history and allow users to send new messages.\n\n**Functionality:** Render a scrollable chat interface with input field, button, and loading indicator, enabling users to submit new messages, clear all messages, and scroll to the bottom when new messages are added."}
{"code": "import {\n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogCancel,\n  AlertDialogContent,\n  AlertDialogDescription,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogTitle,\n  AlertDialogTrigger,\n} from \"@/components/ui/alert-dialog\";\n\nimport { ReactNode } from \"react\";\n\nexport function ConfirmAlert({\n  button,\n  description,\n  onConfirm,\n}: {\n  button: ReactNode;\n  description: string;\n  onConfirm: () => void;\n}) {\n  return (\n    <AlertDialog>\n      <AlertDialogTrigger asChild>{button}</AlertDialogTrigger>\n      <AlertDialogContent>\n        <AlertDialogHeader>\n          <AlertDialogTitle>Are you sure?</AlertDialogTitle>\n          <AlertDialogDescription>{description}</AlertDialogDescription>\n        </AlertDialogHeader>\n        <AlertDialogFooter>\n          <AlertDialogCancel>Cancel</AlertDialogCancel>\n          <AlertDialogAction onClick={onConfirm}>Continue</AlertDialogAction>\n        </AlertDialogFooter>\n      </AlertDialogContent>\n    </AlertDialog>\n  );\n}\n", "explanation": "**Purpose:** Provides a customizable confirmation alert box.\n\n**Functionality:** Displays a dialog with a button that, when clicked, triggers a confirmation action (onConfirm function). Can be customized with a title, description, and buttons.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ConfirmAlert.tsx", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary:\n\n`components/ConfirmAlert.tsx`: A customizable confirmation alert box that displays a dialog with a button to confirm an action, allowing customization of title, description, and buttons."}
{"code": "import { Pencil, Circle, CircleCheck } from \"lucide-react\";\nimport { CHAINS } from \"@/constants\";\nimport { IContract } from \"@/types\";\nimport { shortenAddress } from \"@/utils/shortenAddress\";\nimport { useContracts } from \"@/utils/hooks/useContracts\";\n\nexport const ContractItem = (props: {\n  contract: IContract;\n  onEdit?: (key: number) => void;\n}) => {\n  const { disabledKeys, setDisabledKeys } = useContracts();\n  const isDisabled = disabledKeys.includes(props.contract.key);\n  const DisabledIcon = isDisabled ? Circle : CircleCheck;\n  return (\n    <div className=\"border p-3 rounded-md\">\n      <div\n        className={`flex items-center gap-2 ${isDisabled ? \"opacity-50\" : \"\"}`}\n      >\n        <div className=\"flex flex-col flex-1\">\n          <span>\n            {props.contract.name}{\" \"}\n            <small className=\"text-muted-foreground\">\n              ({CHAINS[props.contract.chainId]?.name})\n            </small>\n          </span>\n          <small className=\"font-xs font-mono text-muted-foreground\">", "explanation": "**Summary:**\n\nThis block is a functional React component named `ContractItem`. It displays information about a contract, including its name, chain ID, and an edit icon (either a pencil or a checkmark). The component also checks if the contract is disabled and adjusts its appearance accordingly.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ContractItem.tsx", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise holistic summary of the file 'components/ContractItem.tsx':\n\nThe `ContractItem` component displays contract details, including address, description, edit icon, and toggle for disabled status."}
{"code": "            {shortenAddress(props.contract.address)}\n          </small>\n          {props.contract.description && (\n            <small className=\"font-xs text-muted-foreground mt-1\">\n              {props.contract.description}\n            </small>\n          )}\n        </div>\n\n        {props.onEdit && (\n          <Pencil\n            onClick={() => props.onEdit?.(props.contract.key)}\n            className=\"h-4 w-4 cursor-pointer\"\n          />\n        )}\n\n        <DisabledIcon\n          className=\"h-4 w-4 cursor-pointer\"\n          onClick={() =>\n            isDisabled\n              ? setDisabledKeys(\n                  disabledKeys.filter((k) => k !== props.contract.key),\n                )\n              : setDisabledKeys([...disabledKeys, props.contract.key])\n          }\n        />\n      </div>\n    </div>\n  );\n};\n", "explanation": "Here is a summary of the purpose and functionality:\n\n**Summary:**\n\nThis block displays information about a contract (address and description), along with an edit icon and toggle disabled status icon.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ContractItem.tsx", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise holistic summary of the file 'components/ContractItem.tsx':\n\nThe `ContractItem` component displays contract details, including address, description, edit icon, and toggle for disabled status."}
{"code": "import { useCallback, useEffect, useState } from \"react\";\nimport { Input } from \"./ui/input\";\nimport { Button } from \"./ui/button\";\nimport { LoadingIcon } from \"./LoadingIcon\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"./ui/dialog\";\nimport { Label } from \"./ui/label\";\nimport { useContracts } from \"@/utils/hooks/useContracts\";\nimport { ConfirmAlert } from \"./ConfirmAlert\";\nimport { IABIFunctionDescription } from \"@/types\";\n\nimport * as React from \"react\";\nimport { ChevronsUpDown } from \"lucide-react\";\n\nimport {\n  Collapsible,\n  CollapsibleContent,\n  CollapsibleTrigger,\n} from \"@/components/ui/collapsible\";\nimport { Card, CardContent } from \"./ui/card\";\nimport { Textarea } from \"./ui/textarea\";\n\nexport function EditContractModal({\n  contractKey,\n  onClose,\n}: {\n  contractKey: number | null;\n  onClose: () => void;\n}) {\n  const {\n    contracts,\n    onRemove,\n    onEdit,\n    setErrorMessage,\n    errorMessage,\n    isLoading,\n  } = useContracts();", "explanation": "**Summary**\n\nThis block is a React component named `EditContractModal`. Its purpose is to display a modal dialog for editing a contract, allowing users to input new data and save changes or cancel the edit process. The component uses various UI components and hooks to manage its functionality.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/EditContractModal.tsx", "chunk_number": 1, "total_chunks": 9}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'components/EditContractModal.tsx':\n\nThe `EditContractModal` component is a React modal dialog for editing contracts, allowing users to input new data, save changes, or cancel edits. It manages contract form state, updates ABI descriptions in response to user input, and handles form submission events to edit contracts. The component displays address, name, description, context, and ABI descriptions for a contract, and allows editing of the contract name while triggering an `onClose` event when completed."}
{"code": "  const [name, setName] = useState(\"\");\n  const [description, setDescription] = useState(\"\");\n  const [context, setContext] = useState(\"\");\n  const [openDescriptionIndex, setOpenDescriptionIndex] = useState(-1);\n  const [abiDescriptions, setAbiDescriptions] = useState<\n    IABIFunctionDescription[] | undefined\n  >();\n\n  const contract = contracts.find((c) => c.key === contractKey);\n  const onResetForm = useCallback(() => {\n    setName(contract?.name ?? \"\");\n    setDescription(contract?.description ?? \"\");\n    setContext(contract?.context ?? \"\");\n    setAbiDescriptions(contract?.abiDescriptions);\n    setErrorMessage(\"\");\n  }, [\n    contract?.name,\n    contract?.description,\n    contract?.context,\n    contract?.abiDescriptions,\n    setErrorMessage,\n  ]);\n\n  useEffect(() => {\n    onResetForm();\n  }, [contractKey, onResetForm]);\n\n  if (typeof contractKey !== \"number\") return null;\n\n  const updateAbiDescriptions = (\n    value: string,\n    descriptionIndex: number,\n    inputIndex?: number,\n    isValueDescription?: boolean,", "explanation": "**Summary**\n\nThis block of code initializes state variables for a contract form and updates them based on changes to the `contractKey` variable. It also includes functions to reset the form fields and update ABI descriptions. The purpose is to manage data for a contract form, ensuring it remains in sync with the current contract being displayed.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/EditContractModal.tsx", "chunk_number": 2, "total_chunks": 9}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'components/EditContractModal.tsx':\n\nThe `EditContractModal` component is a React modal dialog for editing contracts, allowing users to input new data, save changes, or cancel edits. It manages contract form state, updates ABI descriptions in response to user input, and handles form submission events to edit contracts. The component displays address, name, description, context, and ABI descriptions for a contract, and allows editing of the contract name while triggering an `onClose` event when completed."}
{"code": "  ) =>\n    setAbiDescriptions((abi) => {\n      return abi?.map((abiDescription, index) => {\n        if (descriptionIndex !== index) return abiDescription;\n\n        return {\n          ...abiDescription,\n          description:\n            typeof inputIndex === \"number\" || isValueDescription\n              ? abiDescription.description\n              : value,\n          valueDescription: isValueDescription\n            ? value\n            : abiDescription.valueDescription,\n          inputs: abiDescription.inputs.map((input, i) =>\n            inputIndex === i ? { ...input, description: value } : input,\n          ),\n        };\n      });\n    });\n\n  return (\n    <Dialog open={typeof contractKey === \"number\"} onOpenChange={onClose}>\n      <DialogContent className=\"max-w-2xl\">\n        <DialogHeader>\n          <DialogTitle>Edit Contract</DialogTitle>\n        </DialogHeader>\n\n        <form\n          className=\"flex w-full flex-col overflow-y-scroll\"\n          onSubmit={(e) => {\n            e.preventDefault();\n            onEdit({", "explanation": "Here is a concise summary:\n\nThis block updates ABI descriptions in response to user input, modifying specific descriptions or values as needed. It also handles a form submission event to edit contracts.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/EditContractModal.tsx", "chunk_number": 3, "total_chunks": 9}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'components/EditContractModal.tsx':\n\nThe `EditContractModal` component is a React modal dialog for editing contracts, allowing users to input new data, save changes, or cancel edits. It manages contract form state, updates ABI descriptions in response to user input, and handles form submission events to edit contracts. The component displays address, name, description, context, and ABI descriptions for a contract, and allows editing of the contract name while triggering an `onClose` event when completed."}
{"code": "              key: contractKey,\n              name,\n              description,\n              context,\n              abiDescriptions,\n            }).then(() => {\n              onClose();\n            });\n          }}\n        >\n          <div className=\"max-h-[800px] overflow-y-scroll px-1 my-3\">\n            <div className=\"flex flex-col gap-2 my-4\">\n              <Label htmlFor=\"name\">Address</Label>\n              <Input\n                id=\"address\"\n                placeholder=\"Enter a name\"\n                disabled\n                value={contract?.address}\n              />\n            </div>\n            <div className=\"flex flex-col gap-2 my-4\">\n              <Label htmlFor=\"name\">Name</Label>\n              <Input\n                id=\"name\"\n                placeholder=\"Enter a name\"\n                value={name}\n                onChange={(e) => setName(e.target.value)}\n              />\n            </div>\n            <div className=\"flex flex-col gap-2 my-4\">", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Displays and edits contract information.\n\n**Functionality:** Shows address, name, description, context, and ABI descriptions for a contract. Allows editing of contract name and triggers an onClose event when completed.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/EditContractModal.tsx", "chunk_number": 4, "total_chunks": 9}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'components/EditContractModal.tsx':\n\nThe `EditContractModal` component is a React modal dialog for editing contracts, allowing users to input new data, save changes, or cancel edits. It manages contract form state, updates ABI descriptions in response to user input, and handles form submission events to edit contracts. The component displays address, name, description, context, and ABI descriptions for a contract, and allows editing of the contract name while triggering an `onClose` event when completed."}
{"code": "              <Label htmlFor=\"description\">Description</Label>\n              <Input\n                id=\"description\"\n                placeholder=\"Enter a description\"\n                value={description}\n                onChange={(e) => setDescription(e.target.value)}\n              />\n            </div>\n            <div className=\"flex flex-col gap-2 my-4\">\n              <Label htmlFor=\"context\">Context</Label>\n              <Textarea\n                id=\"context\"\n                placeholder=\"Enter a context\"\n                value={context}\n                onChange={(e) => setContext(e.target.value)}\n              />\n            </div>\n\n            <span className=\"font-[600] text-lg\">Function Descriptions</span>\n\n            <div className=\"flex flex-col gap-2\">\n              {abiDescriptions?.map((abiDescription, descriptionIndex) => (\n                <FunctionDescriptionInput\n                  key={descriptionIndex}\n                  abiDescription={abiDescription}\n                  index={descriptionIndex}", "explanation": "Here is a concise summary:\n\nThis block creates input fields for users to enter a \"Description\" (text input) and a \"Context\" (textarea). It also displays \"Function Descriptions\", which are generated dynamically from an array (`abiDescriptions`) using the `FunctionDescriptionInput` component, likely displaying function-specific details.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/EditContractModal.tsx", "chunk_number": 5, "total_chunks": 9}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'components/EditContractModal.tsx':\n\nThe `EditContractModal` component is a React modal dialog for editing contracts, allowing users to input new data, save changes, or cancel edits. It manages contract form state, updates ABI descriptions in response to user input, and handles form submission events to edit contracts. The component displays address, name, description, context, and ABI descriptions for a contract, and allows editing of the contract name while triggering an `onClose` event when completed."}
{"code": "                  onChange={updateAbiDescriptions}\n                  openDescriptionIndex={openDescriptionIndex}\n                  setIsOpen={setOpenDescriptionIndex}\n                />\n              ))}\n            </div>\n          </div>\n\n          <DialogFooter>\n            {errorMessage && (\n              <p className=\"text-red-500 mt-3\">{errorMessage}</p>\n            )}\n\n            <ConfirmAlert\n              onConfirm={() => onRemove(contractKey).then(onClose)}\n              button={\n                <Button className=\"bg-red-500\" title=\"Delete\">\n                  Delete\n                </Button>\n              }\n              description=\"This will delete the contract\"\n            />\n            <Button type=\"submit\" disabled={isLoading || !name}>\n              <div\n                role=\"status\"\n                className={`${isLoading ? \"\" : \"hidden\"} flex justify-center`}\n              >\n                <LoadingIcon />\n                <span className=\"sr-only\">Loading...</span>\n              </div>\n", "explanation": "Here is a concise summary:\n\nThis block appears to be a functional component that contains:\n\n* A Confirm Alert for deleting a contract\n* A submit button for saving changes (with a loading indicator)\n* An error message display\n\nThe functionality is tied to state variables such as `openDescriptionIndex`, `isLoading`, and `errorMessage`.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/EditContractModal.tsx", "chunk_number": 6, "total_chunks": 9}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'components/EditContractModal.tsx':\n\nThe `EditContractModal` component is a React modal dialog for editing contracts, allowing users to input new data, save changes, or cancel edits. It manages contract form state, updates ABI descriptions in response to user input, and handles form submission events to edit contracts. The component displays address, name, description, context, and ABI descriptions for a contract, and allows editing of the contract name while triggering an `onClose` event when completed."}
{"code": "              <span className={isLoading ? \"hidden\" : \"\"}>Save</span>\n            </Button>\n          </DialogFooter>\n        </form>\n      </DialogContent>\n    </Dialog>\n  );\n}\n\nconst FunctionDescriptionInput = ({\n  abiDescription,\n  index,\n  onChange,\n  openDescriptionIndex,\n  setIsOpen,\n}: {\n  openDescriptionIndex: number;\n  setIsOpen: (n: number) => void;\n  abiDescription: IABIFunctionDescription;\n  index: number;\n  onChange: (v: string, i: number, i2?: number, b?: boolean) => void;\n}) => {\n  return (\n    <Card>\n      <CardContent className=\"p-4 py-2\">\n        <Collapsible\n          open={openDescriptionIndex === index}\n          onOpenChange={() =>\n            setIsOpen(openDescriptionIndex === index ? -1 : index)\n          }\n          className=\"w-full\"\n        >\n          <CollapsibleTrigger asChild>\n            <div className=\"flex items-center justify-between cursor-pointer\">\n              <span className=\"capitalize font-[600] truncate\">\n                {abiDescription.name}\n              </span>\n", "explanation": "Here is a concise summary of the block:\n\n**Functionality:** A save button that is hidden when a dialog box is loading.\n\n**Purpose:** To display or hide a save button based on the dialog's load state.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/EditContractModal.tsx", "chunk_number": 7, "total_chunks": 9}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'components/EditContractModal.tsx':\n\nThe `EditContractModal` component is a React modal dialog for editing contracts, allowing users to input new data, save changes, or cancel edits. It manages contract form state, updates ABI descriptions in response to user input, and handles form submission events to edit contracts. The component displays address, name, description, context, and ABI descriptions for a contract, and allows editing of the contract name while triggering an `onClose` event when completed."}
{"code": "              <Button\n                type=\"button\"\n                variant=\"ghost\"\n                size=\"sm\"\n                className=\"w-9 p-0 -mr-3\"\n              >\n                <ChevronsUpDown className=\"h-4 w-4\" />\n                <span className=\"sr-only\">Toggle</span>\n              </Button>\n            </div>\n          </CollapsibleTrigger>\n\n          <CollapsibleContent>\n            <Label>Function Description</Label>\n            <Textarea\n              id={abiDescription.name}\n              placeholder=\"Enter a description\"\n              className=\"min-h-[100px]\"\n              value={abiDescription.description}\n              onChange={(e) => onChange(e.target.value, index)}\n            />\n\n            <p className=\"mt-2 font-[600]\">Inputs</p>\n\n            <div className=\"mt-2\">\n              <div className=\"mb-2\">\n                <Label htmlFor=\"name\">Transaction Value</Label>\n                <Input\n                  placeholder=\"Enter a description\"", "explanation": "**Purpose:**\nA collapsible button that toggles visibility of a form section.\n\n**Functionality:**\n\n* A small button with an up/down chevron icon is displayed.\n* Clicking the button opens or closes a content area containing:\n\t+ A text input field for a function description.\n\t+ A label and input field for transaction value.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/EditContractModal.tsx", "chunk_number": 8, "total_chunks": 9}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'components/EditContractModal.tsx':\n\nThe `EditContractModal` component is a React modal dialog for editing contracts, allowing users to input new data, save changes, or cancel edits. It manages contract form state, updates ABI descriptions in response to user input, and handles form submission events to edit contracts. The component displays address, name, description, context, and ABI descriptions for a contract, and allows editing of the contract name while triggering an `onClose` event when completed."}
{"code": "                  value={abiDescription.valueDescription}\n                  onChange={(e) =>\n                    onChange(e.target.value, index, undefined, true)\n                  }\n                />\n              </div>\n\n              {abiDescription.inputs.map((input, inputIndex) => (\n                <div key={inputIndex} className=\"mb-2\">\n                  <Label htmlFor=\"name\">{input.name}</Label>\n                  <Input\n                    placeholder=\"Enter a description\"\n                    value={input.description}\n                    onChange={(e) =>\n                      onChange(e.target.value, index, inputIndex)\n                    }\n                  />\n                </div>\n              ))}\n            </div>\n          </CollapsibleContent>\n        </Collapsible>\n      </CardContent>\n    </Card>\n  );\n};\n", "explanation": "**Summary:**\n\nThis block of code is a form field for editing a function's description in an ABI (Application Binary Interface) definition. It allows users to input a new description, as well as modify individual input descriptions within the function.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/EditContractModal.tsx", "chunk_number": 9, "total_chunks": 9}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'components/EditContractModal.tsx':\n\nThe `EditContractModal` component is a React modal dialog for editing contracts, allowing users to input new data, save changes, or cancel edits. It manages contract form state, updates ABI descriptions in response to user input, and handles form submission events to edit contracts. The component displays address, name, description, context, and ABI descriptions for a contract, and allows editing of the contract name while triggering an `onClose` event when completed."}
{"code": "\"use client\";\n\nimport { LoaderCircle } from \"lucide-react\";\n\nexport const LoadingIcon = (props: any) => (\n  <span\n    aria-hidden=\"true\"\n    className={`w-6 h-6 ${\n      props.className ?? \"text-white\"\n    } animate-spin dark:text-foreground`}\n  >\n    <LoaderCircle />\n  </span>\n);\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Renders a loading icon.\n\n**Functionality:** Displays a spinning circular animation, likely used as a loading indicator.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/LoadingIcon.tsx", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise and to-the-point holistic summary of the file 'components/LoadingIcon.tsx':\n\n**Summary:** A React component that displays a spinning circular animation, serving as a visual loading indicator."}
{"code": "\"use client\";\n\nimport { Magic } from \"magic-sdk\";\nimport { ethers, BrowserProvider } from \"ethers\";\nimport { createContext, useContext, useEffect, useMemo, useState } from \"react\";\nimport { usePinInput } from \"./PinInput\";\n\n// Create and export the context\nexport const MagicContext = createContext<{\n  isLoading: boolean;\n  magic: Magic | null;\n  provider: BrowserProvider | null;\n  handleLogout: () => void;\n  handleLogin: (email: string) => void;\n  teeWalletAddress: string | null;\n  didToken: string | null;\n}>({\n  isLoading: true,\n  magic: null,\n  provider: null,\n  handleLogout: () => {},\n  handleLogin: () => {},\n  teeWalletAddress: null,\n  didToken: null,\n});\n\nexport const useMagic = () => useContext(MagicContext);\n\nconst MagicProvider = ({ children }: any) => {\n  const [magic, setMagic] = useState<Magic | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [provider, setProvider] = useState<BrowserProvider | null>(null);", "explanation": "**Summary**\n\nThis block creates a React context (`MagicContext`) to manage user authentication with Magic (a passwordless auth service) and Ethers.js (an Ethereum library). It provides a `useMagic` hook for components to access this context, ensuring consistent authentication state across the application.\n\nFunctionalities include:\n\n* Authentication status tracking\n* Handling login and logout logic\n* Managing Magic and Ethers provider connections", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/MagicProvider.tsx", "chunk_number": 1, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'components/MagicProvider.tsx':\n\n**Purpose:** Initialize wallet and DID management for Magic authentication.\n\n**Functionality:** Handles user login/out with email OTP, stores/retrieves DID tokens, fetches TEE wallet address, and exposes context to child components."}
{"code": "  const [teeWalletAddress, setTEEWalletAddress] = useState<string | null>(null);\n\n  const [didToken, setDidToken] = useState<string | null>(null);\n\n  const { getPin, pinInput } = usePinInput({\n    title: \"Enter your Wallet PIN\",\n    description:\n      \"You will be asked to enter this value whenever you try to execute a transaction\",\n    allowCancel: false,\n  });\n\n  useEffect(() => {\n    setDidToken(localStorage.getItem(\"didToken\"));\n      const magic = new Magic(\"pk_live_ADAA583390992B34\" || \"\", {\n        network: {\n          rpcUrl: \"<https://rpc2.sepolia.org/>\",\n          chainId: 11155111,\n        },\n      });\n      setMagic(magic);\n      const web3Provider = new ethers.BrowserProvider(magic.rpcProvider);\n      setProvider(web3Provider);\n      setIsLoading(false);\n  }, []);\n\n  useEffect(() => {\n    if (!didToken) return;\n\n    const getTEEAddress = async () => {\n      let response = await fetch(`/api/wallet?didToken=${didToken}`);\n      if (!response.ok) {\n        const pin = await getPin();", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Initialize wallet and DID (Decentralized Identity) management.\n\n**Functionality:**\n\n* Store user's PIN input and retrieve DID token from local storage.\n* Set up Magic API for interacting with Sepolia blockchain network.\n* Create Web3 provider using ethers.js library.\n* Fetch TEE (Trusted Execution Environment) address from API endpoint when DID token is available.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/MagicProvider.tsx", "chunk_number": 2, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'components/MagicProvider.tsx':\n\n**Purpose:** Initialize wallet and DID management for Magic authentication.\n\n**Functionality:** Handles user login/out with email OTP, stores/retrieves DID tokens, fetches TEE wallet address, and exposes context to child components."}
{"code": "        response = await fetch(`/api/wallet?didToken=${didToken}&pin=${pin}`);\n      }\n      const json = await response.json();\n      setTEEWalletAddress(json.wallet_address);\n    };\n\n    getTEEAddress();\n  }, [didToken, getPin]);\n\n  const handleLogin = async (email: string) => {\n    if (!magic) return;\n    setIsLoading(true);\n    try {\n      const didToken = await magic.auth.loginWithEmailOTP({\n        email,\n        showUI: true,\n        lifespan: 31557600000, // 1000 years\n      });\n      if (didToken) localStorage.setItem(\"didToken\", didToken);\n      setDidToken(didToken);\n    } catch (e) {\n      console.error(e);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleLogout = async () => {\n    if (!magic) return;\n    await magic.user.logout();\n    setDidToken(null);\n    localStorage.removeItem(\"didToken\");\n    setTEEWalletAddress(null);\n  };\n\n  const value = useMemo(() => ({ magic, provider }), [magic, provider]);\n\n  return (\n    <MagicContext.Provider\n      value={{\n        ...value,\n        isLoading,", "explanation": "Here is a concise summary:\n\nThis block of code handles user authentication with Magic, an authentication service. It logs in/out users with email OTP verification and stores/retrieves DID tokens (device identifiers) locally. It also fetches a TEE wallet address based on the stored DID token and displays it in the UI.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/MagicProvider.tsx", "chunk_number": 3, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'components/MagicProvider.tsx':\n\n**Purpose:** Initialize wallet and DID management for Magic authentication.\n\n**Functionality:** Handles user login/out with email OTP, stores/retrieves DID tokens, fetches TEE wallet address, and exposes context to child components."}
{"code": "        teeWalletAddress,\n        handleLogout,\n        handleLogin,\n        didToken,\n      }}\n    >\n      {children}\n      {pinInput}\n    </MagicContext.Provider>\n  );\n};\n\nexport default MagicProvider;\n", "explanation": "This code snippet appears to be a React component, specifically the `MagicProvider` component.\n\n**Purpose:** Provides context for the \"Magic\" library, enabling its functionality within the component tree.\n\n**Functionality:** Exposes several functions (e.g., handleLogout, handleLogin) and values (e.g., teeWalletAddress, didToken) to child components through its context.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/MagicProvider.tsx", "chunk_number": 4, "total_chunks": 4}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'components/MagicProvider.tsx':\n\n**Purpose:** Initialize wallet and DID management for Magic authentication.\n\n**Functionality:** Handles user login/out with email OTP, stores/retrieves DID tokens, fetches TEE wallet address, and exposes context to child components."}
{"code": "import {\n  InputOTP,\n  InputOTPGroup,\n  InputOTPSlot,\n} from \"@/components/ui/input-otp\";\nimport {\n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogContent,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogTitle,\n} from \"@/components/ui/alert-dialog\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport {\n  AlertDialogCancel,\n  AlertDialogDescription,\n} from \"@radix-ui/react-alert-dialog\";\n\nexport function PinInput(props: {\n  open: boolean;\n  title: string;\n  description: string;\n  onSubmit?: (s: string) => void;\n  onCancel?: () => void;\n  pinLength?: number;\n}) {\n  const [value, setValue] = useState(\"\");\n  const length = props.pinLength ?? 4;\n\n  useEffect(() => {\n    if (props.open) setValue(\"\");\n  }, [props.open]);\n\n  return (\n    <AlertDialog open={props.open}>\n      <AlertDialogContent className={props.description ? \"w-[24rem]\" : \"w-60\"}>\n        <form\n          className=\"flex flex-col gap-6\"\n          onSubmit={(e) => {\n            e.preventDefault();", "explanation": "**Summary:**\n\nThis block is a React functional component called `PinInput`. It displays an OTP (One-Time Password) input form within an AlertDialog. The form allows users to enter a PIN, which can be submitted or cancelled when complete.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/PinInput.tsx", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and to-the-point holistic summary of the file 'components/PinInput.tsx':\n\nThe `PinInput` component displays an OTP input form within a dialog box, allowing users to enter a PIN that can be submitted or cancelled when complete. It manages an open/closed state and enables optional title and description display."}
{"code": "            if (value.length === length) props.onSubmit?.(value);\n          }}\n        >\n          <AlertDialogHeader className=\"items-center gap-2\">\n            <AlertDialogTitle>{props.title}</AlertDialogTitle>\n            {props.description && (\n              <AlertDialogDescription className=\"!mt-0 text-center opacity-60\">\n                {props.description}\n              </AlertDialogDescription>\n            )}\n            <InputOTP\n              autoFocus={props.open}\n              maxLength={length}\n              value={value}\n              onChange={setValue}\n            >\n              <InputOTPGroup>\n                {Array.from({ length }, (_, i) => (\n                  <InputOTPSlot key={i} index={i} />\n                ))}\n              </InputOTPGroup>\n            </InputOTP>\n          </AlertDialogHeader>\n\n          <AlertDialogFooter className=\"gap-4\">\n            {props.onCancel && (\n              <AlertDialogCancel onClick={() => props.onCancel?.()}>\n                Cancel", "explanation": "Here is a concise summary:\n\n**Purpose:** Trigger an `onSubmit` event when a user enters a valid OTP (one-time password) of a specified length.\n\n**Functionality:** A dialog box with an input field for entering an OTP, accompanied by title, description, and cancel buttons. When the entered value matches the required length, it calls the `onSubmit` function if provided.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/PinInput.tsx", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and to-the-point holistic summary of the file 'components/PinInput.tsx':\n\nThe `PinInput` component displays an OTP input form within a dialog box, allowing users to enter a PIN that can be submitted or cancelled when complete. It manages an open/closed state and enables optional title and description display."}
{"code": "              </AlertDialogCancel>\n            )}\n            <AlertDialogAction disabled={value.length < length} type=\"submit\">\n              Submit\n            </AlertDialogAction>\n          </AlertDialogFooter>\n        </form>\n      </AlertDialogContent>\n    </AlertDialog>\n  );\n}\n\nexport const usePinInput = ({\n  title = \"Enter PIN\",\n  description = \"\",\n  allowCancel = true,\n} = {}) => {\n  const [isPinOpen, setIsPinOpen] = useState(false);\n  const pinPromiseRef = useRef<(s?: string) => void>();\n  const pinInput = (\n    <PinInput\n      open={isPinOpen}\n      title={title}\n      description={description}\n      onCancel={allowCancel ? pinPromiseRef.current : undefined}\n      onSubmit={pinPromiseRef.current}\n    />\n  );\n\n  const getPin = useCallback(async () => {\n    setIsPinOpen(true);\n    const pin = await new Promise((resolve) => {\n      pinPromiseRef.current = resolve;\n    });\n    setIsPinOpen(false);\n    return pin;\n  }, []);\n\n  return { pinInput, getPin };\n};\n", "explanation": "Here is a summary of the purpose and functionality:\n\n**Purpose:** A PIN input dialog for collecting a user's PIN.\n\n**Functionality:** The `usePinInput` hook manages an open/closed state and allows submitting or canceling a PIN entry, enabling users to enter a secure code with optional title and description.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/PinInput.tsx", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and to-the-point holistic summary of the file 'components/PinInput.tsx':\n\nThe `PinInput` component displays an OTP input form within a dialog box, allowing users to enter a PIN that can be submitted or cancelled when complete. It manages an open/closed state and enables optional title and description display."}
{"code": "import { Button } from \"./ui/button\";\n\nconst buttonMessages: string[] = [\n  \"What can you do?\",\n  \"Can you transfer?\",\n  \"Can you swap eth for usdc?\",\n  \"Can you swap .00001 ETH for USDC with the deadline within 3 hours?\",\n];\n\n/**\n * Renders a list of button components with suggested messages for your convience.\n * Each button, when clicked, will trigger the `addMessage` callback.\n *\n * @function CommonMessages\n * @param {Object} props - The props for the CommonMessages component.\n * @param {string[]} [props.suggestedMessages=buttonMessages] - An optional array of suggested messages to display as buttons. Defaults to a predefined array `buttonMessages`.\n * @param {function(React.MouseEvent<HTMLButtonElement>): void} props.addMessage - A callback function to handle the button click event, receives the click event object as its argument.\n *\n * @returns {JSX.Element[] | null} A list of Button components, each displaying a message, or null if there are no messages to display.\n */", "explanation": "Here is a concise summary:\n\n**Purpose:** Renders a list of customizable buttons with suggested messages.\n\n**Functionality:** Displays a list of button components with predefined messages (or custom messages via props) that trigger an `addMessage` callback when clicked.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/SuggestedMessageList.tsx", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise holistic summary:\n\n**Components/SuggestedMessageList.tsx:**\n\n* **Purpose:** Renders a list of customizable buttons with suggested messages.\n* **Functionality:** Displays a list of button components with predefined or custom messages that trigger an `addMessage` callback on click."}
{"code": "export function SuggestedMessageList({\n  suggestedMessages = buttonMessages,\n  addMessage,\n}: {\n  suggestedMessages?: string[];\n  addMessage: (msg: string) => void;\n}) {\n  if (!suggestedMessages || !suggestedMessages.length) return null;\n  return suggestedMessages.map((message, index) => (\n    <Button\n      key={index}\n      size=\"sm\"\n      className=\"whitespace-normal h-auto py-2\"\n      onClick={(e: React.MouseEvent<HTMLButtonElement>) =>\n        addMessage(e.currentTarget.innerHTML)\n      }\n    >\n      {message}\n    </Button>\n  ));\n}\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Renders a list of suggested messages as buttons.\n\n**Functionality:** Maps over an array of message strings, rendering each as a button with an `onClick` event that triggers the `addMessage` function.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/SuggestedMessageList.tsx", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise holistic summary:\n\n**Components/SuggestedMessageList.tsx:**\n\n* **Purpose:** Renders a list of customizable buttons with suggested messages.\n* **Functionality:** Displays a list of button components with predefined or custom messages that trigger an `addMessage` callback on click."}
{"code": "import {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from \"@/components/ui/table\";\n\nexport function ToolArgsTable({ args }: { args: Record<string, string> }) {\n  const data = Object.entries(args);\n\n  return (\n    <div className=\"rounded-md border bg-background\">\n      <Table>\n        <TableHeader>\n          <TableRow>\n            <TableHead className=\"w-[200px]\">Arg</TableHead>\n            <TableHead>Value</TableHead>\n          </TableRow>\n        </TableHeader>\n        <TableBody>\n          {data.map(([argName, value], index) => (\n            <TableRow key={index}>\n              <TableCell className=\"font-medium\">{argName}</TableCell>\n              <TableCell>\n                {Array.isArray(value) ? value.join(\", \") : value}\n                <TimePreview value={value} />\n              </TableCell>\n            </TableRow>\n          ))}\n        </TableBody>\n      </Table>\n    </div>\n  );\n}\n\nconst ONE_MONTH = 1000 * 60 * 60 * 24 * 30;\n\nconst TimePreview = ({ value }: { value: any }) => {", "explanation": "**Summary**\n\nThis block is a React component called `ToolArgsTable` that displays a table of key-value pairs in a user interface. It takes an object with string keys and values as input, maps it to a table structure with two columns (\"Arg\" and \"Value\"), and renders each pair as a table row.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ToolArgsTable.tsx", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "However, I don't see any summaries related to \"formats date from timestamp\". The provided summaries seem to be about two different code blocks:\n\n1. A React component `ToolArgsTable` that displays a table of key-value pairs.\n2. A function (not shown in the summary) that formats a date string from a timestamp.\n\nHere's a concise and holistic summary of the file 'components/ToolArgsTable.tsx':\n\n**Summary**\n\nA React component called `ToolArgsTable` that displays a table of key-value pairs, rendering each pair as a table row with \"Arg\" and \"Value\" columns."}
{"code": "  let date: Date | undefined;\n  date = new Date(value * 1000);\n  if (isNaN(date.getTime())) {\n    date = undefined;\n  }\n\n  if (!date || Math.abs(Date.now() - +date) > ONE_MONTH) return null;\n\n  return (\n    <span className=\"text-xs opacity-50 ml-2\">\n      {date.toLocaleTimeString(\"en-US\", {\n        weekday: \"short\",\n        month: \"short\",\n        day: \"numeric\",\n      })}\n    </span>\n  );\n};\n", "explanation": "Here is a concise summary:\n\n**Function:** Formats date from timestamp into human-readable string.\n\n**Purpose:** Returns a formatted date string if input is valid, otherwise returns null.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ToolArgsTable.tsx", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "However, I don't see any summaries related to \"formats date from timestamp\". The provided summaries seem to be about two different code blocks:\n\n1. A React component `ToolArgsTable` that displays a table of key-value pairs.\n2. A function (not shown in the summary) that formats a date string from a timestamp.\n\nHere's a concise and holistic summary of the file 'components/ToolArgsTable.tsx':\n\n**Summary**\n\nA React component called `ToolArgsTable` that displays a table of key-value pairs, rendering each pair as a table row with \"Arg\" and \"Value\" columns."}
{"code": "import { useCallback, useEffect, useState } from \"react\";\nimport { Input } from \"./ui/input\";\nimport { Button } from \"./ui/button\";\nimport { LoadingIcon } from \"./LoadingIcon\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"./ui/dialog\";\nimport { Label } from \"./ui/label\";\nimport {\n  Select,\n  SelectContent,\n  SelectGroup,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"./ui/select\";\nimport { CHAINS } from \"@/constants\";\nimport { ChainIdEnum } from \"@/types\";\nimport { useContracts } from \"@/utils/hooks/useContracts\";\nimport { Textarea } from \"./ui/textarea\";\n\nexport function UploadContractModal({\n  isOpen,\n  onClose,\n}: {\n  isOpen: boolean;\n  onClose: () => void;\n}) {\n  const { onUpload, setErrorMessage, errorMessage, isLoading } = useContracts();\n  const [address, setAddress] = useState(\"\");\n  const [name, setName] = useState(\"\");\n  const [description, setDescription] = useState(\"\");\n  const [abi, setABI] = useState(\"\");", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** A React modal component for uploading a contract.\n\n**Functionality:** Allows users to upload a contract by entering address, name, description, and ABI (Application Binary Interface) details, with features like input fields, buttons, and a loading indicator.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/UploadContractModal.tsx", "chunk_number": 1, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise holistic summary of the file 'components/UploadContractModal.tsx':\n\nThis React modal component enables users to upload a contract by collecting address, name, description, ABI details, and chain ID through various input fields, buttons, and a loading indicator. It features form reset functionality on open, submission handling with a successful closure of the dialog, and a dropdown for selecting a blockchain chain ID."}
{"code": "  const [chainId, setChainId] = useState<ChainIdEnum | -1>(-1);\n\n  const onResetForm = useCallback(() => {\n    setAddress(\"\");\n    setChainId(-1);\n    setName(\"\");\n    setDescription(\"\");\n    setABI(\"\");\n    setErrorMessage(\"\");\n  }, [setErrorMessage]);\n\n  useEffect(() => {\n    onResetForm();\n  }, [isOpen, onResetForm]);\n\n  return (\n    <Dialog open={isOpen} onOpenChange={onClose}>\n      <DialogContent className=\"\">\n        <DialogHeader>\n          <DialogTitle>Upload Contract</DialogTitle>\n        </DialogHeader>\n\n        <form\n          className=\"flex w-full flex-col gap-4 mt-4\"\n          onSubmit={(e) => {\n            e.preventDefault();\n            onUpload({ address, name, chainId, abi, description }).then(\n              (contracts) => {\n                if (contracts) onClose();\n              },\n            );\n          }}\n        >\n          <div className=\"grid gap-4 py-4\">\n            <div className=\"flex flex-col gap-2\">\n              <Label htmlFor=\"name\">Name</Label>\n              <Input", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Reset form values and close dialog on open.\n\n**Functionality:**\n\n* Resets form fields (`address`, `chainId`, `name`, etc.) when dialog is opened.\n* Submits form data to `onUpload` function when submitted, then closes dialog if successful.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/UploadContractModal.tsx", "chunk_number": 2, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise holistic summary of the file 'components/UploadContractModal.tsx':\n\nThis React modal component enables users to upload a contract by collecting address, name, description, ABI details, and chain ID through various input fields, buttons, and a loading indicator. It features form reset functionality on open, submission handling with a successful closure of the dialog, and a dropdown for selecting a blockchain chain ID."}
{"code": "                id=\"name\"\n                placeholder=\"Enter a name\"\n                value={name}\n                onChange={(e) => setName(e.target.value)}\n              />\n            </div>\n            <div className=\"flex flex-col gap-2\">\n              <Label htmlFor=\"description\">Description</Label>\n              <Input\n                id=\"description\"\n                placeholder=\"Enter a description\"\n                value={description}\n                onChange={(e) => setDescription(e.target.value)}\n              />\n            </div>\n\n            <div className=\"flex flex-col gap-2\">\n              <Label htmlFor=\"address\">Address</Label>\n              <Input\n                id=\"address\"\n                value={address}\n                placeholder=\"Enter a contract address\"\n                onChange={(e) => setAddress(e.target.value)}\n              />\n            </div>\n\n            <ChainSelect chainId={chainId} setChainId={setChainId} />\n\n            <div className=\"flex flex-col gap-2\">", "explanation": "Here is a concise summary:\n\n**Form Fields**\n\nThis block contains input fields for user data, including:\n\n1. Name: A text field for entering a name.\n2. Description: A text area for entering a description.\n3. Address: A text field for entering a contract address.\n4. Chain Select: A dropdown to select a blockchain chain ID.\n\nEach field has a corresponding state variable and an `onChange` event handler to update the state when user input changes.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/UploadContractModal.tsx", "chunk_number": 3, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise holistic summary of the file 'components/UploadContractModal.tsx':\n\nThis React modal component enables users to upload a contract by collecting address, name, description, ABI details, and chain ID through various input fields, buttons, and a loading indicator. It features form reset functionality on open, submission handling with a successful closure of the dialog, and a dropdown for selecting a blockchain chain ID."}
{"code": "              <Label htmlFor=\"abi\">ABI</Label>\n              <Textarea\n                id=\"abi\"\n                value={abi}\n                placeholder=\"Enter ABI\"\n                onChange={(e) => setABI(e.target.value)}\n              />\n            </div>\n          </div>\n\n          <DialogFooter>\n            {errorMessage && (\n              <p className=\"text-red-500 mt-3\">{errorMessage}</p>\n            )}\n\n            <Button\n              type=\"submit\"\n              disabled={isLoading || !name || !address || chainId === -1}\n            >\n              <div\n                role=\"status\"\n                className={`${isLoading ? \"\" : \"hidden\"} flex justify-center`}\n              >\n                <LoadingIcon />\n                <span className=\"sr-only\">Loading...</span>\n              </div>\n\n              <span className={isLoading ? \"hidden\" : \"\"}>Save</span>\n            </Button>\n          </DialogFooter>\n        </form>\n      </DialogContent>\n    </Dialog>\n  );\n}\n\nconst ChainSelect = (props: {", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** A form dialog that collects user input for creating or editing a blockchain project.\n\n**Functionality:** The form includes a textarea for entering ABI (Application Binary Interface) code, a submit button to save the changes, and displays an error message if any.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/UploadContractModal.tsx", "chunk_number": 4, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise holistic summary of the file 'components/UploadContractModal.tsx':\n\nThis React modal component enables users to upload a contract by collecting address, name, description, ABI details, and chain ID through various input fields, buttons, and a loading indicator. It features form reset functionality on open, submission handling with a successful closure of the dialog, and a dropdown for selecting a blockchain chain ID."}
{"code": "  chainId: ChainIdEnum | -1;\n  setChainId: (chainId: ChainIdEnum) => void;\n}) => (\n  <div className=\"flex flex-col gap-2\">\n    <Label htmlFor=\"chainId\">Chain</Label>\n    <Select\n      value={props.chainId === -1 ? \"\" : `${props.chainId}`}\n      onValueChange={(s) => props.setChainId(Number(s) as ChainIdEnum)}\n    >\n      <SelectTrigger>\n        <SelectValue placeholder=\"Select a chain\" />\n      </SelectTrigger>\n      <SelectContent>\n        <SelectGroup>\n          {Object.entries(CHAINS)\n            .sort((a, b) => a[0].localeCompare(b[0]))\n            .map(([key, value]) => (\n              <SelectItem key={key} value={key}>\n                {value.name}\n              </SelectItem>\n            ))}\n        </SelectGroup>\n      </SelectContent>\n    </Select>\n  </div>\n);\n", "explanation": "Here is a concise summary:\n\n**Purpose:** A dropdown menu for selecting a blockchain chain ID.\n\n**Functionality:** Allows users to choose from a list of predefined chains, updating a corresponding state variable with the selected ID.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/UploadContractModal.tsx", "chunk_number": 5, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise holistic summary of the file 'components/UploadContractModal.tsx':\n\nThis React modal component enables users to upload a contract by collecting address, name, description, ABI details, and chain ID through various input fields, buttons, and a loading indicator. It features form reset functionality on open, submission handling with a successful closure of the dialog, and a dropdown for selecting a blockchain chain ID."}
{"code": "\"use client\"\n\nimport * as React from \"react\"\nimport * as AlertDialogPrimitive from \"@radix-ui/react-alert-dialog\"\n\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\n\nconst AlertDialog = AlertDialogPrimitive.Root\n\nconst AlertDialogTrigger = AlertDialogPrimitive.Trigger\n\nconst AlertDialogPortal = AlertDialogPrimitive.Portal\n\nconst AlertDialogOverlay = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Overlay\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  />\n))\nAlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName\n\nconst AlertDialogContent = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Content>,", "explanation": "Here is a concise summary:\n\nThis block imports and sets up a customizable alert dialog component using Radix UI's `@radix-ui/react-alert-dialog` library, allowing for dynamic display of alerts or modals in a React application.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/alert-dialog.tsx", "chunk_number": 1, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'components/ui/alert-dialog.tsx':\n\n**Purpose:** Defines a customizable alert dialog component using Radix UI's `@radix-ui/react-alert-dialog` library.\n\n**Functionality:** Provides reusable components for headers, footers, titles, descriptions, and action buttons within an alert dialog, allowing for dynamic display of alerts or modals."}
{"code": "  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPortal>\n    <AlertDialogOverlay />\n    <AlertDialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    />\n  </AlertDialogPortal>\n))\nAlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName\n\nconst AlertDialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div", "explanation": "Here is a concise summary of the purpose and functionality:\n\n**Purpose:** A functional component that renders an alert dialog content.\n\n**Functionality:** It returns a JSX element with a fixed position, overlaying other content, and contains an AlertDialogPrimitive.Content component with customizable styles and props.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/alert-dialog.tsx", "chunk_number": 2, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'components/ui/alert-dialog.tsx':\n\n**Purpose:** Defines a customizable alert dialog component using Radix UI's `@radix-ui/react-alert-dialog` library.\n\n**Functionality:** Provides reusable components for headers, footers, titles, descriptions, and action buttons within an alert dialog, allowing for dynamic display of alerts or modals."}
{"code": "    className={cn(\n      \"flex flex-col space-y-2 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogHeader.displayName = \"AlertDialogHeader\"\n\nconst AlertDialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogFooter.displayName = \"AlertDialogFooter\"\n\nconst AlertDialogTitle = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Title\n    ref={ref}\n    className={cn(\"text-lg font-semibold\", className)}\n    {...props}\n  />\n))\nAlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName\n\nconst AlertDialogDescription = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Description>,", "explanation": "Here is a concise summary:\n\n**Block Purpose:** Define reusable alert dialog components (Header, Footer, Title, Description) with customizable styles.\n\n**Functionality:**\n\n* `AlertDialogHeader`: A container for the header text.\n* `AlertDialogFooter`: A container for the footer controls.\n* `AlertDialogTitle` and `AlertDialogDescription`: Customizable title and description components within an alert dialog.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/alert-dialog.tsx", "chunk_number": 3, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'components/ui/alert-dialog.tsx':\n\n**Purpose:** Defines a customizable alert dialog component using Radix UI's `@radix-ui/react-alert-dialog` library.\n\n**Functionality:** Provides reusable components for headers, footers, titles, descriptions, and action buttons within an alert dialog, allowing for dynamic display of alerts or modals."}
{"code": "  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nAlertDialogDescription.displayName =\n  AlertDialogPrimitive.Description.displayName\n\nconst AlertDialogAction = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Action>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Action\n    ref={ref}\n    className={cn(buttonVariants(), className)}\n    {...props}\n  />\n))\nAlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName\n\nconst AlertDialogCancel = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Cancel\n    ref={ref}\n    className={cn(", "explanation": "This block defines two React components:\n\n1. `AlertDialogDescription`: a component that renders an alert description with customizable text and styling.\n2. `AlertDialogAction` and `AlertDialogCancel`: two button-like components for confirming or canceling an action in an alert dialog.\n\nBoth components forward their props to the underlying `AlertDialogPrimitive.Description`, `Action`, or `Cancel` components, allowing for customization of styles and behavior.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/alert-dialog.tsx", "chunk_number": 4, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'components/ui/alert-dialog.tsx':\n\n**Purpose:** Defines a customizable alert dialog component using Radix UI's `@radix-ui/react-alert-dialog` library.\n\n**Functionality:** Provides reusable components for headers, footers, titles, descriptions, and action buttons within an alert dialog, allowing for dynamic display of alerts or modals."}
{"code": "      buttonVariants({ variant: \"outline\" }),\n      \"mt-2 sm:mt-0\",\n      className\n    )}\n    {...props}\n  />\n))\nAlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName\n\nexport {\n  AlertDialog,\n  AlertDialogPortal,\n  AlertDialogOverlay,\n  AlertDialogTrigger,\n  AlertDialogContent,\n  AlertDialogHeader,\n  AlertDialogFooter,\n  AlertDialogTitle,\n  AlertDialogDescription,\n  AlertDialogAction,\n  AlertDialogCancel,\n}\n", "explanation": "Here is a concise summary:\n\nThis block defines an AlertDialog component, including its variants, layout classes, and properties. It exports several related components for use in an application.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/alert-dialog.tsx", "chunk_number": 5, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'components/ui/alert-dialog.tsx':\n\n**Purpose:** Defines a customizable alert dialog component using Radix UI's `@radix-ui/react-alert-dialog` library.\n\n**Functionality:** Provides reusable components for headers, footers, titles, descriptions, and action buttons within an alert dialog, allowing for dynamic display of alerts or modals."}
{"code": "import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n  \"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-primary text-primary-foreground hover:bg-primary/80\",\n        secondary:\n          \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        destructive:\n          \"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80\",\n        outline: \"text-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nexport interface BadgeProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof badgeVariants> {}\n\nfunction Badge({ className, variant, ...props }: BadgeProps) {\n  return (", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** A reusable React component for creating badges with customizable styles and variants.\n\n**Functionality:** The `Badge` component allows you to create badges with different styles, such as primary, secondary, destructive, or outline, using the `badgeVariants` utility.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/badge.tsx", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise summary:\n\n**Summary:** A customizable React badge component that renders badges in various styles (primary, secondary, destructive, outline) using the `badgeVariants` utility."}
{"code": "    <div className={cn(badgeVariants({ variant }), className)} {...props} />\n  )\n}\n\nexport { Badge, badgeVariants }\n", "explanation": "**Summary:**\n\nThis block is a React component that renders a \"Badge\" element. It uses a `badgeVariants` function to determine its styling based on a specified variant, and can be customized with additional props.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/badge.tsx", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise summary:\n\n**Summary:** A customizable React badge component that renders badges in various styles (primary, secondary, destructive, outline) using the `badgeVariants` utility."}
{"code": "import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-destructive-foreground hover:bg-destructive/90\",\n        outline:\n          \"border border-input bg-background hover:bg-accent hover:text-accent-foreground\",\n        secondary:\n          \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",", "explanation": "Here is a concise summary:\n\n**Purpose:** A React button component with customizable styles.\n\n**Functionality:** Provides a reusable button element with various visual states (e.g., primary, destructive, outline) that can be customized using CSS classes from `class-variance-authority`.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/button.tsx", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary:\n\n**Summary:**\n`button.tsx`: A reusable React button component with customizable styles, variants, and sizes that can be dynamically styled and composed for use in various contexts."}
{"code": "        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-10 px-4 py-2\",\n        sm: \"h-9 rounded-md px-3\",\n        lg: \"h-11 rounded-md px-8\",\n        icon: \"h-10 w-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\"\n    return (\n      <Comp\n        className={cn(buttonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nButton.displayName = \"Button\"\n\nexport { Button, buttonVariants }\n", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Defines a reusable `Button` component with customizable variants and sizes.\n\n**Functionality:** Allows for dynamic styling and composition of buttons through a set of predefined variants, sizes, and classes. Can be used as either a standard button or a custom HTML element.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/button.tsx", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary:\n\n**Summary:**\n`button.tsx`: A reusable React button component with customizable styles, variants, and sizes that can be dynamically styled and composed for use in various contexts."}
{"code": "import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Card = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"rounded-lg border bg-card text-card-foreground shadow-sm\",\n      className\n    )}\n    {...props}\n  />\n))\nCard.displayName = \"Card\"\n\nconst CardHeader = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex flex-col space-y-1.5 p-6\", className)}\n    {...props}\n  />\n))\nCardHeader.displayName = \"CardHeader\"\n\nconst CardTitle = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLHeadingElement>\n>(({ className, ...props }, ref) => (\n  <h3\n    ref={ref}\n    className={cn(\n      \"text-2xl font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nCardTitle.displayName = \"CardTitle\"\n\nconst CardDescription = React.forwardRef<\n  HTMLParagraphElement,", "explanation": "Here is a concise summary:\n\n**Purpose:** A set of reusable UI components for rendering cards with various sections (header, title, description).\n\n**Functionality:**\n\n* `Card`: A base component for rendering a card container.\n* `CardHeader`: A component for the header section of the card.\n* `CardTitle` and `CardDescription`: Components for the title and description sections within the card.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/card.tsx", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary:\n\n**Summary:** The 'card.tsx' file defines reusable UI components for rendering cards, including `Card` base component, `CardHeader`, and various section components (`CardTitle`, `CardDescription`, etc.) that accept HTML attributes and render customizable HTML elements."}
{"code": "  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => (\n  <p\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nCardDescription.displayName = \"CardDescription\"\n\nconst CardContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />\n))\nCardContent.displayName = \"CardContent\"\n\nconst CardFooter = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex items-center p-6 pt-0\", className)}\n    {...props}\n  />\n))\nCardFooter.displayName = \"CardFooter\"\n\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }\n", "explanation": "Here is a concise summary:\n\nThis block defines React components for a card layout: `Card`, `CardHeader`, `CardContent`, `CardFooter`, `CardTitle`, and `CardDescription`. Each component accepts HTML attributes and renders corresponding HTML elements (e.g., `<p>`, `<div>`) with customizable classes.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/card.tsx", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary:\n\n**Summary:** The 'card.tsx' file defines reusable UI components for rendering cards, including `Card` base component, `CardHeader`, and various section components (`CardTitle`, `CardDescription`, etc.) that accept HTML attributes and render customizable HTML elements."}
{"code": "\"use client\"\n\nimport * as React from \"react\"\nimport * as CheckboxPrimitive from \"@radix-ui/react-checkbox\"\nimport { Check } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Checkbox = React.forwardRef<\n  React.ElementRef<typeof CheckboxPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <CheckboxPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\",\n      className\n    )}\n    {...props}\n  >\n    <CheckboxPrimitive.Indicator\n      className={cn(\"flex items-center justify-center text-current\")}\n    >\n      <Check className=\"h-4 w-4\" />\n    </CheckboxPrimitive.Indicator>\n  </CheckboxPrimitive.Root>\n))", "explanation": "**Summary:**\n\nThis block is a reusable React checkbox component that uses the `Radix UI` library for styling and functionality. It renders a customizable checkbox with a checkmark icon, allowing for dynamic state updates and accessibility features.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/checkbox.tsx", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'components/ui/checkbox.tsx':\n\nReusable React checkbox component with customizable styling and accessibility features using Radix UI library."}
{"code": "Checkbox.displayName = CheckboxPrimitive.Root.displayName\n\nexport { Checkbox }\n", "explanation": "**Summary:**\n\nThis block sets a display name for a \"Checkbox\" component by exporting it from another component, likely to ensure consistency in naming across different components.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/checkbox.tsx", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'components/ui/checkbox.tsx':\n\nReusable React checkbox component with customizable styling and accessibility features using Radix UI library."}
{"code": "\"use client\";\n\nimport * as CollapsiblePrimitive from \"@radix-ui/react-collapsible\";\n\nconst Collapsible = CollapsiblePrimitive.Root;\n\nconst CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger;\n\nconst CollapsibleContent = CollapsiblePrimitive.CollapsibleContent;\n\nexport { Collapsible, CollapsibleTrigger, CollapsibleContent };\n", "explanation": "This block imports and exports a collapsible UI component from Radix UI, making it reusable in other parts of an application.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/collapsible.tsx", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and to-the-point holistic summary:\n\n**Summary:** The `components/ui/collapsible.tsx` file provides a reusable collapsible UI component from Radix UI for use across the application."}
{"code": "import * as React from \"react\";\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\";\nimport { X } from \"lucide-react\";\n\nimport { cn } from \"@/lib/utils\";\n\nconst Dialog = DialogPrimitive.Root;\n\nconst DialogTrigger = DialogPrimitive.Trigger;\n\nconst DialogPortal = DialogPrimitive.Portal;\n\nconst DialogClose = DialogPrimitive.Close;\n\nconst DialogOverlay = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Overlay\n    ref={ref}\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className,\n    )}\n    {...props}\n  />\n));\nDialogOverlay.displayName = DialogPrimitive.Overlay.displayName;\n\nconst DialogContent = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** A reusable dialog component.\n\n**Functionality:** Provides a customizable overlay and content area for displaying modals, with animations and state management built-in. Can be triggered by a button or other UI element.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/dialog.tsx", "chunk_number": 1, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and holistic summary of the file 'components/ui/dialog.tsx':\n\nThis file exports a reusable dialog component that provides a customizable overlay and content area for displaying modals, including animations and state management. It defines several related components, such as `DialogTitle` and `DialogDescription`, `DialogHeader` and `DialogFooter`, and a close button with hover, focus, and disabled states."}
{"code": ">(({ className, children, ...props }, ref) => (\n  <DialogPortal>\n    <DialogOverlay />\n    <DialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className,\n      )}\n      {...props}\n    >\n      {children}", "explanation": "This block appears to be a React function component that renders a dialog window, comprising of:\n\n* A portal for the dialog\n* An overlay for background dimming\n* Content with customizable styles and props\n* Children elements (content) to be displayed within the dialog.\n\nIt uses CSS classes and utility functions (`cn` and `ref`) to manage its appearance and behavior.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/dialog.tsx", "chunk_number": 2, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and holistic summary of the file 'components/ui/dialog.tsx':\n\nThis file exports a reusable dialog component that provides a customizable overlay and content area for displaying modals, including animations and state management. It defines several related components, such as `DialogTitle` and `DialogDescription`, `DialogHeader` and `DialogFooter`, and a close button with hover, focus, and disabled states."}
{"code": "      <DialogPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </DialogPrimitive.Close>\n    </DialogPrimitive.Content>\n  </DialogPortal>\n));\nDialogContent.displayName = DialogPrimitive.Content.displayName;\n\nconst DialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-1.5 text-center sm:text-left\",\n      className,\n    )}\n    {...props}\n  />\n);\nDialogHeader.displayName = \"DialogHeader\";\n\nconst DialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className,\n    )}", "explanation": "Here is a concise summary:\n\n**This block:** \n\n* Represents a close button for a dialog component\n* Contains an X icon and a hidden \"Close\" text for accessibility\n* Has hover, focus, and disabled states defined via CSS classes\n\n**Related components:**\n\n* `DialogPrimitive.Content`: A content container for the dialog\n* `DialogHeader` and `DialogFooter`: Separate components for the header and footer of the dialog", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/dialog.tsx", "chunk_number": 3, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and holistic summary of the file 'components/ui/dialog.tsx':\n\nThis file exports a reusable dialog component that provides a customizable overlay and content area for displaying modals, including animations and state management. It defines several related components, such as `DialogTitle` and `DialogDescription`, `DialogHeader` and `DialogFooter`, and a close button with hover, focus, and disabled states."}
{"code": "    {...props}\n  />\n);\nDialogFooter.displayName = \"DialogFooter\";\n\nconst DialogTitle = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className,\n    )}\n    {...props}\n  />\n));\nDialogTitle.displayName = DialogPrimitive.Title.displayName;\n\nconst DialogDescription = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n));\nDialogDescription.displayName = DialogPrimitive.Description.displayName;\n\nexport {\n  Dialog,\n  DialogPortal,\n  DialogOverlay,\n  DialogClose,\n  DialogTrigger,\n  DialogContent,\n  DialogHeader,\n  DialogFooter,", "explanation": "Here is a concise summary of the purpose and functionality:\n\nThis block exports components for building dialogs, including title, description, header, footer, and trigger elements, which can be customized with props and CSS classes.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/dialog.tsx", "chunk_number": 4, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and holistic summary of the file 'components/ui/dialog.tsx':\n\nThis file exports a reusable dialog component that provides a customizable overlay and content area for displaying modals, including animations and state management. It defines several related components, such as `DialogTitle` and `DialogDescription`, `DialogHeader` and `DialogFooter`, and a close button with hover, focus, and disabled states."}
{"code": "  DialogTitle,\n  DialogDescription,\n};\n", "explanation": "This block appears to define a struct with two fields: `DialogTitle` and `DialogDescription`.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/dialog.tsx", "chunk_number": 5, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and holistic summary of the file 'components/ui/dialog.tsx':\n\nThis file exports a reusable dialog component that provides a customizable overlay and content area for displaying modals, including animations and state management. It defines several related components, such as `DialogTitle` and `DialogDescription`, `DialogHeader` and `DialogFooter`, and a close button with hover, focus, and disabled states."}
{"code": "\"use client\"\n\nimport * as React from \"react\"\nimport { OTPInput, OTPInputContext } from \"input-otp\"\nimport { Dot } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst InputOTP = React.forwardRef<\n  React.ElementRef<typeof OTPInput>,\n  React.ComponentPropsWithoutRef<typeof OTPInput>\n>(({ className, containerClassName, ...props }, ref) => (\n  <OTPInput\n    ref={ref}\n    containerClassName={cn(\n      \"flex items-center gap-2 has-[:disabled]:opacity-50\",\n      containerClassName\n    )}\n    className={cn(\"disabled:cursor-not-allowed\", className)}\n    {...props}\n  />\n))\nInputOTP.displayName = \"InputOTP\"\n\nconst InputOTPGroup = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\">\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"flex items-center\", className)} {...props} />\n))\nInputOTPGroup.displayName = \"InputOTPGroup\"\n\nconst InputOTPSlot = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\"> & { index: number }", "explanation": "Here is a concise summary:\n\nThis block defines three reusable UI components for displaying and inputting one-time passwords (OTPs):\n\n1. `InputOTP`: A single OTP input field with customizable styling.\n2. `InputOTPGroup`: A container component for grouping multiple OTP inputs together.\n3. `InputOTPSlot`: A slot component that can be used to render a single OTP input within a group.\n\nThese components are built using React and utilize the \"lucide-react\" library for icons and \"input-otp\" library for OTP functionality.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/input-otp.tsx", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'components/ui/input-otp.tsx':\n\nThis file exports three reusable OTP input components: `InputOTP`, `InputOTPGroup`, and `InputOTPSeparator`. They are designed for displaying and inputting one-time passwords, utilizing React and libraries like \"lucide-react\" and \"input-otp\"."}
{"code": ">(({ index, className, ...props }, ref) => {\n  const inputOTPContext = React.useContext(OTPInputContext)\n  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]\n\n  return (\n    <div\n      ref={ref}\n      className={cn(\n        \"relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md\",\n        isActive && \"z-10 ring-2 ring-ring ring-offset-background\",\n        className\n      )}\n      {...props}\n    >\n      {char}\n      {hasFakeCaret && (\n        <div className=\"pointer-events-none absolute inset-0 flex items-center justify-center\">\n          <div className=\"h-4 w-px animate-caret-blink bg-foreground duration-1000\" />\n        </div>\n      )}\n    </div>\n  )\n})\nInputOTPSlot.displayName = \"InputOTPSlot\"\n\nconst InputOTPSeparator = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\">\n>(({ ...props }, ref) => (\n  <div ref={ref} role=\"separator\" {...props}>\n    <Dot />", "explanation": "**Summary**\n\nThis block appears to be a React component, specifically a slot for an OTP (One-Time Password) input field. It renders a single character or separator within the input field.\n\n* `InputOTPSlot`: A React component that renders a single character in an OTP input field.\n* `InputOTPSeparator`: A React component that renders a visual separator between two characters in an OTP input field, represented by a `Dot` element.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/input-otp.tsx", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'components/ui/input-otp.tsx':\n\nThis file exports three reusable OTP input components: `InputOTP`, `InputOTPGroup`, and `InputOTPSeparator`. They are designed for displaying and inputting one-time passwords, utilizing React and libraries like \"lucide-react\" and \"input-otp\"."}
{"code": "  </div>\n))\nInputOTPSeparator.displayName = \"InputOTPSeparator\"\n\nexport { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }\n", "explanation": "This block exports three components: `InputOTP`, `InputOTPGroup`, and `InputOTPSeparator`. It defines a display name for `InputOTPSeparator` but does not provide further functionality details.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/input-otp.tsx", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'components/ui/input-otp.tsx':\n\nThis file exports three reusable OTP input components: `InputOTP`, `InputOTPGroup`, and `InputOTPSeparator`. They are designed for displaying and inputting one-time passwords, utilizing React and libraries like \"lucide-react\" and \"input-otp\"."}
{"code": "import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport interface InputProps\n  extends React.InputHTMLAttributes<HTMLInputElement> {}\n\nconst Input = React.forwardRef<HTMLInputElement, InputProps>(\n  ({ className, type, ...props }, ref) => {\n    return (\n      <input\n        type={type}\n        className={cn(\n          \"flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nInput.displayName = \"Input\"\n\nexport { Input }\n", "explanation": "This block is a React input field component:\n\n* It accepts various props (e.g., type, className) from its users.\n* It renders an HTML input element with customized styles.\n* It supports forward refs for accessibility.\n* It can be used in React applications as a reusable input field component.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/input.tsx", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise holistic summary of the file 'components/ui/input.tsx':\n\n**Reusable Input Field Component**\n\nA customizable React input field that accepts various props, renders an HTML input element with styled appearance, supports accessibility through forward refs, and can be easily integrated into React applications as a reusable component."}
{"code": "import * as React from \"react\";\nimport * as LabelPrimitive from \"@radix-ui/react-label\";\nimport { cva, type VariantProps } from \"class-variance-authority\";\n\nimport { cn } from \"@/lib/utils\";\n\nconst labelVariants = cva(\n  \"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\",\n);\n\nconst Label = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &\n    VariantProps<typeof labelVariants>\n>(({ className, ...props }, ref) => (\n  <LabelPrimitive.Root\n    ref={ref}\n    className={cn(labelVariants(), className)}\n    {...props}\n  />\n));\nLabel.displayName = LabelPrimitive.Root.displayName;\n\nexport { Label };\n", "explanation": "Here is a summary of the block:\n\n**Purpose:** A reusable label component.\n\n**Functionality:** A customizable text label that can be styled with variant props, with features such as disabled state indication and peer interaction.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/label.tsx", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and holistic summary of the file 'components/ui/label.tsx':\n\n\"A customizable, reusable label component for displaying text, supporting variant styles, disabled state indication, and interactive peer functionality.\""}
{"code": "\"use client\"\n\nimport * as React from \"react\"\nimport * as ScrollAreaPrimitive from \"@radix-ui/react-scroll-area\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ScrollArea = React.forwardRef<\n  React.ElementRef<typeof ScrollAreaPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>\n>(({ className, children, ...props }, ref) => (\n  <ScrollAreaPrimitive.Root\n    ref={ref}\n    className={cn(\"relative overflow-hidden\", className)}\n    {...props}\n  >\n    <ScrollAreaPrimitive.Viewport className=\"h-full w-full rounded-[inherit]\">\n      {children}\n    </ScrollAreaPrimitive.Viewport>\n    <ScrollBar />\n    <ScrollAreaPrimitive.Corner />\n  </ScrollAreaPrimitive.Root>\n))\nScrollArea.displayName = ScrollAreaPrimitive.Root.displayName\n\nconst ScrollBar = React.forwardRef<\n  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>\n>(({ className, orientation = \"vertical\", ...props }, ref) => (", "explanation": "Here is a concise summary:\n\n**Purpose:** A reusable scroll area component with a scrollbar.\n\n**Functionality:** Provides a container for content that can be scrolled, along with a customizable scrollbar.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/scroll-area.tsx", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise holistic summary of the file 'components/ui/scroll-area.tsx':\n\n**Reusable Scroll Area Component:** A customizable container for scrollable content with a scrollbar that allows user interaction."}
{"code": "  <ScrollAreaPrimitive.ScrollAreaScrollbar\n    ref={ref}\n    orientation={orientation}\n    className={cn(\n      \"flex touch-none select-none transition-colors\",\n      orientation === \"vertical\" &&\n        \"h-full w-2.5 border-l border-l-transparent p-[1px]\",\n      orientation === \"horizontal\" &&\n        \"h-2.5 flex-col border-t border-t-transparent p-[1px]\",\n      className\n    )}\n    {...props}\n  >\n    <ScrollAreaPrimitive.ScrollAreaThumb className=\"relative flex-1 rounded-full bg-border\" />\n  </ScrollAreaPrimitive.ScrollAreaScrollbar>\n))\nScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName\n\nexport { ScrollArea, ScrollBar }\n", "explanation": "Here is a concise summary:\n\nThis block renders a customizable scroll bar component with a thumb, allowing users to interact with scroll areas in an application.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/scroll-area.tsx", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise holistic summary of the file 'components/ui/scroll-area.tsx':\n\n**Reusable Scroll Area Component:** A customizable container for scrollable content with a scrollbar that allows user interaction."}
{"code": "import * as React from \"react\";\nimport * as SelectPrimitive from \"@radix-ui/react-select\";\nimport { Check, ChevronDown, ChevronUp } from \"lucide-react\";\n\nimport { cn } from \"@/lib/utils\";\n\nconst Select = SelectPrimitive.Root;\n\nconst SelectGroup = SelectPrimitive.Group;\n\nconst SelectValue = SelectPrimitive.Value;\n\nconst SelectTrigger = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1\",\n      className,\n    )}\n    {...props}\n  >\n    {children}\n    <SelectPrimitive.Icon asChild>", "explanation": "**Summary:** This block imports a customizable select component from `@radix-ui/react-select` and defines a reusable `Select` component with various props, styles, and icons. It appears to be a React library or module that can be used to create interactive dropdown selects in applications.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/select.tsx", "chunk_number": 1, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and holistic summary of the file 'components/ui/select.tsx':\n\nThis file defines reusable UI components for creating interactive dropdown selects, including a customizable select trigger, scrolling buttons, and item components with optional checkmarks. It uses React's forwardRef and displayName properties to ensure proper rendering and debugging. The components can be styled and customized via classes and props, making them suitable for use in application development."}
{"code": "      <ChevronDown className=\"h-4 w-4 opacity-50\" />\n    </SelectPrimitive.Icon>\n  </SelectPrimitive.Trigger>\n));\nSelectTrigger.displayName = SelectPrimitive.Trigger.displayName;\n\nconst SelectScrollUpButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollUpButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className,\n    )}\n    {...props}\n  >\n    <ChevronUp className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollUpButton>\n));\nSelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;\n\nconst SelectScrollDownButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollDownButton\n    ref={ref}\n    className={cn(", "explanation": "Here is a concise summary:\n\nThis block defines three UI components: `SelectTrigger`, `SelectScrollUpButton`, and `SelectScrollDownButton`. They are custom buttons for scrolling up/down and triggering actions within a select dropdown, utilizing React and a primitive component called `SelectPrimitive`.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/select.tsx", "chunk_number": 2, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and holistic summary of the file 'components/ui/select.tsx':\n\nThis file defines reusable UI components for creating interactive dropdown selects, including a customizable select trigger, scrolling buttons, and item components with optional checkmarks. It uses React's forwardRef and displayName properties to ensure proper rendering and debugging. The components can be styled and customized via classes and props, making them suitable for use in application development."}
{"code": "      \"flex cursor-default items-center justify-center py-1\",\n      className,\n    )}\n    {...props}\n  >\n    <ChevronDown className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollDownButton>\n));\nSelectScrollDownButton.displayName =\n  SelectPrimitive.ScrollDownButton.displayName;\n\nconst SelectContent = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>\n>(({ className, children, position = \"popper\", ...props }, ref) => (\n  <SelectPrimitive.Portal>\n    <SelectPrimitive.Content\n      ref={ref}\n      className={cn(", "explanation": "Here is a summary of the purpose and functionality:\n\n**Purpose:** A scroll down button component for a select menu.\n\n**Functionality:** Displays an arrow icon that allows scrolling down in a dropdown list, with customizable styles via classes.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/select.tsx", "chunk_number": 3, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and holistic summary of the file 'components/ui/select.tsx':\n\nThis file defines reusable UI components for creating interactive dropdown selects, including a customizable select trigger, scrolling buttons, and item components with optional checkmarks. It uses React's forwardRef and displayName properties to ensure proper rendering and debugging. The components can be styled and customized via classes and props, making them suitable for use in application development."}
{"code": "        \"relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        position === \"popper\" &&\n          \"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1\",\n        className,\n      )}\n      position={position}\n      {...props}\n    >\n      <SelectScrollUpButton />\n      <SelectPrimitive.Viewport\n        className={cn(\n          \"p-1\",\n          position === \"popper\" &&\n            \"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]\",\n        )}\n      >\n        {children}", "explanation": "This block is a styled component that serves as a container for a dropdown menu or popover, with various animations and transitions based on its state (open/closed) and position (top, bottom, left, right).", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/select.tsx", "chunk_number": 4, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and holistic summary of the file 'components/ui/select.tsx':\n\nThis file defines reusable UI components for creating interactive dropdown selects, including a customizable select trigger, scrolling buttons, and item components with optional checkmarks. It uses React's forwardRef and displayName properties to ensure proper rendering and debugging. The components can be styled and customized via classes and props, making them suitable for use in application development."}
{"code": "      </SelectPrimitive.Viewport>\n      <SelectScrollDownButton />\n    </SelectPrimitive.Content>\n  </SelectPrimitive.Portal>\n));\nSelectContent.displayName = SelectPrimitive.Content.displayName;\n\nconst SelectLabel = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Label\n    ref={ref}\n    className={cn(\"py-1.5 pl-8 pr-2 text-sm font-semibold\", className)}\n    {...props}\n  />\n));\nSelectLabel.displayName = SelectPrimitive.Label.displayName;\n\nconst SelectItem = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Item\n    ref={ref}\n    className={cn(", "explanation": "Here is a concise summary:\n\nThis block defines a custom component for selecting content, likely in a dropdown menu context. It includes:\n\n* A scrolling viewport for displaying selected items\n* An \"Scroll Down\" button for expanding the selection list\n* Custom label and item components for styling and rendering selected options.\n\nIt utilizes React's forwardRef and displayName properties to ensure proper rendering and debugging of these custom components.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/select.tsx", "chunk_number": 5, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and holistic summary of the file 'components/ui/select.tsx':\n\nThis file defines reusable UI components for creating interactive dropdown selects, including a customizable select trigger, scrolling buttons, and item components with optional checkmarks. It uses React's forwardRef and displayName properties to ensure proper rendering and debugging. The components can be styled and customized via classes and props, making them suitable for use in application development."}
{"code": "      \"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className,\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <SelectPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </SelectPrimitive.ItemIndicator>\n    </span>\n\n    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\n  </SelectPrimitive.Item>\n));\nSelectItem.displayName = SelectPrimitive.Item.displayName;\n\nconst SelectSeparator = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n));", "explanation": "Here is a concise summary:\n\n**Block Purpose:** A reusable item component for dropdowns/select menus.\n\n**Functionality:** Displays a customizable item with an optional checkmark indicator and allows selection/disabling via props.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/select.tsx", "chunk_number": 6, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and holistic summary of the file 'components/ui/select.tsx':\n\nThis file defines reusable UI components for creating interactive dropdown selects, including a customizable select trigger, scrolling buttons, and item components with optional checkmarks. It uses React's forwardRef and displayName properties to ensure proper rendering and debugging. The components can be styled and customized via classes and props, making them suitable for use in application development."}
{"code": "SelectSeparator.displayName = SelectPrimitive.Separator.displayName;\n\nexport {\n  Select,\n  SelectGroup,\n  SelectValue,\n  SelectTrigger,\n  SelectContent,\n  SelectLabel,\n  SelectItem,\n  SelectSeparator,\n  SelectScrollUpButton,\n  SelectScrollDownButton,\n};\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Exporting UI components for a select dropdown functionality.\n\n**Functionality:** Reassigns display name of \"SelectSeparator\" component and exports multiple related UI components.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/select.tsx", "chunk_number": 7, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and holistic summary of the file 'components/ui/select.tsx':\n\nThis file defines reusable UI components for creating interactive dropdown selects, including a customizable select trigger, scrolling buttons, and item components with optional checkmarks. It uses React's forwardRef and displayName properties to ensure proper rendering and debugging. The components can be styled and customized via classes and props, making them suitable for use in application development."}
{"code": "\"use client\"\n\nimport { useTheme } from \"next-themes\"\nimport { Toaster as Sonner } from \"sonner\"\n\ntype ToasterProps = React.ComponentProps<typeof Sonner>\n\nconst Toaster = ({ ...props }: ToasterProps) => {\n  const { theme = \"system\" } = useTheme()\n\n  return (\n    <Sonner\n      theme={theme as ToasterProps[\"theme\"]}\n      className=\"toaster group\"\n      toastOptions={{\n        classNames: {\n          toast:\n            \"group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg\",\n          description: \"group-[.toast]:text-muted-foreground\",\n          actionButton:\n            \"group-[.toast]:bg-primary group-[.toast]:text-primary-foreground\",\n          cancelButton:\n            \"group-[.toast]:bg-muted group-[.toast]:text-muted-foreground\",\n        },\n      }}\n      {...props}\n    />\n  )\n}\n\nexport { Toaster }\n", "explanation": "Here is a concise summary of the block:\n\n**Purpose:** A reusable React component (Toaster) that integrates with Next.js themes using `useTheme` from \"next-themes\".\n\n**Functionality:** Displays a customizable toast notification bar with styling options based on the active theme.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/sonner.tsx", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'components/ui/sonnet.tsx' in 2-3 sentences:\n\nThe `Toaster` component integrates with Next.js themes, providing a customizable toast notification bar with styling options that adapt to the active theme. This reusable React component offers flexibility and consistency across different themes, enhancing user experience through tailored visualizations."}
{"code": "import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Table = React.forwardRef<\n  HTMLTableElement,\n  React.HTMLAttributes<HTMLTableElement>\n>(({ className, ...props }, ref) => (\n  <div className=\"relative w-full overflow-auto\">\n    <table\n      ref={ref}\n      className={cn(\"w-full caption-bottom text-sm\", className)}\n      {...props}\n    />\n  </div>\n))\nTable.displayName = \"Table\"\n\nconst TableHeader = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <thead ref={ref} className={cn(\"[&_tr]:border-b\", className)} {...props} />\n))\nTableHeader.displayName = \"TableHeader\"\n\nconst TableBody = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tbody\n    ref={ref}\n    className={cn(\"[&_tr:last-child]:border-0\", className)}\n    {...props}\n  />\n))\nTableBody.displayName = \"TableBody\"\n\nconst TableFooter = React.forwardRef<\n  HTMLTableSectionElement,", "explanation": "**Summary:**\n\nThis block is a set of reusable React components for creating tables. It includes:\n\n* `Table`: A container component that wraps a table element.\n* `TableHeader`, `TableBody`, and `TableFooter`: Components that represent different sections of a table.\n\nThese components provide a way to easily create and customize tables in a React application, with features such as responsive design and customizable styles.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/table.tsx", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'components/ui/table.tsx':\n\n**Summary:** \n\nA set of reusable React components for creating customizable tables, providing standard styling and behavior in a React application."}
{"code": "  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tfoot\n    ref={ref}\n    className={cn(\n      \"border-t bg-muted/50 font-medium [&>tr]:last:border-b-0\",\n      className\n    )}\n    {...props}\n  />\n))\nTableFooter.displayName = \"TableFooter\"\n\nconst TableRow = React.forwardRef<\n  HTMLTableRowElement,\n  React.HTMLAttributes<HTMLTableRowElement>\n>(({ className, ...props }, ref) => (\n  <tr\n    ref={ref}\n    className={cn(\n      \"border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted\",\n      className\n    )}\n    {...props}\n  />\n))\nTableRow.displayName = \"TableRow\"\n\nconst TableHead = React.forwardRef<\n  HTMLTableCellElement,\n  React.ThHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <th\n    ref={ref}\n    className={cn(\n      \"h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0\",\n      className\n    )}\n    {...props}\n  />\n))\nTableHead.displayName = \"TableHead\"\n\nconst TableCell = React.forwardRef<", "explanation": "Here is a concise summary:\n\n**Functionality:** A set of reusable, customizable table component functions (TableFooter, TableRow, TableHead, TableCell).\n\n**Purpose:** To facilitate easy creation of tables with standard styling and behavior in a React application.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/table.tsx", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'components/ui/table.tsx':\n\n**Summary:** \n\nA set of reusable React components for creating customizable tables, providing standard styling and behavior in a React application."}
{"code": "  HTMLTableCellElement,\n  React.TdHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <td\n    ref={ref}\n    className={cn(\"p-4 align-middle [&:has([role=checkbox])]:pr-0\", className)}\n    {...props}\n  />\n))\nTableCell.displayName = \"TableCell\"\n\nconst TableCaption = React.forwardRef<\n  HTMLTableCaptionElement,\n  React.HTMLAttributes<HTMLTableCaptionElement>\n>(({ className, ...props }, ref) => (\n  <caption\n    ref={ref}\n    className={cn(\"mt-4 text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nTableCaption.displayName = \"TableCaption\"\n\nexport {\n  Table,\n  TableHeader,\n  TableBody,\n  TableFooter,\n  TableHead,\n  TableRow,\n  TableCell,\n  TableCaption,\n}\n", "explanation": "Here is a concise summary:\n\nThis block defines React components for a table, including cells, captions, and other elements. It provides functional components for building tables with customized styles and attributes.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/table.tsx", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'components/ui/table.tsx':\n\n**Summary:** \n\nA set of reusable React components for creating customizable tables, providing standard styling and behavior in a React application."}
{"code": "import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport interface TextareaProps\n  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}\n\nconst Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(\n  ({ className, ...props }, ref) => {\n    return (\n      <textarea\n        className={cn(\n          \"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nTextarea.displayName = \"Textarea\"\n\nexport { Textarea }\n", "explanation": "**Summary**\n\nA React component (`Textarea`) that renders a customizable text area input field, with a set of default styles that can be overridden by a `className` prop.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "components/ui/textarea.tsx", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and to-the-point summary:\n\n\"The Textarea component: A customizable text area input field with overrideable default styles.\""}
{"code": "export const MODELS = {\n  openai: [\"gpt-4o-mini\", \"gpt-4o\", \"gpt-4o-2024-08-06\", \"gpt-4o-latest\"],\n  // together: [\n  //   \"meta-llama/Meta-Llama-3.1-8B-Instruct-Turbo\",\n  //   \"meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo\",\n  //   \"meta-llama/Meta-Llama-3.1-405B-Instruct-Turbo\",\n  // ],\n  // ollama: [\"mistral\", \"llama3.1\"],\n  // fireworks: [\n  //   \"accounts/fireworks/models/llama-v3p1-8b-instruct\",\n  //   \"accounts/fireworks/models/llama-v3p1-70b-instruct\",\n  //   \"accounts/fireworks/models/llama-v3p1-405b-instruct\",\n  //   \"accounts/fireworks/models/mixtral-8x22b-instruct\",\n  //   \"accounts/fireworks/models/firefunction-v1\",\n  // ],\n};\n\nexport const CHAINS = {\n  11155111: {\n    name: \"ETH Sepolia\",\n    explorerURI: \"https://sepolia.etherscan.io/tx/\",\n    rpcURI: \"https://eth-sepolia.g.alchemy.com/v2/\",\n  },\n  1: {\n    name: \"ETH Mainnet\",\n    explorerURI: \"https://etherscan.io/tx/\",\n    rpcURI: \"https://eth-mainnet.g.alchemy.com/v2/\",\n  },\n  137: {\n    name: \"POLY Mainnet\",", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Define constants for models and chains used in an application.\n\n**Functionality:** Export two objects, `MODELS` and `CHAINS`, containing lists of model IDs and blockchain chain configurations respectively, with properties such as name, explorer URI, and RPC URI.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "constants/index.ts", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'constants/index.ts':\n\n**Summary:** Defines constants for models and chains used in an application, exporting objects `MODELS` and `CHAINS` with configurations for two Polygon blockchain nodes."}
{"code": "    explorerURI: \"https://polygonscan.com/tx/\",\n    rpcURI: \"https://polygon-mainnet.g.alchemy.com/v2/\",\n  },\n  80002: {\n    name: \"POLY Amoy\",\n    explorerURI: \"https://amoy.polygonscan.com/tx/\",\n    rpcURI: \"https://polygon-amoy.g.alchemy.com/v2/\",\n  },\n};\n", "explanation": "This block defines API configurations for two Polygon blockchain nodes:\n\n* Provides links to explorers (https) and RPC APIs (https) for nodes with chain IDs \"0\" and \"80002\".", "metadata": {"repo": "magiclabs/hiro-chat", "file": "constants/index.ts", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'constants/index.ts':\n\n**Summary:** Defines constants for models and chains used in an application, exporting objects `MODELS` and `CHAINS` with configurations for two Polygon blockchain nodes."}
{"code": "import { type ClassValue, clsx } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n", "explanation": "This block defines a function `cn` that concatenates CSS class strings using `clsx` and merges them into a single string with Tailwind's `twMerge`.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "lib/utils.ts", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'lib/utils.ts':\n\n\"Utility functions for concatenating and merging CSS class strings using clsx and twMerge.\""}
{"code": "const withBundleAnalyzer = require('@next/bundle-analyzer')({\n  enabled: process.env.ANALYZE === 'true',\n})\nmodule.exports = withBundleAnalyzer({})", "explanation": "**Purpose:** Enables bundle analysis for Next.js applications.\n\n**Functionality:** Conditionally enables code splitting analysis using `@next/bundle-analyzer` based on an environment variable `ANALYZE`.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "next.config.js", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and to-the-point summary:\n\n`next.config.js`: Enables bundle analysis for Next.js apps, conditionally using `@next/bundle-analyzer` based on `ANALYZE` env var."}
{"code": "diff --git a/node_modules/polygonscan-api/lib/get-request.js b/node_modules/polygonscan-api/lib/get-request.js\nindex be397d5..8d0cd9d 100755\n--- a/node_modules/polygonscan-api/lib/get-request.js\n+++ b/node_modules/polygonscan-api/lib/get-request.js\n@@ -15,7 +15,7 @@ function pickChainUrl(chain) {\n \n const MAIN_API_URL = 'https://api.polygonscan.com';\n const TESTNET_API_URL_MAP = {\n-  mumbai: 'https://api-testnet.polygonscan.com',\n+  amoy: 'https://api-amoy.polygonscan.com',\n };\n \n module.exports = function(chain, timeout) {\n", "explanation": "**Purpose:** A JavaScript file for making API requests to PolygonScan.\n\n**Functionality:** Exports a function to generate API URLs based on the specified chain (mainnet or testnet), allowing users to retrieve data from the PolygonScan API.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "patches/polygonscan-api+1.0.4.patch", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and holistic summary of the file 'patches/polygonscan-api+1.0.4.patch':\n\n**File Summary:** A JavaScript patch for generating PolygonScan API URLs, enabling users to fetch data from PolygonScan's mainnet or testnet API."}
{"code": "module.exports = {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n", "explanation": "This block exports a configuration object for a JavaScript module, specifying two plugins:\n\n* `tailwindcss` for styling with Tailwind CSS\n* `autoprefixer` for auto-adding browser prefixes", "metadata": {"repo": "magiclabs/hiro-chat", "file": "postcss.config.js", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'postcss.config.js':\n\n**postcss.config.js**\nConfigure PostCSS with Tailwind CSS and Autoprefixer plugins.\n\nThis configuration enables styling with Tailwind CSS and automatically adds browser prefixes using Autoprefixer."}
{"code": "import type { Config } from \"tailwindcss\"\n\nconst config = {\n  darkMode: [\"class\"],\n  content: [\n    './pages/**/*.{ts,tsx}',\n    './components/**/*.{ts,tsx}',\n    './app/**/*.{ts,tsx}',\n    './src/**/*.{ts,tsx}',\n\t],\n  prefix: \"\",\n  theme: {\n    container: {\n      center: true,\n      padding: \"2rem\",\n      screens: {\n        \"2xl\": \"1400px\",\n      },\n    },\n    extend: {\n      colors: {\n        border: \"hsl(var(--border))\",\n        input: \"hsl(var(--input))\",\n        ring: \"hsl(var(--ring))\",\n        background: \"hsl(var(--background))\",\n        foreground: \"hsl(var(--foreground))\",\n        primary: {\n          DEFAULT: \"hsl(var(--primary))\",\n          foreground: \"hsl(var(--primary-foreground))\",\n        },\n        secondary: {\n          DEFAULT: \"hsl(var(--secondary))\",\n          foreground: \"hsl(var(--secondary-foreground))\",\n        },\n        destructive: {\n          DEFAULT: \"hsl(var(--destructive))\",\n          foreground: \"hsl(var(--destructive-foreground))\",\n        },\n        muted: {", "explanation": "This block is a Tailwind CSS configuration file, defining:\n\n* Dark mode settings\n* File inclusion patterns for utility classes\n* Custom theme styles, including colors, spacing, and typography.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "tailwind.config.ts", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'tailwind.config.ts':\n\nThis Tailwind CSS configuration file defines theme styles, dark mode settings, utility class patterns, and animation plugins for various UI components."}
{"code": "          DEFAULT: \"hsl(var(--muted))\",\n          foreground: \"hsl(var(--muted-foreground))\",\n        },\n        accent: {\n          DEFAULT: \"hsl(var(--accent))\",\n          foreground: \"hsl(var(--accent-foreground))\",\n        },\n        popover: {\n          DEFAULT: \"hsl(var(--popover))\",\n          foreground: \"hsl(var(--popover-foreground))\",\n        },\n        card: {\n          DEFAULT: \"hsl(var(--card))\",\n          foreground: \"hsl(var(--card-foreground))\",\n        },\n      },\n      borderRadius: {\n        lg: \"var(--radius)\",\n        md: \"calc(var(--radius) - 2px)\",\n        sm: \"calc(var(--radius) - 4px)\",\n      },\n      keyframes: {\n        \"accordion-down\": {\n          from: { height: \"0\" },\n          to: { height: \"var(--radix-accordion-content-height)\" },\n        },\n        \"accordion-up\": {\n          from: { height: \"var(--radix-accordion-content-height)\" },\n          to: { height: \"0\" },\n        },\n      },\n      animation: {\n        \"accordion-down\": \"accordion-down 0.2s ease-out\",", "explanation": "**Summary:**\n\nThis block defines a set of styles and animations for various UI components, including colors, borders, and accordion effects.\n\n**Key Features:**\n\n* Color schemes (muted, accent, popover, card) with foreground and background colors\n* Border radius sizes (lg, md, sm)\n* Keyframe animations for accordion effects (down and up)\n* Animation definitions for the accordion effects", "metadata": {"repo": "magiclabs/hiro-chat", "file": "tailwind.config.ts", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'tailwind.config.ts':\n\nThis Tailwind CSS configuration file defines theme styles, dark mode settings, utility class patterns, and animation plugins for various UI components."}
{"code": "        \"accordion-up\": \"accordion-up 0.2s ease-out\",\n      },\n    },\n  },\n  plugins: [require(\"tailwindcss-animate\")],\n} satisfies Config\n\nexport default config", "explanation": "This block defines a Tailwind CSS configuration with an animation plugin.\n\nIn more detail, it:\n\n* Specifies an animation duration for \"accordion-up\" events (i.e., when an accordion expands)\n* Imports an animation plugin (tailwindcss-animate)", "metadata": {"repo": "magiclabs/hiro-chat", "file": "tailwind.config.ts", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'tailwind.config.ts':\n\nThis Tailwind CSS configuration file defines theme styles, dark mode settings, utility class patterns, and animation plugins for various UI components."}
{"code": "{\n  \"compilerOptions\": {\n    \"target\": \"esnext\",\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"strict\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"noEmit\": true,\n    \"esModuleInterop\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"bundler\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"jsx\": \"preserve\",\n    \"incremental\": true,\n    \"plugins\": [\n      {\n        \"name\": \"next\"\n      }\n    ],\n    \"paths\": {\n      \"@/*\": [\"./*\"]\n    }\n  },\n  \"include\": [\"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\", \".next/types/**/*.ts\"],\n  \"exclude\": [\"node_modules\"]\n}\n", "explanation": "This block appears to be a configuration file for a TypeScript compiler, specifically targeting Next.js projects. Its purpose is to define settings for compiling TypeScript code into JavaScript. Key functionality includes:\n\n* Setting up TypeScript targets and libraries\n* Enabling specific features like ES6+ support and JSX preservation\n* Specifying directories to include or exclude from compilation\n\nIn short, it's a configuration block that sets up the environment for compiling TypeScript code in a Next.js project.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "tsconfig.json", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'tsconfig.json':\n\n**tsconfig.json**: A configuration file for compiling TypeScript code into JavaScript, specifically targeting Next.js projects, defining targets, libraries, features, and directory settings."}
{"code": "import { CHAINS, MODELS } from \"./constants\";\n\nexport type ChainIdEnum = keyof typeof CHAINS;\n\nexport type InferenceEnum = keyof typeof MODELS;\n\nexport type IContract = {\n  key: number;\n  address: string;\n  name: string;\n  description?: string;\n  context: string;\n  chainId: ChainIdEnum;\n  abi?: AbiFunction[];\n  abiDescriptions?: IABIFunctionDescription[];\n};\n\nexport type IABIFunctionDescription = {\n  name: string;\n  description: string;\n  valueDescription: string;\n  inputs: { name: string; description: string }[];\n};\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Defines data types for blockchain contracts.\n\n**Functionality:** Exports enumerations (ChainIdEnum, InferenceEnum) and interface types (IContract, IABIFunctionDescription) for working with contract data, including key-value pairs and ABI descriptions.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "types.d.ts", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise holistic summary of the file 'types.d.ts':\n\n**Summary:** Defines data types for blockchain contracts, exporting enumerations and interface types for working with contract data and ABI descriptions."}
{"code": "// @ts-ignore\nimport Etherscan from \"etherscan-api\";\nimport { ChainIdEnum } from \"@/types\";\nimport { AbiFunction } from \"abitype\";\n\nexport const getABIFromEtherscan = async (\n  contractAddress: string,\n  chainId: ChainIdEnum,\n) => {\n  if (!etherscanChains[chainId]) {\n    throw new Error(\"Contract network not supported\");\n  }\n\n  if (!process.env.ETHERSCAN_API_KEY) {\n    throw new Error(\"Missing ETHERSCAN_API_KEY\");\n  }\n\n  const api = Etherscan.init(\n    process.env.ETHERSCAN_API_KEY,\n    etherscanChains[chainId],\n  );\n\n  const response = await api.contract.getabi(contractAddress);\n  if (response.status !== \"1\") {\n    throw new Error(`Failed to fetch ABI: ${response.result}`);\n  }\n\n  return JSON.parse(response.result) as AbiFunction[];\n};\n\nexport const etherscanChains: Record<number, string> = {\n  11155111: \"sepolia\",\n  1: \"mainnet\",\n};\n", "explanation": "Here is a summary of the block:\n\n**Purpose:** Fetches contract ABI from Etherscan API.\n\n**Functionality:** Takes a contract address and chain ID as input, uses Etherscan API to retrieve ABI, and returns it in JSON format.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/abi/etherscan.ts", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and to-the-point summary of the file 'utils/abi/etherscan.ts':\n\n\"Fetches contract ABI from Etherscan API using a contract address and chain ID as input.\""}
{"code": "import { KVCache } from \"@/utils/kv/kvCache\";\nimport { ChainIdEnum } from \"@/types\";\nimport { AbiFunction } from \"abitype\";\nimport { polygonscanChains, getABIFromPolygonscan } from \"./polygonscan\";\nimport { etherscanChains, getABIFromEtherscan } from \"./etherscan\";\n\n// ca = contract address\nconst cache = new KVCache<AbiFunction[]>(\"ca:\");\n\nexport const getAbi = async function (\n  contractAddress: string,\n  chainId: ChainIdEnum,\n): Promise<AbiFunction[]> {\n  const key = `${contractAddress}-${chainId}`;\n  const currentCache = await cache.get(key);\n\n  // Check if ABI is already in cache\n  if (currentCache) {\n    return currentCache;\n  }\n\n  let abi: AbiFunction[] = [];\n  if (etherscanChains[chainId]) {\n    abi = await getABIFromEtherscan(contractAddress, chainId);\n  }\n\n  if (polygonscanChains[chainId]) {\n    abi = await getABIFromPolygonscan(contractAddress, chainId);\n  }\n\n  if (abi.length > 0) {\n    await cache.set(key, abi);\n  }\n\n  return abi;\n};\n", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Retrieves contract ABI (Application Binary Interface) data from cached or API sources.\n\n**Functionality:** Caches contract ABIs for efficient retrieval, fetching from Etherscan or PolygonScan APIs when not available in cache.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/abi/index.ts", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'utils/abi/index.ts':\n\nThis module retrieves and caches Contract ABI data from both local storage and external APIs (Etherscan/PolygonScan), providing efficient access to ABIs for various contracts."}
{"code": "// @ts-ignore\nimport Polygonscan from \"polygonscan-api\";\nimport { ChainIdEnum } from \"@/types\";\nimport { AbiFunction } from \"abitype\";\n\nexport const getABIFromPolygonscan = async (\n  contractAddress: string,\n  chainId: ChainIdEnum,\n) => {\n  if (!polygonscanChains[chainId]) {\n    throw new Error(\"Contract network not supported\");\n  }\n\n  if (!process.env.POLYGONSCAN_API_KEY) {\n    throw new Error(\"Missing POLYGONSCAN_API_KEY\");\n  }\n\n  const api = Polygonscan.init(\n    process.env.POLYGONSCAN_API_KEY,\n    polygonscanChains[chainId],\n  );\n\n  const response = await api.contract.getabi(contractAddress);\n  if (response.status !== \"1\") {\n    throw new Error(`Failed to fetch ABI: ${response.result}`);\n  }\n\n  try {\n    return JSON.parse(response.result[0].ABI) as AbiFunction[];\n  } catch (e) {}\n  return [];\n};\n\nexport const polygonscanChains: Record<number, string> = {\n  137: \"mainnet\",\n  80002: \"amoy\",\n};\n", "explanation": "Here is a concise summary:\n\n**Purpose:** Fetches ABI data for a contract from Polygonscan API.\n\n**Functionality:** Takes a contract address and chain ID as input, initiates a Polygonscan API request, and returns an array of ABI functions if successful, or an empty array otherwise.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/abi/polygonscan.ts", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary:\n\n`polygonscan.ts`: Fetches contract ABI data from Polygonscan API, returning an array of functions for a given contract address and chain ID on success, or an empty array otherwise."}
{"code": "export class TransactionError extends Error {\n  constructor(\n    message: string,\n    public context?: any,\n  ) {\n    super(message);\n    this.name = \"TransactionError\";\n    if (context) {\n      console.error(\"Error Context:\", context);\n    }\n  }\n}\n\nexport class NetworkError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"NetworkError\";\n  }\n}\n\nexport class SigningError extends Error {\n  constructor(\n    message: string,\n    public context?: any,\n  ) {\n    super(message);\n    this.name = \"SigningError\";\n    if (context) {\n      console.error(\"Signing Error Context:\", context);\n    }\n  }\n}\n", "explanation": "**Purpose:** Define custom error classes for transaction, network, and signing errors.\n\n**Functionality:**\n\n* Create three custom error classes:\n\t+ `TransactionError`: logs context when created.\n\t+ `NetworkError`: no additional functionality beyond standard Error class.\n\t+ `SigningError`: logs context when created.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/errors.ts", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'utils/errors.ts':\n\n**Summary:**\n\nThe `errors.ts` file defines custom error classes for transaction, network, and signing errors, providing contextual logging for `TransactionError` and `SigningError`, while maintaining standard Error class functionality for `NetworkError`."}
{"code": "import useSWR from \"swr\";\nimport { IABIFunctionDescription, IContract } from \"@/types\";\nimport { useState } from \"react\";\nimport { useLocalStorage } from \"usehooks-ts\";\n\nexport const useContracts = () => {\n  const [erroMessage, setErrorMessage] = useState(\"\");\n  const [disabledKeys, setDisabledKeys] = useLocalStorage<number[]>(\n    \"disabled-contracts\",\n    [],\n  );\n  const {\n    data: contracts = [],\n    error,\n    mutate: mutateContracts,\n  } = useSWR<IContract[]>(\"/api/contracts\", fetcher);\n\n  const onUpload = async (props: {\n    address: string;\n    name: string;\n    description: string;\n    chainId: number;\n    abi?: string;\n  }) => {\n    setErrorMessage(\"\");\n\n    return await mutateContracts(\n      async () => {\n        const resp = await fetch(\"/api/contracts\", {\n          method: \"POST\",\n          body: JSON.stringify(props),\n        });\n        const json = await resp.json();\n\n        if (json.error) {\n          setErrorMessage(json.error);\n        }\n\n        if (json.contracts) {\n          return json.contracts;", "explanation": "Here is a concise summary:\n\n**Purpose:** A custom React hook (`useContracts`) for managing contracts, including fetching, uploading, and storing data.\n\n**Functionality:**\n\n* Fetches contract list from API\n* Allows uploading new contracts with associated metadata\n* Stores disabled contract keys in local storage\n* Updates contract list when changes occur", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/hooks/useContracts.tsx", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'utils/hooks/useContracts.tsx':\n\n**Summary:** `useContracts` hook manages contract data with API fetch, upload, and local storage features. It provides functions for removing, editing, and updating contracts, leveraging caching and validation mechanisms."}
{"code": "        }\n      },\n      { revalidate: true },\n    );\n  };\n\n  const onRemove = async (key: number) => {\n    setErrorMessage(\"\");\n\n    return await mutateContracts(\n      async () => {\n        const resp = await fetch(\"/api/contracts\", {\n          method: \"DELETE\",\n          body: JSON.stringify({ key }),\n        });\n        const json = await resp.json();\n\n        if (json.error) {\n          setErrorMessage(json.error);\n        }\n\n        if (json.contracts) {\n          return json.contracts;\n        }\n      },\n      { revalidate: true },\n    );\n  };\n\n  const onEdit = async (props: {\n    key: number;\n    name?: string;\n    description?: string;\n    context?: string;\n    abiDescriptions?: IABIFunctionDescription[];\n  }) => {\n    setErrorMessage(\"\");\n\n    return await mutateContracts(\n      async () => {\n        const resp = await fetch(\"/api/contracts\", {\n          method: \"PATCH\",\n          body: JSON.stringify(props),\n        });\n        const json = await resp.json();\n\n        if (json.error) {", "explanation": "Here is a concise summary:\n\n**Functions**\n\n* `onRemove`: Deletes a contract with given key, updates contracts list.\n* `onEdit`: Edits a contract properties (name, description, context, ABI functions), updates contracts list.\n\nAll functions use the `mutateContracts` function to update data and revalidate the cache.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/hooks/useContracts.tsx", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'utils/hooks/useContracts.tsx':\n\n**Summary:** `useContracts` hook manages contract data with API fetch, upload, and local storage features. It provides functions for removing, editing, and updating contracts, leveraging caching and validation mechanisms."}
{"code": "          setErrorMessage(json.error);\n        }\n\n        if (json.contracts) {\n          return json.contracts;\n        }\n      },\n      { revalidate: true },\n    );\n  };\n\n  return {\n    disabledKeys,\n    setDisabledKeys,\n    contracts,\n    isLoading: !error && !contracts,\n    errorMessage: erroMessage || error?.message || \"\",\n    setErrorMessage,\n    onUpload,\n    onRemove,\n    onEdit,\n  };\n};\n\nconst fetcher = (url: string) =>\n  fetch(url).then((res) => res.json().then((d) => d.contracts as IContract[]));\n", "explanation": "Here is a concise summary:\n\n**Functionality Summary**\n\nThis block uses `fetch` to retrieve JSON data from a URL, processes the response, and returns an object with various properties (e.g., disabled keys, error message) for display and interaction. The process includes setting an error message if retrieval fails, checking for contracts in the response, and revalidating if applicable.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/hooks/useContracts.tsx", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'utils/hooks/useContracts.tsx':\n\n**Summary:** `useContracts` hook manages contract data with API fetch, upload, and local storage features. It provides functions for removing, editing, and updating contracts, leveraging caching and validation mechanisms."}
{"code": "import { IContract } from \"@/types\";\nimport { KVCollection } from \"./kvCollection\";\n\nclass ContractCollection extends KVCollection<Omit<IContract, \"key\">> {\n  public async get(): Promise<IContract[]> {\n    return (await super.get()) as IContract[];\n  }\n}\n\nexport const contractCollection = new ContractCollection(\"contracts:\");\n", "explanation": "Here is a summary of the purpose and functionality:\n\n**Purpose:** A collection class for contracts, extending KVCollection.\n\n**Functionality:** Retrieves and returns an array of contracts from storage, with methods for getting all contracts.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/kv/collections.ts", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'utils/kv/collections.ts':\n\n\"Provides a collection class for contracts that retrieves and manages contracts stored in KVCollection.\""}
{"code": "import { kv } from \"@vercel/kv\";\n\nexport class KVCache<T> {\n  private cachePrefix: string;\n\n  constructor(cachePrefix: string) {\n    this.cachePrefix = cachePrefix;\n  }\n\n  private getStorageKey(id: string) {\n    return `${this.cachePrefix}:${id}`;\n  }\n\n  public async set(key: string, item: T): Promise<void> {\n    await kv.set(this.getStorageKey(key), JSON.stringify(item));\n  }\n\n  public async delete(key: string): Promise<void> {\n    await kv.del(this.getStorageKey(key));\n  }\n\n  public async get(key: string): Promise<T | null> {\n    return kv.get(this.getStorageKey(key));\n  }\n}\n", "explanation": "**Purpose:** A cache utility class for storing and retrieving data using Vercel's Key-Value (KV) store.\n\n**Functionality:** Provides set, delete, and get methods for caching data with customizable prefix.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/kv/kvCache.ts", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary:\n\n`kvCache.ts`: A cache utility class that leverages Vercel's KV store, offering `set`, `delete`, and `get` methods with customizable prefix for efficient data storage and retrieval."}
{"code": "import { kv } from \"@vercel/kv\";\n\nexport class KVCollection<T> {\n  private cachePrefix: string;\n\n  constructor(cachePrefix: string) {\n    this.cachePrefix = cachePrefix;\n  }\n\n  private getStorageKey() {\n    return `${this.cachePrefix}:members`;\n  }\n\n  private async getAutoInc() {\n    return ((await kv.get(`${this.cachePrefix}:autoInc`)) as number) ?? 0;\n  }\n\n  private async onAutoInc() {\n    const autoInc = await this.getAutoInc();\n    await kv.set(`${this.cachePrefix}:autoInc`, autoInc + 1);\n  }\n\n  public async add(item: T): Promise<T & { key: number }> {\n    const autoInc = await this.getAutoInc();\n    const members = await this.get();\n\n    const newItem = { key: autoInc, ...item };\n    const valueToSet = [...members, newItem].filter((m) => m.key > -1);\n\n    await kv.set(this.getStorageKey(), valueToSet);\n\n    await this.onAutoInc();\n\n    return newItem;\n  }\n\n  public async update(item: Partial<T> & { key: number }): Promise<void> {\n    const members = await this.get();\n\n    const valueToSet = members", "explanation": "**Summary**\n\nThis code defines a KVCollection class that provides an interface for storing and retrieving data in a Vercel Key-Value (KV) store. It allows adding, updating, and retrieving items from the collection with automatic incrementing IDs.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/kv/kvCollection.ts", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and to-the-point holistic summary of the file 'utils/kv/kvCollection.ts':\n\nThe KVCollection class provides an interface for storing and retrieving data in a Vercel Key-Value store, with features including auto-incrementing IDs, cache management, and CRUD (Create, Read, Update, Delete) operations."}
{"code": "      .filter((m) => m.key > -1)\n      .map((m) => (m.key === item.key ? { ...m, ...item } : m));\n\n    await kv.set(this.getStorageKey(), valueToSet);\n\n    await this.onAutoInc();\n  }\n\n  public async delete(key: number): Promise<void> {\n    const members = await this.get();\n    const valueToSet = members.filter((m) => m.key !== key && m.key > -1);\n    await kv.set(this.getStorageKey(), valueToSet);\n  }\n\n  public async get(): Promise<(T & { key: number })[]> {\n    return (await kv.get(this.getStorageKey())) ?? [];\n  }\n\n  public async reset() {\n    await kv.del(`${this.cachePrefix}:autoInc`);\n    await kv.del(this.getStorageKey());\n  }\n}\n", "explanation": "Here is a concise summary:\n\n**Class Functionality:**\n\n* Filters and updates key-value pairs in cache storage.\n* Manages auto-incrementing keys.\n* Provides methods for deleting, getting, and resetting cache data.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/kv/kvCollection.ts", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise and to-the-point holistic summary of the file 'utils/kv/kvCollection.ts':\n\nThe KVCollection class provides an interface for storing and retrieving data in a Vercel Key-Value store, with features including auto-incrementing IDs, cache management, and CRUD (Create, Read, Update, Delete) operations."}
{"code": "import { concat } from \"@langchain/core/utils/stream\";\nimport {\n  BaseTransformOutputParser,\n  OutputParserException,\n} from \"@langchain/core/output_parsers\";\n\nconst isToolCallFinished = (metadata: Record<string, any>) =>\n  // metadata?.done_reason === \"stop\" is not exclusive to responses that are tool_calls\n  // but its the stop signal for all responses that are tool calls from local llama3.1\n  metadata?.finish_reason === \"tool_calls\" || metadata?.done_reason === \"stop\";\n\nexport class CustomParser extends BaseTransformOutputParser<string> {\n  lc_namespace = [\"langchain\", \"output_parsers\"];\n  gathered: any = undefined;\n  hasToolCall: boolean = false;\n\n  constructor(fields?: {}) {\n    super(fields);\n  }\n\n  async parse(text: string): Promise<string> {\n    return text;\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n\n  async parseResult(llmOutputs: any[]): Promise<string> {\n    if (!llmOutputs.length) {\n      throw new OutputParserException(\n        \"Output parser did not receive any generations.\",\n      );", "explanation": "Here is a concise summary of the purpose and functionality:\n\n**Purpose:** Custom output parser for LangChain.\n\n**Functionality:**\n\n* Checks if LLama responses are finished (finished_reason === 'tool_calls' or done_reason === 'stop').\n* Parses LLama outputs into a string format.\n* Throws exception if no generations are received.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/CustomParser.ts", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise summary of `utils/llm/CustomParser.ts`:\n\n**Purpose:** Parse LLama outputs to extract relevant information.\n\n**Functionality:** Checks for finished responses, parses outputs into strings, and throws exceptions if no generations are received. Extracts tool calls from LLma outputs and returns associated data in a specific format, or returns text output otherwise."}
{"code": "    }\n    let output = \"\";\n\n    try {\n      const message = llmOutputs[0]?.message;\n      if (message?.tool_call_chunks?.length || message?.tool_calls?.length) {\n        this.hasToolCall = true;\n        this.gathered =\n          this.gathered !== undefined\n            ? concat(this.gathered, message)\n            : message;\n      } else {\n        output = llmOutputs[0].text;\n      }\n\n      if (isToolCallFinished(message?.response_metadata) && this.hasToolCall) {\n        output = JSON.stringify({ toolCall: this.gathered?.tool_calls[0] });\n      }\n\n      return output;\n    } catch (e: any) {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${output}\". Error: ${e.message}`,\n      );\n    }\n  }\n}\n", "explanation": "Here is a summary of the purpose and functionality of this block:\n\n**Purpose:** Parse LLm output and extract relevant information.\n\n**Functionality:** Determine if an LLm output contains a tool call, gather associated data, and return it in a specific format. If no tool call is found, returns the text output.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/CustomParser.ts", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise summary of `utils/llm/CustomParser.ts`:\n\n**Purpose:** Parse LLama outputs to extract relevant information.\n\n**Functionality:** Checks for finished responses, parses outputs into strings, and throws exceptions if no generations are received. Extracts tool calls from LLma outputs and returns associated data in a specific format, or returns text output otherwise."}
{"code": "import { AbiFunction, AbiParameter } from \"abitype\";\nimport { ZodArray, ZodBoolean, ZodNumber, ZodString, z } from \"zod\";\nimport { DynamicStructuredTool } from \"@langchain/core/tools\";\nimport { Magic } from \"@magic-sdk/admin\";\nimport { getTransactionReceipt } from \"@/utils/tee\";\nimport { TransactionError, NetworkError, SigningError } from \"@/utils/errors\";\nimport { IContract } from \"@/types\";\n\nconst magic = await Magic.init(process.env.MAGIC_SECRET_KEY);\ntype IZodGeneric = ZodBoolean | ZodNumber | ZodString;\n\nexport const getToolsFromContracts = (\n  contracts: IContract[],\n  didToken?: string,\n  encryptionContext?: string,\n) =>\n  contracts.flatMap((contract) =>\n    (contract.abi ?? [])\n      .filter((f: any) => f.name && f.type === \"function\")\n      .map(generateToolFromABI(contract, didToken, encryptionContext)),\n  );\n\nexport const getContractABIDescriptions = (\n  contract: IContract,\n  abi: AbiFunction[],\n) =>\n  abi\n    .filter((f: any) => f.name && f.type === \"function\")\n    .flatMap((func) => [\n      {", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Generate tools from contract ABIs (Application Binary Interfaces).\n\n**Functionality:** Two main functions are provided:\n\n1. `getToolsFromContracts`: Takes an array of contracts, optional DID token, and encryption context, and returns an array of tools generated from each contract's function ABI.\n2. `getContractABIDescriptions`: Takes a contract and its ABI function array, filters the functions by name, and returns an array of descriptions for these functions.\n\nThese functions appear to be part of a larger framework for interacting with blockchain contracts using Magic, a blockchain platform.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/generateToolFromABI.ts", "chunk_number": 1, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a holistic summary of the file 'utils/llm/generateToolFromABI.ts':\n\n**Purpose:** Generate dynamic tool configurations for interacting with blockchain contracts using Magic, including tools from contract ABIs (Application Binary Interfaces) and handling transaction data.\n\n**Functionality:**\n\n* Two main functions: `getToolsFromContracts` generates tools from each contract's function ABI and `getContractABIDescriptions` filters functions by name to return descriptions.\n* Additional functionality includes generating tool schemas, input fields, and dynamic structured tools for interacting with smart contracts.\n* Other features include input description generation, type conversion, and detailed tool descriptions, as well as executing ABI functions with user-provided arguments using Magic's user metadata and a contract.\n* Lastly, the file also handles promise resolution for transaction data, catching errors and returning JSON responses."}
{"code": "        name: func.name,\n        description: getToolDescription(contract, func),\n        valueDescription: \"\",\n        inputs: func.inputs.map((input) => ({\n          name: input.name ?? \"\",\n          description: getInputDescription(input),\n        })),\n      },\n    ]);\n\nconst generateToolFromABI =\n  (contract: IContract, didToken?: string, encryptionContext?: string) =>\n  (func: AbiFunction, _: number, abi: AbiFunction[]): any => {\n    const name = getToolName(contract, func, abi);\n    const abiDescription = contract.abiDescriptions?.find((d) =>\n      abi.find((f) => d.name === f.name && d.inputs.length === f.inputs.length),\n    );\n\n    let schema: any = {};\n    if (abiDescription?.valueDescription) {\n      schema.transactionValue = z\n        .string()\n        .describe(abiDescription?.valueDescription);\n    }\n\n    func.inputs.forEach((input) => {\n      const inputDescription =\n        abiDescription?.inputs.find((i) => i.name === input.name)\n          ?.description ?? getInputDescription(input);\n", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Generate a tool from an ABI (Application Binary Interface) function.\n\n**Functionality:** Extracts inputs, name, and description from an ABI function and uses it to create a tool schema with value description and input fields.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/generateToolFromABI.ts", "chunk_number": 2, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a holistic summary of the file 'utils/llm/generateToolFromABI.ts':\n\n**Purpose:** Generate dynamic tool configurations for interacting with blockchain contracts using Magic, including tools from contract ABIs (Application Binary Interfaces) and handling transaction data.\n\n**Functionality:**\n\n* Two main functions: `getToolsFromContracts` generates tools from each contract's function ABI and `getContractABIDescriptions` filters functions by name to return descriptions.\n* Additional functionality includes generating tool schemas, input fields, and dynamic structured tools for interacting with smart contracts.\n* Other features include input description generation, type conversion, and detailed tool descriptions, as well as executing ABI functions with user-provided arguments using Magic's user metadata and a contract.\n* Lastly, the file also handles promise resolution for transaction data, catching errors and returning JSON responses."}
{"code": "      schema[input.name ?? \"\"] =\n        getInputSchema(input).describe(inputDescription);\n    });\n\n    return new DynamicStructuredTool({\n      name,\n      description: `${abiDescription?.description ?? \"\"}. Extra context: ${\n        contract.context ?? \"\"\n      }`,\n      schema: z.object(schema),\n      func: getToolFunction(didToken, encryptionContext, contract, func),\n    });\n  };\n\nconst getToolName = (\n  contract: IContract,\n  func: AbiFunction,\n  abi: AbiFunction[],\n) => {\n  const funcOverloadIndex = abi\n    .filter((_func) => _func.name === func.name)\n    .findIndex(\n      (_func) => JSON.stringify(_func.inputs) === JSON.stringify(func.inputs),\n    );\n\n  return `${contract.key}_${func.name}_${funcOverloadIndex}`;\n};\n\nconst getInputSchema = (input: AbiParameter) => {\n  const isArray = input.type.includes(\"[]\");\n  const castType = getInputCastType(input);\n\n  let zodType: IZodGeneric | ZodArray<IZodGeneric> =\n    castType === \"bool\" ? z.boolean() : z.string();\n\n  if (isArray) {\n    zodType = z.array(zodType);\n  }", "explanation": "Here is a summary of the purpose and functionality of this block:\n\n**Purpose:** To generate a dynamic tool configuration for interacting with a smart contract.\n\n**Functionality:**\n\n1. Generates a schema for an input based on its AbiParameter.\n2. Creates a DynamicStructuredTool instance with:\n\t* A name derived from the contract, function, and overload index.\n\t* A description combining the ABI description and contract context.\n\t* The generated schema.\n\t* A tool function obtained by calling `getToolFunction`.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/generateToolFromABI.ts", "chunk_number": 3, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a holistic summary of the file 'utils/llm/generateToolFromABI.ts':\n\n**Purpose:** Generate dynamic tool configurations for interacting with blockchain contracts using Magic, including tools from contract ABIs (Application Binary Interfaces) and handling transaction data.\n\n**Functionality:**\n\n* Two main functions: `getToolsFromContracts` generates tools from each contract's function ABI and `getContractABIDescriptions` filters functions by name to return descriptions.\n* Additional functionality includes generating tool schemas, input fields, and dynamic structured tools for interacting with smart contracts.\n* Other features include input description generation, type conversion, and detailed tool descriptions, as well as executing ABI functions with user-provided arguments using Magic's user metadata and a contract.\n* Lastly, the file also handles promise resolution for transaction data, catching errors and returning JSON responses."}
{"code": "  return zodType;\n};\n\nconst getInputDescription = (input: AbiParameter) => {\n  const isArray = input.type.includes(\"[]\");\n  const castType = getInputCastType(input);\n  const descriptor = isArray ? \"array\" : \"a\";\n  return `${descriptor} ${castType} input called ${input.name}`;\n};\n\nconst getInputCastType = (input: AbiParameter) =>\n  input.type.match(/^bool/)\n    ? \"bool\"\n    : input.type.match(/^u?(int|fixed)\\d+/)\n    ? \"numeric\"\n    : \"string\";\n\nconst getToolDescription = (contract: IContract, func: AbiFunction) => {\n  const inputLength = func.inputs.length;\n  const inputString = func.inputs\n    .map(({ name, type }) => `\"${name}\" of type ${type}`)\n    .join(\", \");\n\n  return `This is a function called ${func.name}.  It belongs to the contract with the address ${contract.address} and the name ${contract.name}.  It takes ${inputLength} inputs as arguments consisting of ${inputString}`;\n};\n\nconst getToolFunction =\n  (\n    didToken: string | undefined,\n    encryptionContext: string | undefined,\n    contract: IContract,", "explanation": "Here is a summary of the purpose and functionality of this block:\n\n**Purpose:** Generate tool descriptions for smart contracts based on their functions.\n\n**Functionality:**\n\n* `getInputDescription`: Returns a string describing an input parameter (e.g., \"a numeric input called name\").\n* `getInputCastType`: Converts a contract's ABI type to a human-readable description (e.g., \"numeric\" or \"string\").\n* `getToolDescription`: Generates a detailed string describing a contract function, including its inputs.\n* `getToolFunction`: Not fully visible in the provided snippet, but appears to be a factory for generating tool descriptions based on contract and input parameters.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/generateToolFromABI.ts", "chunk_number": 4, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a holistic summary of the file 'utils/llm/generateToolFromABI.ts':\n\n**Purpose:** Generate dynamic tool configurations for interacting with blockchain contracts using Magic, including tools from contract ABIs (Application Binary Interfaces) and handling transaction data.\n\n**Functionality:**\n\n* Two main functions: `getToolsFromContracts` generates tools from each contract's function ABI and `getContractABIDescriptions` filters functions by name to return descriptions.\n* Additional functionality includes generating tool schemas, input fields, and dynamic structured tools for interacting with smart contracts.\n* Other features include input description generation, type conversion, and detailed tool descriptions, as well as executing ABI functions with user-provided arguments using Magic's user metadata and a contract.\n* Lastly, the file also handles promise resolution for transaction data, catching errors and returning JSON responses."}
{"code": "    func: AbiFunction,\n  ) =>\n  async (args: Record<string, any>): Promise<string> => {\n    // This function should return a string according to the link hence the stringifed JSON\n    // https://js.langchain.com/v0.2/docs/how_to/custom_tools/#dynamicstructuredtool\n    if (!encryptionContext) {\n      return JSON.stringify({\n        message: \"No encryptionContext\",\n        status: \"failure\",\n        payload: {},\n      });\n    }\n\n    if (!didToken) {\n      return JSON.stringify({\n        message: \"No didToken\",\n        status: \"failure\",\n        payload: {},\n      });\n    }\n    const ensuredArgOrder = func.inputs.map((input) => {\n      return args[input.name ?? \"\"];\n    });\n\n    const userMetadata = await magic.users.getMetadataByToken(didToken);\n    const publicAddress = userMetadata.publicAddress ?? \"\";\n\n    try {\n      const txReceipt = await getTransactionReceipt({\n        contract: contract,\n        functionName: func.name,\n        value: args.transactionValue ?? 0,\n        args: ensuredArgOrder,", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Execute an ABI function with user-provided arguments, using Magic's user metadata and a contract.\n\n**Functionality:**\n\n* Verify presence of `encryptionContext` and `didToken`.\n* Extract required inputs from `args` object.\n* Get user metadata using `magic.users.getMetadataByToken(didToken)`.\n* Call the ABI function with extracted inputs and transaction data.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/generateToolFromABI.ts", "chunk_number": 5, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a holistic summary of the file 'utils/llm/generateToolFromABI.ts':\n\n**Purpose:** Generate dynamic tool configurations for interacting with blockchain contracts using Magic, including tools from contract ABIs (Application Binary Interfaces) and handling transaction data.\n\n**Functionality:**\n\n* Two main functions: `getToolsFromContracts` generates tools from each contract's function ABI and `getContractABIDescriptions` filters functions by name to return descriptions.\n* Additional functionality includes generating tool schemas, input fields, and dynamic structured tools for interacting with smart contracts.\n* Other features include input description generation, type conversion, and detailed tool descriptions, as well as executing ABI functions with user-provided arguments using Magic's user metadata and a contract.\n* Lastly, the file also handles promise resolution for transaction data, catching errors and returning JSON responses."}
{"code": "        publicAddress,\n        encryptionContext,\n      });\n      const { transactionHash, message, status } = txReceipt;\n\n      return JSON.stringify({\n        message: message,\n        status,\n        payload: {\n          transactionHash,\n        },\n      });\n    } catch (error) {\n      // Not Rethrowing known errors here so that they can be shown inline in the UI\n      if (\n        [NetworkError, SigningError, TransactionError].some(\n          (errType) => error instanceof errType,\n        )\n      ) {\n        // Just to get around TS\n        if (error instanceof TransactionError) {\n          console.error(`${error.constructor.name}:`, error.message);\n          const transactionHash = error.context?.hash;\n          return JSON.stringify({\n            message: error.message,\n            status: \"failure\",\n            payload: transactionHash ? { transactionHash } : {},\n          });\n        }\n      }\n\n      console.error(\"Unexpected Error:\", error);\n      return JSON.stringify({\n        message: \"Unexpected Error\",", "explanation": "Here is a concise summary of the block:\n\n**Purpose:** Returns a JSON string with transaction data, including status and payload (transaction hash) in case of success or error message and status.\n\n**Functionality:** Handles promise resolution for an `txReceipt` object, catching errors and returning a JSON response with error details if applicable.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/generateToolFromABI.ts", "chunk_number": 6, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a holistic summary of the file 'utils/llm/generateToolFromABI.ts':\n\n**Purpose:** Generate dynamic tool configurations for interacting with blockchain contracts using Magic, including tools from contract ABIs (Application Binary Interfaces) and handling transaction data.\n\n**Functionality:**\n\n* Two main functions: `getToolsFromContracts` generates tools from each contract's function ABI and `getContractABIDescriptions` filters functions by name to return descriptions.\n* Additional functionality includes generating tool schemas, input fields, and dynamic structured tools for interacting with smart contracts.\n* Other features include input description generation, type conversion, and detailed tool descriptions, as well as executing ABI functions with user-provided arguments using Magic's user metadata and a contract.\n* Lastly, the file also handles promise resolution for transaction data, catching errors and returning JSON responses."}
{"code": "        status: \"failure\",\n        payload: {},\n      });\n    }\n  };\n", "explanation": "This block appears to be a JavaScript object containing error handling information:\n\n* Status is set to \"failure\".\n* The payload, or data accompanying the error, is an empty object.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/generateToolFromABI.ts", "chunk_number": 7, "total_chunks": 7}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a holistic summary of the file 'utils/llm/generateToolFromABI.ts':\n\n**Purpose:** Generate dynamic tool configurations for interacting with blockchain contracts using Magic, including tools from contract ABIs (Application Binary Interfaces) and handling transaction data.\n\n**Functionality:**\n\n* Two main functions: `getToolsFromContracts` generates tools from each contract's function ABI and `getContractABIDescriptions` filters functions by name to return descriptions.\n* Additional functionality includes generating tool schemas, input fields, and dynamic structured tools for interacting with smart contracts.\n* Other features include input description generation, type conversion, and detailed tool descriptions, as well as executing ABI functions with user-provided arguments using Magic's user metadata and a contract.\n* Lastly, the file also handles promise resolution for transaction data, catching errors and returning JSON responses."}
{"code": "import { BaseChatModelParams } from \"@langchain/core/language_models/chat_models\";\nimport { ChatOllama, ChatOllamaInput } from \"@langchain/ollama\";\nimport { ChatOpenAI } from \"@langchain/openai\";\nimport { ChatTogetherAI } from \"@langchain/community/chat_models/togetherai\";\nimport { ChatFireworks } from \"@langchain/community/chat_models/fireworks\";\nimport { InferenceEnum } from \"@/types\";\nimport { MODELS } from \"@/constants\";\n\ntype ModelMapping = {\n  openai: ChatOpenAI;\n  // ollama: ChatOllama;\n  // together: ChatTogetherAI;\n  // fireworks: ChatFireworks;\n};\n\nexport function getModel(\n  modelName: string,\n  overrides: BaseChatModelParams | ChatOllamaInput = {},\n): ModelMapping[keyof ModelMapping] {\n  // const inference = findInferenceByModelName(modelName);\n\n  // if (inference === \"ollama\") {\n  //   return new ChatOllama({\n  //     model: modelName,\n  //     temperature: 0,\n  //     streaming: true,\n  //     ...overrides,\n  //   });\n  // }\n\n  // if (inference === \"together\") {\n  //   return new ChatTogetherAI({", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Returns a chat model instance based on the specified `modelName` and optional overrides.\n\n**Functionality:** Maps a `modelName` to an instance of a specific chat model (e.g., OpenAI, Ollama) and returns it.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/getModel.ts", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'utils/llm/getModel.ts':\n\n**Returns a chat model instance based on the specified `modelName` and optional overrides, or finds an inference model by its name in a predefined dictionary.**"}
{"code": "  //     model: modelName,\n  //     temperature: 0,\n  //     streaming: true,\n  //     ...overrides,\n  //   });\n  // }\n\n  // if (inference === \"fireworks\") {\n  //   return new ChatFireworks({\n  //     model: modelName,\n  //     temperature: 0,\n  //     maxTokens: undefined,\n  //     timeout: undefined,\n  //     streaming: true,\n  //     ...overrides,\n  //   });\n  // }\n\n  return new ChatOpenAI({\n    model: modelName,\n    temperature: 0,\n    streaming: true,\n    ...overrides,\n  });\n}\n\nexport function applyStructuredOutput(\n  model: ModelMapping[keyof ModelMapping],\n  schema: ChatOpenAI[\"withStructuredOutput\"],\n) {\n  // if (model instanceof ChatOllama) {\n  //   return model.withStructuredOutput(schema);\n  // }\n  // if (model instanceof ChatFireworks) {\n  //   return model.withStructuredOutput(schema);\n  // }\n  return model.withStructuredOutput(schema, { strict: true });\n}\n\nexport function findInferenceByModelName(\n  modelName: string,\n): InferenceEnum | undefined {\n  for (const key in MODELS) {", "explanation": "Here is a summary of the purpose and functionality of this block:\n\n**Purpose:** Instantiate an inference model with specific parameters.\n\n**Functionality:**\n\n* A function returns a new instance of a specified chat model (e.g., ChatOpenAI, ChatFireworks) based on the `modelName` input.\n* The model is instantiated with default temperature and streaming settings, and additional parameters can be overridden using the `overrides` object.\n* A separate function (`applyStructuredOutput`) applies a structured output schema to an existing model instance.\n* Another function (`findInferenceByModelName`) searches for an inference model by its name in a predefined dictionary (`MODELS`).", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/getModel.ts", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'utils/llm/getModel.ts':\n\n**Returns a chat model instance based on the specified `modelName` and optional overrides, or finds an inference model by its name in a predefined dictionary.**"}
{"code": "    if (MODELS[key as InferenceEnum].includes(modelName)) {\n      return key as InferenceEnum;\n    }\n  }\n  return undefined;\n}\n", "explanation": "**Function Purpose:** Returns a specific enum value (`InferenceEnum`) if a model name matches an existing model in the `MODELS` collection, otherwise returns `undefined`. \n\n**Key Functionality:** Contains an if-statement that checks for membership of `modelName` within a list of models (accessed via `MODELS[key as InferenceEnum]`). If true, it returns the corresponding enum value; if false, it returns undefined.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/getModel.ts", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'utils/llm/getModel.ts':\n\n**Returns a chat model instance based on the specified `modelName` and optional overrides, or finds an inference model by its name in a predefined dictionary.**"}
{"code": "import { Message as VercelChatMessage } from \"ai\";\nimport {\n  SystemMessage,\n  AIMessage,\n  HumanMessage,\n} from \"@langchain/core/messages\";\n\n/**\n * Maps an array of VercelChatMessage objects to corresponding LangChain message types.\n *\n * @param {VercelChatMessage[]} messages - An array of message objects from Vercel's AI framework, where each object contains a role and content.\n * @returns {(SystemMessage|AIMessage|HumanMessage)[]} An array of LangChain message objects based on the role of each message.\n *\n * @typedef {Object} VercelChatMessage\n * @property {string} role - The role of the message (e.g., \"system\", \"assistant\", \"human\").\n * @property {string} content - The content of the message.\n *\n * The role is mapped to the following LangChain message types:\n * - \"system\" -> SystemMessage\n * - \"assistant\" -> AIMessage\n * - Any other role defaults to HumanMessage.\n */\nexport function mapToLcMessages(messages: VercelChatMessage[]) {\n  return messages.map(", "explanation": "Here is a concise summary:\n\n**Functionality:** Maps an array of Vercel Chat Message objects to corresponding LangChain message types.\n\n**Purpose:** Converts Vercel AI chat messages into LangChain-compatible messages based on their role.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/mapToLcMessages.ts", "chunk_number": 1, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise summary:\n\n**mapToLcMessages.ts**: Maps Vercel Chat Messages to LangChain-compatible messages based on their role. Converts AI chat messages into LangChain formats (SystemMessage, AIMessage, HumanMessage) with defaulting to HumanMessage for unrecognized roles."}
{"code": "    ({ role, content }: { role: string; content: string }) => {\n      switch (role) {\n        case \"system\":\n          return new SystemMessage(content);\n        case \"assistant\":\n          return new AIMessage(content);\n        default:\n          return new HumanMessage(content);\n      }\n    },\n  );\n}\n", "explanation": "**Function Summary**\n\nThis is a JavaScript function that creates messages based on their role.\n\n* It takes an object with `role` and `content` properties.\n* Based on the `role`, it returns an instance of one of three message classes: `SystemMessage`, `AIMessage`, or `HumanMessage`.\n* If the `role` is not recognized, it defaults to `HumanMessage`.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/mapToLcMessages.ts", "chunk_number": 2, "total_chunks": 2}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here's a concise summary:\n\n**mapToLcMessages.ts**: Maps Vercel Chat Messages to LangChain-compatible messages based on their role. Converts AI chat messages into LangChain formats (SystemMessage, AIMessage, HumanMessage) with defaulting to HumanMessage for unrecognized roles."}
{"code": "import { IContract } from \"@/types\";\nimport { SystemMessage } from \"@langchain/core/messages\";\nimport { ChatPromptTemplate } from \"@langchain/core/prompts\";\nimport { AbiFunction, formatAbi, parseAbi } from \"abitype\";\nimport { z } from \"zod\";\nimport { RunnableSequence } from \"@langchain/core/runnables\";\nimport { Message as VercelChatMessage } from \"ai\";\nimport { mapToLcMessages } from \"./mapToLcMessages\";\nimport { applyStructuredOutput, getModel } from \"./getModel\";\n\nexport type IReasoningPromptResponse = {\n  address: string;\n  abi: AbiFunction[];\n}[];\n\nconst structuredOutputSchema = z\n  .array(\n    z.object({\n      address: z\n        .string()\n        .describe(\n          \"The contract address that has a function that could be used\",\n        ),\n      functionSignatures: z\n        .array(z.string())\n        .describe(\"The functions from contract address that applies\"),\n    }),\n  )\n  .describe(", "explanation": "Here is a concise summary of the block:\n\n**Purpose:** This block imports various dependencies and exports types, functions, and a schema for processing contract data and generating prompts.\n\n**Functionality:** It appears to be part of a larger system that processes contracts and generates prompts using data from those contracts. The code seems to handle ABI (Application Binary Interface) data and uses it to generate structured output schemas.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/reasoningPrompt.ts", "chunk_number": 1, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'utils/llm/reasoningPrompt.ts':\n\nThis module processes contract data and generates prompts, handling ABI (Application Binary Interface) data and chat history to provide structured output schemas. It filters and transforms contract objects, generates function strings from ABI arrays, and returns reasoning prompt responses based on model input and user interactions."}
{"code": "    \"An array of objects containing the contract address and list of applicable functions. If no reasonable match found this can be empty\",\n  );\n\nconst trimIfStartsWith = (str: string, prefix: string) => {\n  if (str.startsWith(prefix)) {\n    return str.slice(prefix.length);\n  } else {\n    return str;\n  }\n};\n\nexport async function reasoningPrompt({\n  modelName,\n  input,\n  contracts,\n  chatHistory,\n}: {\n  modelName: string;\n  input: string;\n  contracts: IContract[];\n  chatHistory: VercelChatMessage[];\n}): Promise<IReasoningPromptResponse> {\n  if (!modelName) {\n    return [];\n  }\n\n  // Reduce contract.abi to just functions\n  const contractFunctions = contracts\n    .filter(({ abi }) => abi?.length)\n    .map(({ abi, ...contract }) => {\n      return {\n        ...contract,\n        abi: abi?.filter((f: any) => f.name && f.type === \"function\"),\n      };\n    });\n\n  // Generate a readable string of functions from the items in the abi array\n  const readableAbiFunction = contractFunctions\n    .map(({ address, name, abi }) => {", "explanation": "Here is a summary of the purpose and functionality of this block:\n\n**Purpose:** This code generates a reasoning prompt response based on model input, contracts, and chat history.\n\n**Functionality:**\n\n* It filters and transforms an array of contract objects (`contracts`) by removing non-function ABI (Application Binary Interface) entries.\n* It uses the filtered contracts to generate a readable string of functions from each contract's ABI array.\n* If no reasonable match is found, it returns an empty response.\n* The `reasoningPrompt` function takes in model name, input, contracts, and chat history as inputs and returns a promise that resolves to a reasoning prompt response.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/reasoningPrompt.ts", "chunk_number": 2, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'utils/llm/reasoningPrompt.ts':\n\nThis module processes contract data and generates prompts, handling ABI (Application Binary Interface) data and chat history to provide structured output schemas. It filters and transforms contract objects, generates function strings from ABI arrays, and returns reasoning prompt responses based on model input and user interactions."}
{"code": "      // Convert abi object to string. Remove the word function to reduce token use\n      const abiFunctions = formatAbi(abi ?? []).map((func) =>\n        trimIfStartsWith(func, \"function \"),\n      );\n\n      return `${name}:${address}\\n${abiFunctions.join(\"\\n\")}`;\n    })\n    .join(\"\\n\");\n\n  const model = getModel(modelName, { streaming: false });\n  const modelWithOutput = applyStructuredOutput(\n    model,\n    // @ts-ignore\n    z.object({\n      results: structuredOutputSchema,\n    }),\n  );\n\n  const prompt = ChatPromptTemplate.fromMessages([\n    new SystemMessage(\n      [\n        \"You're an assistant whose tasked with narrowing the list of smart contracts and their associated functions signatures that you think apply given the conversation provided.\",\n        \"You will be provided with a list functions the user can call.\",\n        \"Based on the user's prompt, determine what functions they are trying to call. It can be fuzzy match\",", "explanation": "Here is a concise summary:\n\n**Purpose:** Convert ABI object to string for display.\n\n**Functionality:** Removes \"function\" keyword from function signatures in the ABI object, then combines with contract name and address for output.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/reasoningPrompt.ts", "chunk_number": 3, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'utils/llm/reasoningPrompt.ts':\n\nThis module processes contract data and generates prompts, handling ABI (Application Binary Interface) data and chat history to provide structured output schemas. It filters and transforms contract objects, generates function strings from ABI arrays, and returns reasoning prompt responses based on model input and user interactions."}
{"code": "        \"There can be multiple functions across multiple contracts that apply to the user's input.\",\n        \"Do not try to parse, understand, confirm, or interpret function inputs from the user's query. A second assistant will determine that.\",\n        \"The following is a list of abi's and their functions (in the format {contract name}:{address} followed by the list of function signatures):\",\n        \"return functionSignatures in the same structure given to you namely functionName(list of arguments)\",\n        \"If theyre no matches its fine to return nothing.\",\n        \"Do not hallucinate. Do not make up function signatures.\",\n      ].join(\" \"),\n    ),\n    {\n      type: \"system\",\n      content:\n        \"\\nStart of Available ABI Functions\\n{abiContext}\\n End of Available ABI functions\\n\",\n    },\n    ...mapToLcMessages(chatHistory),\n    { type: \"human\", content: \"{input}\" },\n  ]);\n  const chain = RunnableSequence.from([prompt, modelWithOutput]);\n\n  try {\n    const answer = await chain.invoke({\n      input,", "explanation": "Here is a concise summary:\n\nThis block processes user input (via chat) by comparing it to a list of contract function signatures (ABIs). It returns any matching function signatures without interpretation or hallucination.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/reasoningPrompt.ts", "chunk_number": 4, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'utils/llm/reasoningPrompt.ts':\n\nThis module processes contract data and generates prompts, handling ABI (Application Binary Interface) data and chat history to provide structured output schemas. It filters and transforms contract objects, generates function strings from ABI arrays, and returns reasoning prompt responses based on model input and user interactions."}
{"code": "      abiContext: readableAbiFunction,\n    });\n\n    if (!answer?.results || !answer?.results?.length) {\n      return [];\n    }\n\n    const parsedResult = structuredOutputSchema.parse(answer.results);\n\n    const filteredAbi = parsedResult.reduce(\n      (accu, currentValue) => {\n        const { address, functionSignatures } = currentValue;\n        const abi = parseAbi(\n          // append `function ` to the returned string so it can be parsed by parseAbi\n          functionSignatures.map((func: string) => `function ${func}`),\n        ) as AbiFunction[];\n        accu.push({ address, abi });\n        return accu;\n      },\n      [] as { address: string; abi: AbiFunction[] }[],\n    );\n    return filteredAbi;\n  } catch (error) {\n    console.error(\"Invalid JSON:\", error);\n    return [];\n  }\n}\n", "explanation": "Here is a concise summary of the purpose and functionality of this block:\n\n**Purpose:** Filter and parse ABI data from structured output schema.\n\n**Functionality:**\n\n* Processes answer.results array\n* Parses array using structuredOutputSchema\n* Filters ABI data by address and function signatures\n* Returns filtered ABI data in array format", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/reasoningPrompt.ts", "chunk_number": 5, "total_chunks": 5}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'utils/llm/reasoningPrompt.ts':\n\nThis module processes contract data and generates prompts, handling ABI (Application Binary Interface) data and chat history to provide structured output schemas. It filters and transforms contract objects, generates function strings from ABI arrays, and returns reasoning prompt responses based on model input and user interactions."}
{"code": "import { Message as VercelChatMessage } from \"ai\";\nimport { ChatPromptTemplate } from \"@langchain/core/prompts\";\nimport { mapToLcMessages } from \"./mapToLcMessages\";\n\nexport const getStructuredPrompt = (chatHistory: VercelChatMessage[]) => {\n  const chatHistoryAsMessages = mapToLcMessages(chatHistory);\n\n  return ChatPromptTemplate.fromMessages([\n    {\n      type: \"system\",\n      content:\n        \"You are to interact with smart contracts on behalf of the user. The smart contract addresses are {contractAddresses}. You will be provided with functions that represent the functions in the ABI the user can call. Based on the user's prompt, determine what function they are trying to call, and extract the appropriate inputs. If there is ambiguity about which contract they want to call the function on, ask for clarification. If a tool needs a timestamp, use {timestamp} if it is defined\",\n    },\n    ...chatHistoryAsMessages,\n    {\n      type: \"user\",\n      content: \"{input}\",\n    },\n  ]);\n};\n", "explanation": "**Summary**\n\nThis block, `getStructuredPrompt`, takes an array of chat history messages and returns a structured prompt template using the `ChatPromptTemplate` class. It maps the chat history to messages, prepends a system message with instructions, appends user input, and prepares the template for conversation.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/structuredPrompt.ts", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary:\n\nThe `getStructuredPrompt` function creates a structured prompt template from an array of chat history messages, adding context and user input for conversation preparation."}
{"code": "import { DynamicStructuredTool } from \"@langchain/core/tools\";\nimport { z } from \"zod\";\nimport { ChatPromptTemplate } from \"@langchain/core/prompts\";\nimport { RunnableLambda } from \"@langchain/core/runnables\";\nimport { getModel } from \"./getModel\";\n\nconst timestampTool = new DynamicStructuredTool({\n  name: \"calculateTimestamp\",\n  description:\n    \"When the user asks you about time, determine the difference in seconds the user is referring to, then pass that amount of seconds to this function\",\n  schema: z.object({\n    seconds: z\n      .number()\n      .describe(\n        \"This is the relative amount of seconds to compute the timestamp for\",\n      ),\n  }),\n  func: async ({ seconds }: { seconds: number }) =>\n    Math.floor(new Date(Date.now() + seconds * 1000).getTime() / 1000),\n});\n\nexport const getTimestampLambda = (modelName: string) => {\n  const unboundModel = getModel(modelName).bindTools([timestampTool]);\n  return new RunnableLambda({", "explanation": "Here is a concise summary:\n\n**Purpose:** Create a timestamp calculator tool that takes seconds as input and returns a timestamp.\n\n**Functionality:** The `getTimestampLambda` function binds this tool to a model, allowing users to query for timestamps based on a given number of seconds.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/timestampLambda.ts", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'utils/llm/timestampLambda.ts' that is concise and to the point:\n\n**Purpose:** Calculates and returns a timestamp based on user input.\n\n**Functionality:** Takes user input, current time, and uses an AI model to generate and validate a timestamp."}
{"code": "    func: async (props: { input: string; contractAddresses: string[] }) => {\n      const analysisPrompt = ChatPromptTemplate.fromTemplate(\n        \"You are an expert on determining the relative amount of seconds based on a user input. The current time as a unix timestamp is: {timestamp}. The current time as a humanized string is {humanizedTimestamp}.  Input: {input}\",\n      );\n      const result = await analysisPrompt.pipe(unboundModel).invoke({\n        input: props.input,\n        timestamp: `${Math.floor(Date.now() / 1000)}`,\n        humanizedTimestamp: `${new Date().toLocaleDateString(\n          \"en-US\",\n        )} ${new Date().toLocaleTimeString(\"en-US\")}`,\n      });\n\n      let timestamp: number | undefined;\n      if (result.tool_calls?.[0]?.args) {\n        timestamp = await timestampTool.invoke(\n          result.tool_calls[0].args as { seconds: number },\n        );\n      }\n      return {\n        input: props.input,\n        contractAddresses: props.contractAddresses,\n        timestamp,\n      };\n    },", "explanation": "Here is a summary of the purpose and functionality of this block:\n\n**Purpose:** Calculates and returns a timestamp based on user input.\n\n**Functionality:** Takes in user input and current time, uses AI model to analyze and generate a timestamp, then calls an external tool to validate the result, returning the final timestamp along with other input parameters.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/timestampLambda.ts", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'utils/llm/timestampLambda.ts' that is concise and to the point:\n\n**Purpose:** Calculates and returns a timestamp based on user input.\n\n**Functionality:** Takes user input, current time, and uses an AI model to generate and validate a timestamp."}
{"code": "  });\n};\n", "explanation": "This appears to be a function closure in JavaScript.\n\n* Purpose: Defines an anonymous function\n* Functionality: None (empty body)", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/llm/timestampLambda.ts", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'utils/llm/timestampLambda.ts' that is concise and to the point:\n\n**Purpose:** Calculates and returns a timestamp based on user input.\n\n**Functionality:** Takes user input, current time, and uses an AI model to generate and validate a timestamp."}
{"code": "export function shortenAddress(\n  address: string,\n  startLength = 6,\n  endLength = 6,\n) {\n  if (!address || address.length !== 42) {\n    throw new Error(\"Invalid Ethereum address\");\n  }\n\n  const start = address.slice(0, startLength + 2); // Include '0x'\n  const end = address.slice(-endLength);\n\n  return `${start}...${end}`;\n}\n", "explanation": "**Function Purpose:** Shortens a Ethereum address to show a specified number of characters at the beginning and end, omitting the middle.\n\n**Key Functionality:**\n\n* Validates input as a 42-character Ethereum address\n* Extracts specified lengths from start and end of address\n* Returns shortened address with ellipsis ( \"...\") in place of omitted characters", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/shortenAddress.ts", "chunk_number": 1, "total_chunks": 1}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary:\n\nThe `shortenAddress` function shortens an Ethereum address to show specified character lengths at the start and end, omitting the middle section and replacing it with an ellipsis."}
{"code": "export const ERC20_ABI = [\n  {\n    constant: true,\n    inputs: [],\n    name: \"name\",\n    outputs: [{ name: \"\", type: \"string\" }],\n    type: \"function\",\n  },\n  {\n    constant: false,\n    inputs: [\n      { name: \"_spender\", type: \"address\" },\n      { name: \"_value\", type: \"uint256\" },\n    ],\n    name: \"approve\",\n    outputs: [{ name: \"\", type: \"bool\" }],\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: \"totalSupply\",\n    outputs: [{ name: \"\", type: \"uint256\" }],\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [{ name: \"_owner\", type: \"address\" }],\n    name: \"balanceOf\",\n    outputs: [{ name: \"balance\", type: \"uint256\" }],\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: \"symbol\",\n    outputs: [{ name: \"\", type: \"string\" }],\n    type: \"function\",\n  },\n  {\n    constant: false,\n    inputs: [\n      { name: \"_from\", type: \"address\" },\n      { name: \"_to\", type: \"address\" },\n      { name: \"_value\", type: \"uint256\" },\n    ],\n    name: \"transferFrom\",", "explanation": "**Summary:** \n\nThe `ERC20_ABI` block defines a set of functions for interacting with an ERC-20 compliant smart contract, including methods to retrieve token information (name, symbol, total supply), check balances, and execute transactions (approve, transfer).", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/tee/erc20.ts", "chunk_number": 1, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'utils/tee/erc20.ts':\n\nDefines ERC-20 compliant token functions for interacting with smart contracts: retrieve token info, check balances, execute transactions (approve, transfer), and handles related events (Approval, Transfer)."}
{"code": "    outputs: [{ name: \"\", type: \"bool\" }],\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: \"decimals\",\n    outputs: [{ name: \"\", type: \"uint8\" }],\n    type: \"function\",\n  },\n  {\n    constant: false,\n    inputs: [\n      { name: \"_to\", type: \"address\" },\n      { name: \"_value\", type: \"uint256\" },\n    ],\n    name: \"transfer\",\n    outputs: [{ name: \"\", type: \"bool\" }],\n    type: \"function\",\n  },\n  {\n    constant: false,\n    inputs: [\n      { name: \"_owner\", type: \"address\" },\n      { name: \"_spender\", type: \"address\" },\n    ],\n    name: \"allowance\",\n    outputs: [{ name: \"remaining\", type: \"uint256\" }],\n    type: \"function\",\n  },\n  {\n    inputs: [{ name: \"_initialSupply\", type: \"uint256\" }],\n    payable: false,\n    type: \"constructor\",\n  },\n  {\n    payable: false,\n    type: \"fallback\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      { indexed: true, name: \"owner\", type: \"address\" },\n      { indexed: true, name: \"spender\", type: \"address\" },\n      { indexed: false, name: \"value\", type: \"uint256\" },", "explanation": "Here is a concise summary:\n\nThis block appears to be a set of Solidity functions (smart contract methods) that manage an ERC-20 token's balance and permissions, including transfer, allowance, and constructor functionality.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/tee/erc20.ts", "chunk_number": 2, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'utils/tee/erc20.ts':\n\nDefines ERC-20 compliant token functions for interacting with smart contracts: retrieve token info, check balances, execute transactions (approve, transfer), and handles related events (Approval, Transfer)."}
{"code": "    ],\n    name: \"Approval\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      { indexed: true, name: \"from\", type: \"address\" },\n      { indexed: true, name: \"to\", type: \"address\" },\n      { indexed: false, name: \"value\", type: \"uint256\" },\n    ],\n    name: \"Transfer\",\n    type: \"event\",\n  },\n];\n", "explanation": "This block defines two event types for a smart contract:\n\n* \"Approval\": an event with no parameters\n* \"Transfer\": an event with three parameters (from, to, value)", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/tee/erc20.ts", "chunk_number": 3, "total_chunks": 3}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a concise summary of the file 'utils/tee/erc20.ts':\n\nDefines ERC-20 compliant token functions for interacting with smart contracts: retrieve token info, check balances, execute transactions (approve, transfer), and handles related events (Approval, Transfer)."}
{"code": "import axios from \"axios\";\nimport * as ethers from \"ethers\";\nimport crypto from \"crypto\";\nimport { TransactionError, SigningError } from \"@/utils/errors\";\nimport { KVCache } from \"@/utils/kv/kvCache\";\nimport { ChainIdEnum, IContract } from \"@/types\";\nimport { CHAINS } from \"@/constants\";\nimport { ERC20_ABI } from \"./erc20\";\n\nconst FUNDER_PUBLIC_ADDRESS = process.env.TEE_FUNDER_PUBLIC_ADDRESS ?? \"\";\nconst FUNDER_ENCRYPTION_CONTEXT =\n  process.env.TEE_FUNDER_ENCRYPTION_CONTEXT ?? \"\";\n\ntype IWalletTxPayload = {\n  type: number;\n  to: string;\n  chainId: number;\n  data: string;\n  value: string;\n  nonce?: number;\n  gas?: number;\n  maxFeePerGas?: number;\n  maxPriorityFeePerGas?: number;\n};\n\ntype IWallet = {\n  wallet_id: string;\n  access_key: string;\n  wallet_address: string;\n};\n\ntype ITransactionReceipt = {\n  transactionHash: string;\n  message: string;\n  status: string;\n};\n\nconst TEE_URL = process.env.TEE_URL;\n\nconst axiosInstance = axios.create({\n  baseURL: `${TEE_URL}/v1/api`,\n  timeout: 10000,\n  headers: {", "explanation": "Here is a concise summary of the block's purpose and functionality:\n\n**Purpose:** A JavaScript module for interacting with a TEE (Trusted Execution Environment) API, allowing users to send transactions and manage wallets.\n\n**Functionality:** The module uses Axios to make requests to the TEE API, utilizing ethers.js for Ethereum-related operations. It also provides error handling mechanisms and caching using KVCache.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/tee/index.ts", "chunk_number": 1, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'utils/tee/index.ts':\n\nThis file provides a suite of functions for interacting with a TEE (Trusted Execution Environment) API, enabling users to send transactions and manage wallets across multiple blockchain networks. The module utilizes Axios for API requests, ethers.js for Ethereum operations, and KVCache for caching wallet data. It includes error handling mechanisms and functions for signing and broadcasting transactions, as well as retrieving wallet information and estimated gas costs."}
{"code": "    \"x-magic-secret-key\": process.env.MAGIC_SECRET_KEY,\n  },\n});\n\nasync function getWalletGroups() {\n  try {\n    const response = await axiosInstance.get(\"/wallet_groups\");\n    return response.data;\n  } catch (e) {\n    if (e instanceof Error) {\n      console.error(\"Error fetching Wallet Groups\", e.message);\n    } else {\n      console.log(e);\n    }\n    throw e;\n  }\n}\n\nasync function createWallet(body: {\n  wallet_group_id: string;\n  network: \"mainnet\";\n  encryption_context: string;\n}) {\n  try {\n    const response = await axiosInstance.post(\"/wallet\", body);\n    return response.data;\n  } catch (e) {\n    if (e instanceof Error) {\n      console.error(\"Error fetching Wallet\", e.message);\n    } else {\n      console.log(e);\n    }\n    throw e;\n  }\n}\n\nasync function signTransaction({\n  payload,\n  access_key,\n  wallet_id,\n  encryption_context,\n}: {\n  payload: IWalletTxPayload;\n  access_key: string;\n  wallet_id: string;\n  encryption_context: string;\n}) {\n  try {\n    const response = await axiosInstance.post(\"/wallet/sign_transaction\", {", "explanation": "**Summary**\n\nThis block defines three asynchronous functions:\n\n1. `getWalletGroups()`: Retrieves wallet groups from a server.\n2. `createWallet(body)`: Creates a new wallet on a server, taking in a wallet group ID, network, and encryption context.\n3. `signTransaction({})`: Signs a transaction for a specific wallet, requiring access key, wallet ID, payload, and encryption context.\n\nThese functions use the Axios library to make HTTP requests to the `/wallet_groups`, `/wallet`, and `/wallet/sign_transaction` endpoints respectively.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/tee/index.ts", "chunk_number": 2, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'utils/tee/index.ts':\n\nThis file provides a suite of functions for interacting with a TEE (Trusted Execution Environment) API, enabling users to send transactions and manage wallets across multiple blockchain networks. The module utilizes Axios for API requests, ethers.js for Ethereum operations, and KVCache for caching wallet data. It includes error handling mechanisms and functions for signing and broadcasting transactions, as well as retrieving wallet information and estimated gas costs."}
{"code": "      payload: payload,\n      encryption_context: encryption_context,\n      access_key: access_key,\n      wallet_id: wallet_id,\n    });\n    return response.data.data.signed_transaction;\n  } catch (error) {\n    console.error(\"Error signing transaction\", error);\n    if (error instanceof Error) {\n      throw new SigningError(`Signing error: ${error.message}`);\n    }\n    throw error;\n  }\n}\n\nexport async function getWalletUUIDandAccessKey(\n  publicAddress: string,\n  encryptionContext?: string,\n): Promise<IWallet> {\n  try {\n    // pa = public address\n    const walletCache = new KVCache<string>(\"pa:\");\n    const rawWallet = await walletCache.get(publicAddress);\n\n    if (rawWallet) {\n      const existingWallet = JSON.parse(rawWallet);\n      return {\n        wallet_id: existingWallet.uuid,\n        access_key: existingWallet.access_key,\n        wallet_address: existingWallet.public_address,\n      };\n    }\n\n    if (!encryptionContext)\n      throw new Error(\"Wallet not found and missing encryption context\");\n", "explanation": "Here is a concise summary:\n\n**Functionality:**\n\n* Signs a transaction using provided payload, encryption context, access key, and wallet ID.\n* Returns the signed transaction.\n\n**getWalletUUIDandAccessKey Function:**\n\n* Retrieves cached wallet data for a given public address.\n* If found, returns wallet UUID, access key, and wallet address.\n* If not found or missing encryption context, throws an error.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/tee/index.ts", "chunk_number": 3, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'utils/tee/index.ts':\n\nThis file provides a suite of functions for interacting with a TEE (Trusted Execution Environment) API, enabling users to send transactions and manage wallets across multiple blockchain networks. The module utilizes Axios for API requests, ethers.js for Ethereum operations, and KVCache for caching wallet data. It includes error handling mechanisms and functions for signing and broadcasting transactions, as well as retrieving wallet information and estimated gas costs."}
{"code": "    const walletGroups = await getWalletGroups();\n\n    // For now assume the first wallet group in case the magic tenant has more than one\n    const [walletGroup] = walletGroups.data;\n\n    const walletResponse = await createWallet({\n      wallet_group_id: walletGroup.uuid,\n      network: \"mainnet\",\n      encryption_context: encryptionContext,\n    });\n    const wallet = walletResponse.data;\n\n    await walletCache.set(publicAddress, JSON.stringify(wallet));\n\n    try {\n      await Promise.all([\n        transfer({\n          to: wallet.public_address,\n          value: \"0.001\",\n          chainId: 11155111, // sepolia\n        }),\n        transfer({\n          to: wallet.public_address,\n          value: \"0.001\",\n          chainId: 80002, // amoy\n        }),\n      ]);\n    } catch (e) {\n      if (e instanceof Error) {\n        console.error(\"Error funding Wallet\", e.message);\n      } else {\n        console.log(e);\n      }\n    }\n\n    return {\n      wallet_id: wallet.uuid,\n      access_key: wallet.access_key,", "explanation": "Here is a concise summary of the block:\n\n**Purpose:** Fund a new wallet on multiple blockchain networks (mainnet, sepolia, amoy) with an initial value.\n\n**Functionality:** Creates a new wallet, caches it in memory, and attempts to transfer small amounts of cryptocurrency to it on two separate chains, logging any errors that occur.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/tee/index.ts", "chunk_number": 4, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'utils/tee/index.ts':\n\nThis file provides a suite of functions for interacting with a TEE (Trusted Execution Environment) API, enabling users to send transactions and manage wallets across multiple blockchain networks. The module utilizes Axios for API requests, ethers.js for Ethereum operations, and KVCache for caching wallet data. It includes error handling mechanisms and functions for signing and broadcasting transactions, as well as retrieving wallet information and estimated gas costs."}
{"code": "      wallet_address: wallet.public_address,\n    };\n  } catch (e) {\n    if (e instanceof Error) {\n      console.error(\"Error fetching Wallet\", e.message);\n    } else {\n      console.log(e);\n    }\n    throw e;\n  }\n}\n\nconst ALCHEMY_KEY = process.env.ALCHEMY_API_KEY;\nconst getProvider = (chainId: ChainIdEnum) => {\n  const RPC_URL = `${CHAINS[chainId].rpcURI}${ALCHEMY_KEY}`;\n  return new ethers.JsonRpcProvider(RPC_URL);\n};\n\nasync function signAndBroadcastPayload({\n  chainId,\n  value,\n  data,\n  to,\n  publicAddress,\n  encryptionContext,\n}: {\n  chainId: ChainIdEnum;\n  value: string;\n  data: string;\n  to: string;\n  publicAddress: string;\n  encryptionContext: string;\n}): Promise<ITransactionReceipt> {\n  try {\n    const { wallet_id, wallet_address, access_key } =\n      await getWalletUUIDandAccessKey(publicAddress, encryptionContext);\n\n    let payload: IWalletTxPayload = { type: 2, to, chainId, data, value };\n    const provider = getProvider(chainId);\n    const [nonce, feeData, gasEstimate] = await Promise.all([", "explanation": "**Summary**\n\nThis block is responsible for signing and broadcasting a payload to a blockchain network. It:\n\n1. Retrieves wallet UUID and access key using `getWalletUUIDandAccessKey` function.\n2. Creates a payload with type, recipient address, chain ID, data, and value.\n3. Uses the `getProvider` function to get an Ethereum provider instance for the specified chain ID.\n4. Estimates gas fees, calculates nonce, and retrieves fee data.\n5. Signs the transaction using wallet information and broadcasts it to the network.\n\n**Functionality**\n\nThis block appears to be part of a larger system that enables transactions on multiple blockchain networks. It uses external dependencies such as `ethers` for interacting with Ethereum and an Alchemy API key for accessing blockchain data.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/tee/index.ts", "chunk_number": 5, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'utils/tee/index.ts':\n\nThis file provides a suite of functions for interacting with a TEE (Trusted Execution Environment) API, enabling users to send transactions and manage wallets across multiple blockchain networks. The module utilizes Axios for API requests, ethers.js for Ethereum operations, and KVCache for caching wallet data. It includes error handling mechanisms and functions for signing and broadcasting transactions, as well as retrieving wallet information and estimated gas costs."}
{"code": "      provider.getTransactionCount(wallet_address),\n      provider.getFeeData(),\n      getGasEstimate(provider, payload),\n    ]);\n\n    payload = {\n      ...payload,\n      nonce,\n      gas: Number(gasEstimate),\n      maxFeePerGas: Number(feeData.maxFeePerGas),\n      maxPriorityFeePerGas: Number(feeData.maxPriorityFeePerGas),\n    };\n\n    const signedTx = await signTransaction({\n      payload,\n      access_key,\n      wallet_id,\n      encryption_context: encryptionContext,\n    });\n\n    console.log({ signedTx });\n\n    let tx: ethers.ethers.TransactionResponse | null = null;\n    try {\n      tx = await provider.broadcastTransaction(signedTx);\n      const txReceipt = await tx.wait();\n      const transactionHash = txReceipt?.hash ?? \"\";\n      return {\n        transactionHash,\n        message: `Successfully added transaction ${transactionHash}`,\n        status: \"success\",\n      };\n    } catch (error) {\n      console.error(\"Error Broadcasting or waiting for transaction\", error);\n      if (error instanceof Error) {", "explanation": "Here is a concise summary:\n\n**Purpose:** Broadcast a signed Ethereum transaction.\n\n**Functionality:** \n\n1. Get the current nonce, fee data, and gas estimate.\n2. Update the payload with the nonce, gas, maxFeePerGas, and maxPriorityFeePerGas values.\n3. Sign the updated payload using an access key and encryption context.\n4. Broadcast the signed transaction to the Ethereum network.\n5. Wait for the transaction receipt and return its hash and a success message if successful, or an error message otherwise.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/tee/index.ts", "chunk_number": 6, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'utils/tee/index.ts':\n\nThis file provides a suite of functions for interacting with a TEE (Trusted Execution Environment) API, enabling users to send transactions and manage wallets across multiple blockchain networks. The module utilizes Axios for API requests, ethers.js for Ethereum operations, and KVCache for caching wallet data. It includes error handling mechanisms and functions for signing and broadcasting transactions, as well as retrieving wallet information and estimated gas costs."}
{"code": "        throw new TransactionError(error.message, tx);\n      }\n      throw error;\n    }\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n}\n\nasync function transfer({\n  to,\n  value: rawValue,\n  chainId,\n}: {\n  chainId: ChainIdEnum;\n  to: string;\n  value: string;\n}): Promise<ITransactionReceipt> {\n  const wrappedContract = new ethers.Contract(\n    FUNDER_PUBLIC_ADDRESS,\n    ERC20_ABI,\n    getProvider(chainId),\n  );\n\n  const value = ethers.parseEther(rawValue);\n  const data = wrappedContract.interface.encodeFunctionData(\"transfer\", [\n    to,\n    value,\n  ]);\n\n  return signAndBroadcastPayload({\n    chainId,\n    to,\n    value: \"0x\" + value.toString(16),\n    data,\n    publicAddress: FUNDER_PUBLIC_ADDRESS,\n    encryptionContext: FUNDER_ENCRYPTION_CONTEXT,\n  });\n}\n\nexport async function getTransactionReceipt({\n  contract,\n  functionName,\n  value: rawValue,\n  args,\n  publicAddress,\n  encryptionContext,\n}: {\n  contract: IContract;\n  functionName: string;\n  value: number;\n  args: any[];\n  publicAddress: string;", "explanation": "Here is a concise summary of the code:\n\n**Block Purpose:** Error handling and transaction execution functions.\n\n**Functionality:**\n\n1. **Error Handling**: Catches and logs errors, then re-throws them.\n2. **Transfer Function**: Transfers tokens on a blockchain by:\n\t* Creating an Ethereum contract instance.\n\t* Parsing and encoding function data for the transfer operation.\n\t* Signing and broadcasting the payload using `signAndBroadcastPayload` function.\n\nNote: This summary focuses on the overall purpose and functionality of the code, rather than detailing every line or implementation.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/tee/index.ts", "chunk_number": 7, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'utils/tee/index.ts':\n\nThis file provides a suite of functions for interacting with a TEE (Trusted Execution Environment) API, enabling users to send transactions and manage wallets across multiple blockchain networks. The module utilizes Axios for API requests, ethers.js for Ethereum operations, and KVCache for caching wallet data. It includes error handling mechanisms and functions for signing and broadcasting transactions, as well as retrieving wallet information and estimated gas costs."}
{"code": "  encryptionContext: string;\n}): Promise<ITransactionReceipt> {\n  const wrappedContract = new ethers.Contract(\n    contract.address,\n    contract.abi as ethers.InterfaceAbi,\n    getProvider(contract.chainId),\n  );\n\n  const data = wrappedContract.interface.encodeFunctionData(functionName, args);\n  const value = \"0x\" + BigInt(rawValue).toString(16);\n\n  return signAndBroadcastPayload({\n    chainId: contract.chainId,\n    to: contract.address,\n    value,\n    data,\n    publicAddress,\n    encryptionContext,\n  });\n}\n\nconst getGasEstimate = async (\n  provider: ethers.ethers.JsonRpcProvider,\n  payload: ethers.ethers.TransactionRequest,\n) => {\n  try {\n    return await provider.estimateGas(payload);\n  } catch (e) {\n    // Default gas\n    return BigInt(100_000);\n  }\n};\n\nexport async function hashPin(pin: string) {\n  try {\n    const hash = crypto.createHash(\"sha512\");\n    hash.update(pin);\n    return hash.digest(\"hex\");\n  } catch (error) {\n    console.error(\"Error hashing password:\", error);\n  }\n}\n", "explanation": "Here is a summary of each block:\n\n**Block 1**\nPurpose: Send a transaction with encrypted data.\nFunctionality: Calls `signAndBroadcastPayload` function with contract details, payload, public address, and encryption context.\n\n**Block 2**\nPurpose: Get an estimated gas cost for a transaction.\nFunctionality: Uses `estimateGas` method to estimate gas costs or returns a default value if failed.\n\n**Block 3**\nPurpose: Hash a PIN using SHA-512.\nFunctionality: Creates a hash object with the given pin and returns its digest as a hexadecimal string.", "metadata": {"repo": "magiclabs/hiro-chat", "file": "utils/tee/index.ts", "chunk_number": 8, "total_chunks": 8}, "repository_explanation": "This is a GitHub repository.\n\n**Purpose:** Development and hosting of HiroChat, a chat application.\n\n**Content:**\n\n* Code for HiroChat's frontend (client-side) using web technologies (e.g., JavaScript, HTML, CSS)\n* Possibly backend code or API integrations\n* Project configurations and dependencies", "file_summary": "Here is a holistic summary of the file 'utils/tee/index.ts':\n\nThis file provides a suite of functions for interacting with a TEE (Trusted Execution Environment) API, enabling users to send transactions and manage wallets across multiple blockchain networks. The module utilizes Axios for API requests, ethers.js for Ethereum operations, and KVCache for caching wallet data. It includes error handling mechanisms and functions for signing and broadcasting transactions, as well as retrieving wallet information and estimated gas costs."}
